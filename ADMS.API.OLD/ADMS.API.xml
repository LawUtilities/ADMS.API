<?xml version="1.0"?>
<doc>
    <assembly>
        <name>ADMS.API</name>
    </assembly>
    <members>
        <member name="T:ADMS.API.ActionConstraints.RequestHeaderMatchesMediaTypeAttribute">
            <summary>
                Validates request header
            </summary>
        </member>
        <member name="M:ADMS.API.ActionConstraints.RequestHeaderMatchesMediaTypeAttribute.#ctor(System.String,System.String,System.String[])">
            <summary>
                RequestHeaderMatchesMediaTypeAttribute constructor
            </summary>
            <param name="requestHeaderToMatch">Request Header to Match</param>
            <param name="mediaType">media Type</param>
            <param name="otherMediaTypes">other Media Types</param>
            <exception cref="T:System.ArgumentNullException">requestHeaderToMatch is null</exception>
            <exception cref="T:System.ArgumentException">media type or other media types are null</exception>
        </member>
        <member name="P:ADMS.API.ActionConstraints.RequestHeaderMatchesMediaTypeAttribute.Order">
            <summary>
                Search Order
            </summary>
        </member>
        <member name="M:ADMS.API.ActionConstraints.RequestHeaderMatchesMediaTypeAttribute.Accept(Microsoft.AspNetCore.Mvc.ActionConstraints.ActionConstraintContext)">
            <summary>
                Verifies match
            </summary>
            <param name="context">context to match</param>
            <returns>true if matched, false otherwise</returns>
        </member>
        <member name="T:ADMS.API.Controllers.DocumentAuditController">
            <summary>
            Controller for managing document audit records.
            Provides endpoints for retrieving paginated audit records for document activities,
            move/copy operations, and related audit trails.
            </summary>
            <remarks>
            This controller handles three types of audit records:
            - Document activities (create, update, delete, restore, check in/out)
            - Document move/copy FROM operations (where the document was moved/copied from)
            - Document move/copy TO operations (where the document was moved/copied to)
            
            All endpoints support pagination, sorting, and filtering through resource parameters.
            The controller implements consistent error handling, validation, and logging patterns.
            </remarks>
        </member>
        <member name="M:ADMS.API.Controllers.DocumentAuditController.#ctor(Microsoft.Extensions.Logging.ILogger{ADMS.API.Controllers.DocumentAuditController},ADMS.API.Services.IAdmsRepository,ADMS.API.Services.IPropertyMappingService,Microsoft.AspNetCore.Mvc.Infrastructure.ProblemDetailsFactory,ADMS.API.Services.IValidationService)">
            <summary>
            Controller for managing document audit records.
            Provides endpoints for retrieving paginated audit records for document activities,
            move/copy operations, and related audit trails.
            </summary>
            <remarks>
            This controller handles three types of audit records:
            - Document activities (create, update, delete, restore, check in/out)
            - Document move/copy FROM operations (where the document was moved/copied from)
            - Document move/copy TO operations (where the document was moved/copied to)
            
            All endpoints support pagination, sorting, and filtering through resource parameters.
            The controller implements consistent error handling, validation, and logging patterns.
            </remarks>
        </member>
        <member name="M:ADMS.API.Controllers.DocumentAuditController.GetDocumentActivityAuditsAsync(System.Guid,System.Guid,ADMS.API.ResourceParameters.DocumentAuditsResourceParameters)">
            <summary>
            Retrieves paginated document activity audit records for a specific document.
            </summary>
            <remarks>
            Returns audit records for document activities such as:
            - Document creation, updates, deletion, and restoration
            - Check-in and check-out operations
            - File uploads and modifications
            
            The endpoint supports pagination, sorting, and field validation.
            All returned DTOs are validated to ensure data integrity.
            </remarks>
            <param name="matterId">The unique identifier of the matter containing the document.</param>
            <param name="documentId">The unique identifier of the document for which to retrieve audit records.</param>
            <param name="resourceParameters">Pagination and sorting parameters including page size, page number, and order by fields.</param>
            <returns>
            <para>200 OK - A paged list of document activity audit records with pagination metadata in headers.</para>
            <para>400 BadRequest - Invalid input parameters or validation errors.</para>
            <para>404 NotFound - The specified matter or document does not exist.</para>
            <para>500 InternalServerError - An unexpected server error occurred.</para>
            </returns>
        </member>
        <member name="M:ADMS.API.Controllers.DocumentAuditController.GetDocumentMoveFromAuditsAsync(System.Guid,System.Guid,ADMS.API.ResourceParameters.DocumentAuditsResourceParameters)">
            <summary>
            Retrieves paginated document move/copy FROM audit records for a specific document.
            </summary>
            <remarks>
            Returns audit records showing where the document was moved or copied FROM.
            This includes the source matter information and the user who performed the operation.
            
            The endpoint supports pagination, sorting, and comprehensive error handling.
            Validation ensures data integrity and proper error responses.
            </remarks>
            <param name="matterId">The unique identifier of the matter containing the document.</param>
            <param name="documentId">The unique identifier of the document for which to retrieve move/copy FROM audit records.</param>
            <param name="resourceParameters">Pagination and sorting parameters including page size, page number, and order by fields.</param>
            <returns>
            <para>200 OK - A paged list of move/copy FROM audit records with pagination metadata in headers.</para>
            <para>400 BadRequest - Invalid input parameters or validation errors.</para>
            <para>404 NotFound - The specified matter or document does not exist.</para>
            <para>500 InternalServerError - An unexpected server error occurred.</para>
            </returns>
        </member>
        <member name="M:ADMS.API.Controllers.DocumentAuditController.GetDocumentMoveToAuditsAsync(System.Guid,System.Guid,ADMS.API.ResourceParameters.DocumentAuditsResourceParameters)">
            <summary>
            Retrieves paginated document move/copy TO audit records for a specific document.
            </summary>
            <remarks>
            Returns audit records showing where the document was moved or copied TO.
            This includes the destination matter information and the user who performed the operation.
            
            The endpoint supports pagination, sorting, and comprehensive error handling.
            All responses include consistent pagination metadata and proper HTTP status codes.
            </remarks>
            <param name="matterId">The unique identifier of the matter containing the document.</param>
            <param name="documentId">The unique identifier of the document for which to retrieve move/copy TO audit records.</param>
            <param name="resourceParameters">Pagination and sorting parameters including page size, page number, and order by fields.</param>
            <returns>
            <para>200 OK - A paged list of move/copy TO audit records with pagination metadata in headers.</para>
            <para>400 BadRequest - Invalid input parameters or validation errors.</para>
            <para>404 NotFound - The specified matter or document does not exist.</para>
            <para>500 InternalServerError - An unexpected server error occurred.</para>
            </returns>
        </member>
        <member name="M:ADMS.API.Controllers.DocumentAuditController.ValidateRequestParametersAsync(System.Guid,System.Guid,ADMS.API.ResourceParameters.DocumentAuditsResourceParameters)">
            <summary>
            Validates the common request parameters for all audit endpoints.
            </summary>
            <remarks>
            Performs validation on:
            - ModelState validation
            - Matter existence
            - Document existence
            
            This method centralizes common validation logic to reduce code duplication
            and ensure consistent error handling across all endpoints.
            </remarks>
            <param name="matterId">The matter ID to validate.</param>
            <param name="documentId">The document ID to validate.</param>
            <param name="resourceParameters">The resource parameters to validate.</param>
            <returns>An ActionResult if validation fails, null if validation passes.</returns>
        </member>
        <member name="M:ADMS.API.Controllers.DocumentAuditController.ValidatePropertyMapping``1(System.String)">
            <summary>
            Validates property mapping for sorting parameters.
            </summary>
            <remarks>
            Ensures that the requested order by fields are valid for the specified DTO type.
            This prevents SQL injection and ensures proper sorting functionality.
            </remarks>
            <typeparam name="TDto">The DTO type to validate property mapping for.</typeparam>
            <param name="orderBy">The order by string to validate.</param>
            <returns>An ActionResult if validation fails, null if validation passes.</returns>
        </member>
        <member name="M:ADMS.API.Controllers.DocumentAuditController.CreateInternalServerErrorResponse(System.String)">
            <summary>
            Creates a standardized internal server error response.
            </summary>
            <remarks>
            Provides consistent error responses for unexpected server errors.
            The operation context helps identify which operation failed for better debugging.
            </remarks>
            <param name="operationContext">A description of the operation that failed.</param>
            <returns>A standardized internal server error response.</returns>
        </member>
        <member name="T:ADMS.API.Controllers.DocumentController">
            <summary>
            Controller for managing documents within a matter in the ADMS system.
            </summary>
            <remarks>
            This controller provides comprehensive document management functionality including:
            - Document creation with file upload, virus scanning, and validation
            - Document retrieval with pagination, filtering, and data shaping
            - Document updates with metadata and file content changes
            - Document operations (copy, move, delete, check in/out)
            - Document history and audit trail access
            
            All endpoints implement consistent error handling, centralized validation,
            structured logging, and security best practices including virus scanning
            and file type validation.
            
            The controller follows RESTful principles and supports content negotiation
            for JSON and XML responses.
            </remarks>
        </member>
        <member name="M:ADMS.API.Controllers.DocumentController.#ctor(Microsoft.Extensions.Logging.ILogger{ADMS.API.Controllers.DocumentController},ADMS.API.Services.IAdmsRepository,MapsterMapper.IMapper,ADMS.API.Services.IPropertyMappingService,ADMS.API.Services.IPropertyCheckerService,Microsoft.AspNetCore.Mvc.Infrastructure.ProblemDetailsFactory,ADMS.API.Services.IValidationService,ADMS.API.Services.IVirusScanner,ADMS.API.Services.IFileStorage)">
            <summary>
            Controller for managing documents within a matter in the ADMS system.
            </summary>
            <remarks>
            This controller provides comprehensive document management functionality including:
            - Document creation with file upload, virus scanning, and validation
            - Document retrieval with pagination, filtering, and data shaping
            - Document updates with metadata and file content changes
            - Document operations (copy, move, delete, check in/out)
            - Document history and audit trail access
            
            All endpoints implement consistent error handling, centralized validation,
            structured logging, and security best practices including virus scanning
            and file type validation.
            
            The controller follows RESTful principles and supports content negotiation
            for JSON and XML responses.
            </remarks>
        </member>
        <member name="F:ADMS.API.Controllers.DocumentController.MaxUploadFileSize">
            <summary>
            Maximum allowed file size for uploads (50 MB).
            </summary>
        </member>
        <member name="M:ADMS.API.Controllers.DocumentController.CreateDocumentAsync(System.Guid,ADMS.API.Models.DocumentForCreationDto,Microsoft.AspNetCore.Http.IFormFile,System.Threading.CancellationToken)">
            <summary>
            Creates a new document within the specified matter.
            </summary>
            <remarks>
            This endpoint accepts both document metadata and a file upload to create
            a new document. The process includes:
            
            1. Input validation and file size checks
            2. Virus scanning using ClamAV
            3. File type validation and MIME type detection
            4. Business rule validation (duplicate filename, etc.)
            5. Document persistence and file storage
            6. Audit trail creation
            
            The endpoint supports multipart/form-data for file uploads and enforces
            security policies including file type restrictions and virus scanning.
            </remarks>
            <param name="matterId">The unique identifier of the matter to contain the document.</param>
            <param name="document">The document metadata including filename and extension.</param>
            <param name="fileUpload">The file content to be uploaded and associated with the document.</param>
            <param name="cancelToken">Cancellation token for the async operation.</param>
            <returns>
            <para>201 Created - Document successfully created with location header.</para>
            <para>400 BadRequest - Invalid input parameters or validation errors.</para>
            <para>404 NotFound - The specified matter does not exist.</para>
            <para>409 Conflict - A document with the same filename already exists.</para>
            <para>413 PayloadTooLarge - File size exceeds the maximum allowed limit.</para>
            <para>415 UnsupportedMediaType - File type is not allowed.</para>
            <para>422 UnprocessableEntity - File contains virus or malware.</para>
            <para>500 InternalServerError - Unexpected server error occurred.</para>
            </returns>
        </member>
        <member name="M:ADMS.API.Controllers.DocumentController.GetDocumentsAsync(System.Guid,ADMS.API.ResourceParameters.DocumentsResourceParameters)">
            <summary>
            Retrieves a paginated list of documents for the specified matter.
            </summary>
            <remarks>
            This endpoint supports advanced querying capabilities including:
            - Pagination with configurable page size
            - Sorting by multiple fields with ascending/descending order
            - Filtering by document filename
            - Data shaping to return only requested fields
            - Response caching for improved performance
            
            Pagination metadata is returned in the X-Pagination response header.
            The endpoint supports both GET and HEAD methods for metadata retrieval.
            </remarks>
            <param name="matterId">The unique identifier of the matter containing the documents.</param>
            <param name="documentsResourceParameters">Parameters for pagination, filtering, sorting, and data shaping.</param>
            <returns>
            <para>200 OK - Paginated list of documents with metadata in headers.</para>
            <para>400 BadRequest - Invalid parameters or validation errors.</para>
            <para>404 NotFound - The specified matter does not exist.</para>
            <para>500 InternalServerError - Unexpected server error occurred.</para>
            </returns>
        </member>
        <member name="M:ADMS.API.Controllers.DocumentController.GetDocumentAsync(System.Guid,System.Guid,System.String)">
            <summary>
            Retrieves a specific document by its identifier.
            </summary>
            <remarks>
            This endpoint retrieves a single document with optional data shaping
            to return only requested fields. The response includes document metadata,
            file information, and audit trail summary.
            
            Data shaping allows clients to specify which properties to include
            in the response using a comma-separated list of field names.
            </remarks>
            <param name="matterId">The unique identifier of the matter containing the document.</param>
            <param name="documentId">The unique identifier of the document to retrieve.</param>
            <param name="fields">Optional comma-separated list of fields to include in the response.</param>
            <returns>
            <para>200 OK - The requested document with specified fields.</para>
            <para>400 BadRequest - Invalid parameters or field specifications.</para>
            <para>404 NotFound - The specified matter or document does not exist.</para>
            <para>500 InternalServerError - Unexpected server error occurred.</para>
            </returns>
        </member>
        <member name="M:ADMS.API.Controllers.DocumentController.UpdateDocumentAsync(System.Guid,System.Guid,ADMS.API.Models.DocumentForUpdateDto,Microsoft.AspNetCore.Http.IFormFile,System.Threading.CancellationToken)">
            <summary>
            Updates an existing document's metadata and optionally replaces its file content.
            </summary>
            <remarks>
            This endpoint supports partial updates of document metadata and complete
            file replacement. When a new file is provided, it undergoes the same
            validation process as document creation including virus scanning and
            file type validation.
            
            The update operation is atomic - either all changes succeed or none are applied.
            An audit trail entry is automatically created for the update operation.
            </remarks>
            <param name="matterId">The unique identifier of the matter containing the document.</param>
            <param name="documentId">The unique identifier of the document to update.</param>
            <param name="document">The updated document metadata.</param>
            <param name="fileUpload">Optional new file content to replace the existing file.</param>
            <param name="cancelToken">Cancellation token for the async operation.</param>
            <returns>
            <para>204 NoContent - Document successfully updated.</para>
            <para>400 BadRequest - Invalid input parameters or validation errors.</para>
            <para>404 NotFound - The specified matter or document does not exist.</para>
            <para>413 PayloadTooLarge - File size exceeds the maximum allowed limit.</para>
            <para>415 UnsupportedMediaType - File type is not allowed.</para>
            <para>422 UnprocessableEntity - File contains virus or malware.</para>
            <para>500 InternalServerError - Unexpected server error occurred.</para>
            </returns>
        </member>
        <member name="M:ADMS.API.Controllers.DocumentController.DeleteDocumentAsync(System.Guid,System.Guid)">
            <summary>
            Soft deletes a document by marking it as deleted without removing it from storage.
            </summary>
            <remarks>
            This endpoint performs a soft delete operation, marking the document as deleted
            while preserving it for audit purposes. The document can be restored later
            if needed. An audit trail entry is created to track the deletion.
            
            The physical file remains on storage but becomes inaccessible through normal
            document retrieval operations.
            </remarks>
            <param name="matterId">The unique identifier of the matter containing the document.</param>
            <param name="documentId">The unique identifier of the document to delete.</param>
            <returns>
            <para>204 NoContent - Document successfully deleted.</para>
            <para>400 BadRequest - Invalid input parameters.</para>
            <para>404 NotFound - The specified matter or document does not exist.</para>
            <para>409 Conflict - Document cannot be deleted in its current state.</para>
            <para>500 InternalServerError - Unexpected server error occurred.</para>
            </returns>
        </member>
        <member name="M:ADMS.API.Controllers.DocumentController.CopyDocumentAsync(System.Guid,ADMS.API.Models.DocumentWithoutRevisionsDto)">
            <summary>
            Copies a document to the specified target matter.
            </summary>
            <remarks>
            Creates a copy of the specified document in the target matter while
            preserving the original. The copied document receives a new identifier
            and creation timestamp, but maintains the same content and metadata.
            
            An audit trail entry is created for both the source and target documents
            to track the copy operation.
            </remarks>
            <param name="matterId">The unique identifier of the target matter for the document copy.</param>
            <param name="document">The document to be copied (without revision history).</param>
            <returns>
            <para>200 OK - Document successfully copied with the new document details.</para>
            <para>400 BadRequest - Invalid input parameters or validation errors.</para>
            <para>404 NotFound - The specified source document or target matter does not exist.</para>
            <para>409 Conflict - A document with the same filename already exists in the target matter.</para>
            <para>500 InternalServerError - Unexpected server error occurred.</para>
            </returns>
        </member>
        <member name="M:ADMS.API.Controllers.DocumentController.MoveDocumentAsync(System.Guid,ADMS.API.Models.DocumentWithoutRevisionsDto)">
            <summary>
            Moves a document to the specified target matter.
            </summary>
            <remarks>
            Transfers the specified document from its current matter to the target matter.
            The document is removed from the source matter and added to the target matter,
            preserving all metadata and content.
            
            An audit trail entry is created for both the source and target matters
            to track the move operation.
            </remarks>
            <param name="matterId">The unique identifier of the target matter for the document move.</param>
            <param name="document">The document to be moved (without revision history).</param>
            <returns>
            <para>200 OK - Document successfully moved with updated matter association.</para>
            <para>400 BadRequest - Invalid input parameters or validation errors.</para>
            <para>404 NotFound - The specified document or target matter does not exist.</para>
            <para>409 Conflict - A document with the same filename already exists in the target matter.</para>
            <para>500 InternalServerError - Unexpected server error occurred.</para>
            </returns>
        </member>
        <member name="M:ADMS.API.Controllers.DocumentController.CheckoutDocumentAsync(System.Guid,System.Guid)">
            <summary>
            Checks out a document for exclusive editing by the current user.
            </summary>
            <remarks>
            Marks the document as checked out, preventing other users from
            modifying it until it is checked back in. This implements an
            optimistic locking mechanism for document editing.
            
            An audit trail entry is created to track the checkout operation
            and user information.
            </remarks>
            <param name="matterId">The unique identifier of the matter containing the document.</param>
            <param name="documentId">The unique identifier of the document to check out.</param>
            <returns>
            <para>200 OK - Document successfully checked out.</para>
            <para>400 BadRequest - Invalid parameters or document cannot be checked out.</para>
            <para>404 NotFound - The specified matter or document does not exist.</para>
            <para>409 Conflict - Document is already checked out by another user.</para>
            <para>500 InternalServerError - Unexpected server error occurred.</para>
            </returns>
        </member>
        <member name="M:ADMS.API.Controllers.DocumentController.CheckinDocumentAsync(System.Guid,System.Guid)">
            <summary>
            Checks in a previously checked out document, making it available for other users.
            </summary>
            <remarks>
            Removes the checked out status from the document, allowing other users
            to check it out for editing. This completes the optimistic locking cycle
            for document editing.
            
            An audit trail entry is created to track the check-in operation
            and user information.
            </remarks>
            <param name="matterId">The unique identifier of the matter containing the document.</param>
            <param name="documentId">The unique identifier of the document to check in.</param>
            <returns>
            <para>200 OK - Document successfully checked in.</para>
            <para>400 BadRequest - Invalid parameters or document cannot be checked in.</para>
            <para>404 NotFound - The specified matter or document does not exist.</para>
            <para>409 Conflict - Document is not currently checked out.</para>
            <para>500 InternalServerError - Unexpected server error occurred.</para>
            </returns>
        </member>
        <member name="M:ADMS.API.Controllers.DocumentController.GetDocumentHistoryAsync(System.Guid,System.Guid)">
            <summary>
            Retrieves the complete activity history for a document.
            </summary>
            <remarks>
            Returns a chronological list of all activities performed on the document
            including creation, modifications, check in/out operations, and user
            information. The history provides a complete audit trail for compliance
            and tracking purposes.
            
            Activities are returned in reverse chronological order (most recent first).
            </remarks>
            <param name="matterId">The unique identifier of the matter containing the document.</param>
            <param name="documentId">The unique identifier of the document whose history is requested.</param>
            <returns>
            <para>200 OK - Complete chronological activity history for the document.</para>
            <para>400 BadRequest - Invalid input parameters.</para>
            <para>404 NotFound - The specified matter or document does not exist.</para>
            <para>500 InternalServerError - Unexpected server error occurred.</para>
            </returns>
        </member>
        <member name="M:ADMS.API.Controllers.DocumentController.GetAuditAsync(System.Guid,System.Guid,ADMS.API.Helpers.AuditEnums.AuditDirection)">
            <summary>
            Retrieves audit records for document operations in the specified direction.
            </summary>
            <remarks>
            Returns audit records showing document move or copy operations either
            FROM the current matter (outgoing) or TO the current matter (incoming).
            This provides visibility into document transfer activities across matters.
            
            The direction parameter determines whether to show:
            - From: Documents that were moved/copied FROM this matter to others
            - To: Documents that were moved/copied TO this matter from others
            </remarks>
            <param name="matterId">The unique identifier of the matter.</param>
            <param name="documentId">The unique identifier of the document.</param>
            <param name="direction">The direction of audit records to retrieve (From or To).</param>
            <returns>
            <para>200 OK - List of audit records for the specified direction.</para>
            <para>400 BadRequest - Invalid input parameters or direction value.</para>
            <para>404 NotFound - The specified matter or document does not exist.</para>
            <para>500 InternalServerError - Unexpected server error occurred.</para>
            </returns>
        </member>
        <member name="M:ADMS.API.Controllers.DocumentController.GetDocumentOptions">
            <summary>
            Returns the HTTP methods supported by the document resource.
            </summary>
            <remarks>
            This endpoint implements the HTTP OPTIONS method to allow clients
            to discover which operations are available on the document resource.
            This is useful for API documentation tools and client applications
            that need to determine available functionality dynamically.
            </remarks>
            <returns>
            <para>204 NoContent - Response with Allow header listing supported HTTP methods.</para>
            <para>500 InternalServerError - Unexpected server error occurred.</para>
            </returns>
        </member>
        <member name="T:ADMS.API.Controllers.DocumentController.DocumentOperationType">
            <summary>
            Enum representing document operation types for copy and move operations.
            </summary>
        </member>
        <member name="F:ADMS.API.Controllers.DocumentController.DocumentOperationType.Copy">
            <summary>Document copy operation.</summary>
        </member>
        <member name="F:ADMS.API.Controllers.DocumentController.DocumentOperationType.Move">
            <summary>Document move operation.</summary>
        </member>
        <member name="M:ADMS.API.Controllers.DocumentController.ValidateCreateDocumentParametersAsync(System.Guid,ADMS.API.Models.DocumentForCreationDto,Microsoft.AspNetCore.Http.IFormFile)">
            <summary>
            Validates parameters for document creation operation.
            </summary>
        </member>
        <member name="M:ADMS.API.Controllers.DocumentController.ValidateGetDocumentsParametersAsync(System.Guid,ADMS.API.ResourceParameters.DocumentsResourceParameters)">
            <summary>
            Validates parameters for document retrieval operations.
            </summary>
        </member>
        <member name="M:ADMS.API.Controllers.DocumentController.ValidateDocumentAccessParametersAsync(System.Guid,System.Guid,System.String)">
            <summary>
            Validates parameters for document access operations (get, update, delete).
            </summary>
        </member>
        <member name="M:ADMS.API.Controllers.DocumentController.ValidateUpdateDocumentParametersAsync(System.Guid,System.Guid,ADMS.API.Models.DocumentForUpdateDto)">
            <summary>
            Validates parameters for document update operations.
            </summary>
        </member>
        <member name="M:ADMS.API.Controllers.DocumentController.ValidateAuditParametersAsync(System.Guid,System.Guid,ADMS.API.Helpers.AuditEnums.AuditDirection)">
            <summary>
            Validates parameters for audit retrieval operations.
            </summary>
        </member>
        <member name="M:ADMS.API.Controllers.DocumentController.ProcessFileUploadAsync(Microsoft.AspNetCore.Http.IFormFile,System.Threading.CancellationToken)">
            <summary>
            Processes and validates file upload including virus scanning and file type validation.
            </summary>
        </member>
        <member name="M:ADMS.API.Controllers.DocumentController.ValidateDocumentForCreationAsync(System.Guid,ADMS.API.Models.DocumentForCreationDto)">
            <summary>
            Validates document for creation including business rules and DTO validation.
            </summary>
        </member>
        <member name="M:ADMS.API.Controllers.DocumentController.CreateAndSaveDocumentAsync(System.Guid,ADMS.API.Models.DocumentForCreationDto,System.Byte[],System.String,System.Threading.CancellationToken)">
            <summary>
            Creates and saves a document with its associated file.
            </summary>
        </member>
        <member name="M:ADMS.API.Controllers.DocumentController.SaveDocumentFileAsync(System.Guid,System.Guid,System.Byte[],System.String,System.Threading.CancellationToken)">
            <summary>
            Saves document file content to storage.
            </summary>
        </member>
        <member name="M:ADMS.API.Controllers.DocumentController.PerformDocumentOperationAsync(System.Guid,ADMS.API.Models.DocumentWithoutRevisionsDto,ADMS.API.Controllers.DocumentController.DocumentOperationType)">
            <summary>
            Performs document copy or move operations with comprehensive validation and error handling.
            </summary>
        </member>
        <member name="M:ADMS.API.Controllers.DocumentController.PerformCheckStateOperationAsync(System.Guid,System.Guid,System.Boolean,System.String)">
            <summary>
            Performs document check-in or check-out operations.
            </summary>
        </member>
        <member name="M:ADMS.API.Controllers.DocumentController.ValidateHistoryDtosAsync(System.Collections.Generic.IList{ADMS.API.Models.DocumentActivityUserDto})">
            <summary>
            Validates a collection of document history DTOs.
            </summary>
        </member>
        <member name="M:ADMS.API.Controllers.DocumentController.ValidateAuditDtosAsync(System.Collections.Generic.IList{ADMS.API.Models.MatterDocumentActivityUserMinimalDto})">
            <summary>
            Validates a collection of audit DTOs.
            </summary>
        </member>
        <member name="M:ADMS.API.Controllers.DocumentController.ComputeChecksum(System.Byte[])">
            <summary>
            Computes SHA256 checksum for file content.
            </summary>
        </member>
        <member name="M:ADMS.API.Controllers.DocumentController.CreateInternalServerErrorResponse(System.String)">
            <summary>
            Creates a standardized internal server error response.
            </summary>
        </member>
        <member name="M:ADMS.API.Controllers.DocumentController.CreateProblemDetails(System.Int32,System.String)">
            <summary>
            Creates a standardized problem details object.
            </summary>
        </member>
        <member name="M:ADMS.API.Controllers.DocumentController.CreateValidationErrorResponse(System.Collections.Generic.IEnumerable{System.ComponentModel.DataAnnotations.ValidationResult},System.String)">
            <summary>
            Creates a validation error response from validation results.
            </summary>
        </member>
        <member name="T:ADMS.API.Controllers.FileController">
            <summary>
            Controller for managing file operations within the ADMS system.
            </summary>
            <remarks>
            This controller provides comprehensive file management functionality including:
            - File upload and storage with security validation
            - File download with content type detection and secure path handling
            - PDF conversion for supported Microsoft Office document formats
            - File type verification with virus scanning and content analysis
            - Document metadata management and custom property injection
            
            All endpoints implement consistent error handling, centralized validation,
            structured logging, and security best practices including:
            - Virus scanning using ClamAV integration
            - File type validation by content analysis (not just extension)
            - File size limits and extension validation
            - Custom document properties for Office files (Word, Excel, PowerPoint)
            - Secure file path construction to prevent directory traversal
            
            The controller supports Microsoft Office document conversion to PDF using 
            Syncfusion components and maintains comprehensive audit trails for all 
            file operations.
            
            Security features include:
            - Comprehensive file validation (type, size, content, extension matching)
            - Virus scanning before storage using ClamAV
            - Secure file path construction with sanitization
            - Content type detection and validation
            - Prevention of malicious file uploads through multiple validation layers
            </remarks>
        </member>
        <member name="M:ADMS.API.Controllers.FileController.#ctor(Microsoft.Extensions.Logging.ILogger{ADMS.API.Controllers.FileController},ADMS.API.Services.IAdmsRepository,MapsterMapper.IMapper,Microsoft.AspNetCore.Mvc.Infrastructure.ProblemDetailsFactory,ADMS.API.Services.IValidationService,ADMS.API.Services.IVirusScanner,ADMS.API.Services.IFileStorage)">
            <summary>
            Controller for managing file operations within the ADMS system.
            </summary>
            <remarks>
            This controller provides comprehensive file management functionality including:
            - File upload and storage with security validation
            - File download with content type detection and secure path handling
            - PDF conversion for supported Microsoft Office document formats
            - File type verification with virus scanning and content analysis
            - Document metadata management and custom property injection
            
            All endpoints implement consistent error handling, centralized validation,
            structured logging, and security best practices including:
            - Virus scanning using ClamAV integration
            - File type validation by content analysis (not just extension)
            - File size limits and extension validation
            - Custom document properties for Office files (Word, Excel, PowerPoint)
            - Secure file path construction to prevent directory traversal
            
            The controller supports Microsoft Office document conversion to PDF using 
            Syncfusion components and maintains comprehensive audit trails for all 
            file operations.
            
            Security features include:
            - Comprehensive file validation (type, size, content, extension matching)
            - Virus scanning before storage using ClamAV
            - Secure file path construction with sanitization
            - Content type detection and validation
            - Prevention of malicious file uploads through multiple validation layers
            </remarks>
        </member>
        <member name="F:ADMS.API.Controllers.FileController.ServerFilesPath">
            <summary>
            The server files path from environment variables with validation.
            </summary>
        </member>
        <member name="F:ADMS.API.Controllers.FileController.PdfFolderName">
            <summary>
            The folder name for storing PDF conversions.
            </summary>
        </member>
        <member name="F:ADMS.API.Controllers.FileController.MaxUploadFileSize">
            <summary>
            Maximum allowed file size for uploads (50 MB).
            </summary>
        </member>
        <member name="M:ADMS.API.Controllers.FileController.UploadExistingFileAsync(System.Guid,System.Guid,System.Guid,Microsoft.AspNetCore.Http.IFormFile,System.Threading.CancellationToken)">
            <summary>
            Uploads a replacement file for an existing document revision.
            </summary>
            <remarks>
            This endpoint replaces the file content for an existing document revision
            while maintaining the document's metadata and audit trail. The process includes:
            
            1. Comprehensive validation of matter, document, and revision existence
            2. File size and type validation with content analysis
            3. Virus scanning using ClamAV integration
            4. Document metadata updates with new file properties
            5. Secure file storage with proper path construction
            6. Audit trail creation for the file replacement
            
            The operation is atomic - either all changes succeed or none are applied.
            File validation includes extension checking, MIME type detection, and
            content-based file type verification to prevent malicious uploads.
            
            Custom document properties are injected into supported Office formats
            to maintain document traceability within the ADMS system.
            </remarks>
            <param name="matterId">The unique identifier of the matter containing the document.</param>
            <param name="documentId">The unique identifier of the document to update.</param>
            <param name="revisionId">The unique identifier of the revision to update with the new file.</param>
            <param name="fileUpload">The new file content to replace the existing file.</param>
            <param name="cancelToken">Cancellation token for the async operation.</param>
            <returns>
            <para>201 Created - File successfully uploaded and document metadata updated.</para>
            <para>400 BadRequest - Invalid input parameters or validation errors.</para>
            <para>404 NotFound - The specified matter, document, or revision does not exist.</para>
            <para>409 Conflict - File conflicts with existing content or constraints.</para>
            <para>413 PayloadTooLarge - File size exceeds the maximum allowed limit.</para>
            <para>415 UnsupportedMediaType - File type is not allowed or doesn't match extension.</para>
            <para>422 UnprocessableEntity - File contains virus or malware.</para>
            <para>500 InternalServerError - Unexpected server error occurred.</para>
            </returns>
        </member>
        <member name="M:ADMS.API.Controllers.FileController.DownloadFileAsync(System.Guid,System.Guid,System.Guid)">
            <summary>
            Downloads the specified file from the ADMS system.
            </summary>
            <remarks>
            This endpoint provides secure file download functionality with:
            - Comprehensive validation of matter, document, and revision existence
            - Secure path construction to prevent directory traversal attacks
            - Content type detection for proper browser handling
            - Proper content disposition headers for file downloads
            - Audit logging of download activities
            
            The endpoint validates all entities exist before attempting file access
            and uses centralized validation for DTOs to ensure data integrity.
            File paths are constructed securely to prevent unauthorized access.
            </remarks>
            <param name="matterId">The unique identifier of the matter containing the document.</param>
            <param name="documentId">The unique identifier of the document to download.</param>
            <param name="revisionId">The unique identifier of the revision to download.</param>
            <returns>
            <para>200 OK - File successfully downloaded with appropriate headers.</para>
            <para>400 BadRequest - Invalid input parameters.</para>
            <para>404 NotFound - The specified matter, document, revision, or file does not exist.</para>
            <para>500 InternalServerError - Unexpected server error occurred.</para>
            </returns>
        </member>
        <member name="M:ADMS.API.Controllers.FileController.DownloadPdfAsync(System.Guid,System.Guid,System.Guid)">
            <summary>
            Downloads the PDF version of the specified document revision.
            </summary>
            <remarks>
            This endpoint provides PDF download functionality with automatic conversion:
            - Validates entity existence and user permissions
            - Checks for existing PDF version of the document
            - Automatically converts supported Office formats to PDF if needed
            - Uses Syncfusion components for high-quality conversions
            - Caches converted PDFs for improved performance
            
            Supported formats for PDF conversion:
            - Microsoft Word: .doc, .docx, .dot, .dotx, .docm, .dotm
            - Microsoft Excel: .xls, .xlsx, .csv, .xlt, .xltm, .xlw
            - Microsoft PowerPoint: .ppt, .pptx, .pot, .potx, .pptm, .potm
            
            If the source document is not a supported format, the endpoint returns
            a 400 Bad Request with details about supported formats.
            </remarks>
            <param name="matterId">The unique identifier of the matter containing the document.</param>
            <param name="documentId">The unique identifier of the document to convert and download.</param>
            <param name="revisionId">The unique identifier of the revision to convert and download.</param>
            <returns>
            <para>200 OK - PDF file successfully downloaded.</para>
            <para>400 BadRequest - Invalid parameters or unsupported file format.</para>
            <para>404 NotFound - The specified entities or source file does not exist.</para>
            <para>500 InternalServerError - Conversion failed or unexpected error occurred.</para>
            </returns>
        </member>
        <member name="M:ADMS.API.Controllers.FileController.VerifyFileTypeAsync(System.Guid,System.Guid,System.Guid,Microsoft.AspNetCore.Http.IFormFile)">
            <summary>
            Verifies file type and integrity without storing the file.
            </summary>
            <remarks>
            This endpoint provides comprehensive file validation including:
            - Entity existence validation (matter, document, revision)
            - File extension validation against allowed types
            - Content-based file type detection and validation
            - Extension/content type matching verification
            - Virus scanning using ClamAV integration
            - File metadata validation using centralized validation services
            
            The endpoint is useful for client-side validation before actual upload,
            allowing users to verify file compatibility and security before committing
            to the full upload process. This can save bandwidth and improve user experience.
            
            The verification process uses the same validation logic as actual uploads
            to ensure consistency across the system.
            </remarks>
            <param name="matterId">The unique identifier of the matter for context validation.</param>
            <param name="documentId">The unique identifier of the document for context validation.</param>
            <param name="revisionId">The unique identifier of the revision for context validation.</param>
            <param name="fileUpload">The file to verify without storing.</param>
            <returns>
            <para>200 OK - File is valid and safe for upload with verification details.</para>
            <para>400 BadRequest - Invalid input parameters.</para>
            <para>404 NotFound - The specified entities do not exist.</para>
            <para>415 UnsupportedMediaType - File type is not allowed or extension mismatch.</para>
            <para>422 UnprocessableEntity - File contains virus or malware.</para>
            <para>500 InternalServerError - Unexpected error during verification.</para>
            </returns>
        </member>
        <member name="M:ADMS.API.Controllers.FileController.UploadNewFileAsync(System.Guid,Microsoft.AspNetCore.Http.IFormFile,System.Threading.CancellationToken)">
            <summary>
            Uploads a new file and creates a new document in the specified matter.
            </summary>
            <remarks>
            This endpoint creates a completely new document with the uploaded file:
            - Validates matter existence and user permissions
            - Performs comprehensive file validation and security scanning
            - Checks for duplicate filenames within the matter
            - Creates new document and revision entities
            - Stores file with custom document properties for Office formats
            - Creates audit trail entries for document creation
            
            The process is atomic - either all operations succeed or none are applied.
            Custom ADMS properties are injected into supported Office documents for
            traceability and system integration.
            
            File validation includes multiple layers of security checks to prevent
            malicious uploads and ensure system integrity.
            </remarks>
            <param name="matterId">The unique identifier of the matter to create the document in.</param>
            <param name="fileUpload">The file to upload and associate with the new document.</param>
            <param name="cancelToken">Cancellation token for the async operation.</param>
            <returns>
            <para>201 Created - Document successfully created with download URL.</para>
            <para>400 BadRequest - Invalid input parameters or validation errors.</para>
            <para>404 NotFound - The specified matter does not exist.</para>
            <para>409 Conflict - A document with the same filename already exists.</para>
            <para>413 PayloadTooLarge - File size exceeds the maximum allowed limit.</para>
            <para>415 UnsupportedMediaType - File type is not allowed.</para>
            <para>422 UnprocessableEntity - File contains virus or malware.</para>
            <para>500 InternalServerError - Unexpected server error occurred.</para>
            </returns>
        </member>
        <member name="M:ADMS.API.Controllers.FileController.GetFileOptions">
            <summary>
            Returns the HTTP methods supported by the file resource.
            </summary>
            <remarks>
            This endpoint implements the HTTP OPTIONS method to allow clients
            to discover which operations are available on the file resource.
            This is useful for API documentation tools, CORS preflight requests,
            and client applications that need to determine available functionality dynamically.
            
            The response includes appropriate headers indicating supported methods,
            API version information, and CORS configuration if applicable.
            </remarks>
            <returns>
            <para>204 NoContent - Response with Allow header listing supported HTTP methods.</para>
            <para>500 InternalServerError - Unexpected server error occurred.</para>
            </returns>
        </member>
        <member name="M:ADMS.API.Controllers.FileController.ValidateFileUploadParametersAsync(System.Guid,System.Guid,System.Guid,Microsoft.AspNetCore.Http.IFormFile)">
            <summary>
            Validates parameters for file upload operations.
            </summary>
        </member>
        <member name="M:ADMS.API.Controllers.FileController.ValidateFileAccessParametersAsync(System.Guid,System.Guid,System.Guid)">
            <summary>
            Validates parameters for file access operations (download).
            </summary>
        </member>
        <member name="M:ADMS.API.Controllers.FileController.ValidateFileVerificationParametersAsync(System.Guid,System.Guid,System.Guid,Microsoft.AspNetCore.Http.IFormFile)">
            <summary>
            Validates parameters for file verification operations.
            </summary>
        </member>
        <member name="M:ADMS.API.Controllers.FileController.ValidateNewFileUploadParametersAsync(System.Guid,Microsoft.AspNetCore.Http.IFormFile)">
            <summary>
            Validates parameters for new file upload operations.
            </summary>
        </member>
        <member name="M:ADMS.API.Controllers.FileController.ValidateEntitiesExistenceAsync(System.Guid,System.Guid,System.Guid)">
            <summary>
            Validates entity existence and returns validated entities.
            </summary>
        </member>
        <member name="M:ADMS.API.Controllers.FileController.ValidateEntitiesExistenceForVerificationAsync(System.Guid,System.Guid,System.Guid)">
            <summary>
            Validates entity existence for verification operations (context only).
            </summary>
        </member>
        <member name="M:ADMS.API.Controllers.FileController.ValidateEntityDtosAsync(ADMS.API.Entities.Document,ADMS.API.Entities.Revision)">
            <summary>
            Validates entity DTOs using centralized validation.
            </summary>
        </member>
        <member name="M:ADMS.API.Controllers.FileController.ProcessFileUploadAsync(Microsoft.AspNetCore.Http.IFormFile,System.Threading.CancellationToken)">
            <summary>
            Processes and validates uploaded file with comprehensive security checks.
            </summary>
        </member>
        <member name="M:ADMS.API.Controllers.FileController.UpdateDocumentMetadataAsync(ADMS.API.Entities.Document,System.Guid,System.Byte[],System.String,System.String)">
            <summary>
            Updates document metadata with new file properties.
            </summary>
        </member>
        <member name="M:ADMS.API.Controllers.FileController.SaveFileWithCustomPropertiesAsync(System.Guid,System.Guid,System.Guid,System.Byte[],System.String,System.Threading.CancellationToken)">
            <summary>
            Saves file to storage with custom document properties.
            </summary>
        </member>
        <member name="M:ADMS.API.Controllers.FileController.SaveNewFileWithCustomPropertiesAsync(System.Guid,System.Guid,System.Guid,System.Byte[],System.String,System.Threading.CancellationToken)">
            <summary>
            Saves new file with custom document properties.
            </summary>
        </member>
        <member name="M:ADMS.API.Controllers.FileController.BuildSecureFilePath(System.Guid,System.Guid,System.Int32,System.String)">
            <summary>
            Builds secure file path preventing directory traversal.
            </summary>
        </member>
        <member name="M:ADMS.API.Controllers.FileController.GetContentType(System.String)">
            <summary>
            Gets content type for file download.
            </summary>
        </member>
        <member name="M:ADMS.API.Controllers.FileController.CreateDownloadFileName(System.String,System.Int32,System.String)">
            <summary>
            Creates download filename with revision information.
            </summary>
        </member>
        <member name="M:ADMS.API.Controllers.FileController.SetDownloadResponseHeaders(System.String)">
            <summary>
            Sets appropriate response headers for file downloads.
            </summary>
        </member>
        <member name="M:ADMS.API.Controllers.FileController.CreateValidationDto(System.String,System.String,System.Byte[],System.String)">
            <summary>
            Creates validation DTO for file verification.
            </summary>
        </member>
        <member name="M:ADMS.API.Controllers.FileController.CreateDocumentForCreationDto(System.String,System.String,System.Byte[],System.String)">
            <summary>
            Creates document creation DTO.
            </summary>
        </member>
        <member name="M:ADMS.API.Controllers.FileController.CreateFileUploadResponse(System.Guid,System.Guid,System.Guid,System.String)">
            <summary>
            Creates file upload response object.
            </summary>
        </member>
        <member name="M:ADMS.API.Controllers.FileController.GetSupportedConversions(System.String)">
            <summary>
            Gets supported conversion formats for a file extension.
            </summary>
        </member>
        <member name="M:ADMS.API.Controllers.FileController.ConvertToPdfAsync(System.String,System.String,System.String)">
            <summary>
            Converts supported office documents to PDF asynchronously.
            </summary>
        </member>
        <member name="M:ADMS.API.Controllers.FileController.ConvertToPdf(System.String,System.String,System.String)">
            <summary>
            Converts a supported Office document to PDF format.
            </summary>
            <param name="folder">The folder containing the original file.</param>
            <param name="originalFileName">The name of the original file to convert.</param>
            <param name="pdfFileName">The desired name for the output PDF file.</param>
            <returns>True if the conversion was successful; false otherwise.</returns>
        </member>
        <member name="M:ADMS.API.Controllers.FileController.ConvertWordToPdf(System.String,System.String)">
            <summary>
            Converts a Word document to PDF format using Syncfusion DocIO and DocIORenderer.
            </summary>
            <param name="fileToConvert">The full path to the Word document to be converted.</param>
            <param name="convertedFile">The full path where the resulting PDF should be saved.</param>
            <returns>True if the conversion was successful; false otherwise.</returns>
        </member>
        <member name="M:ADMS.API.Controllers.FileController.ConvertExcelToPdf(System.String,System.String)">
            <summary>
            Converts an Excel document to PDF format using Syncfusion XlsIO and XlsIORenderer.
            </summary>
            <param name="fileToConvert">The full path to the Excel file to be converted.</param>
            <param name="convertedFile">The full path where the resulting PDF should be saved.</param>
            <returns>True if the conversion was successful; false otherwise.</returns>
        </member>
        <member name="M:ADMS.API.Controllers.FileController.ConvertPowerPointToPdf(System.String,System.String)">
            <summary>
            Converts a PowerPoint document to PDF format using Syncfusion Presentation and PresentationToPdfConverter.
            </summary>
            <param name="fileToConvert">The full path to the PowerPoint file to be converted.</param>
            <param name="convertedFile">The full path where the resulting PDF should be saved.</param>
            <returns>True if the conversion was successful; false otherwise.</returns>
        </member>
        <member name="M:ADMS.API.Controllers.FileController.ComputeChecksum(System.Byte[])">
            <summary>
            Computes SHA256 checksum for file content with enhanced error handling.
            </summary>
            <param name="fileBytes">The file bytes to compute the checksum for.</param>
            <returns>The SHA256 checksum as a lowercase hexadecimal string.</returns>
        </member>
        <member name="M:ADMS.API.Controllers.FileController.AddCustomDocumentProperties(System.String,System.String,System.Guid,System.Guid,System.Guid)">
            <summary>
            Adds custom document properties to MS Office files with enhanced error handling.
            </summary>
            <param name="inputPath">Path to the input file (temp file).</param>
            <param name="outputPath">Path to save the file with properties.</param>
            <param name="documentId">Document GUID.</param>
            <param name="revisionId">Revision GUID.</param>
            <param name="matterId">Matter GUID.</param>
        </member>
        <member name="M:ADMS.API.Controllers.FileController.ProcessWordDocument(System.String,System.String,System.Guid,System.Guid,System.Guid)">
            <summary>
            Processes Word documents to add custom properties.
            </summary>
        </member>
        <member name="M:ADMS.API.Controllers.FileController.ProcessExcelDocument(System.String,System.String,System.Guid,System.Guid,System.Guid)">
            <summary>
            Processes Excel documents to add custom properties.
            </summary>
        </member>
        <member name="M:ADMS.API.Controllers.FileController.ProcessPowerPointDocument(System.String,System.String,System.Guid,System.Guid,System.Guid)">
            <summary>
            Processes PowerPoint documents to add custom properties.
            </summary>
        </member>
        <member name="M:ADMS.API.Controllers.FileController.SetCustomProperties(System.Object,System.Guid,System.Guid,System.Guid)">
            <summary>
            Sets custom properties for Word documents.
            </summary>
        </member>
        <member name="M:ADMS.API.Controllers.FileController.SetExcelCustomProperties(System.Object,System.Guid,System.Guid,System.Guid)">
            <summary>
            Sets custom properties for Excel documents.
            </summary>
        </member>
        <member name="M:ADMS.API.Controllers.FileController.SetPowerPointCustomProperties(System.Object,System.Guid,System.Guid,System.Guid)">
            <summary>
            Sets custom properties for PowerPoint documents.
            </summary>
        </member>
        <member name="M:ADMS.API.Controllers.FileController.CreateProblemDetails(System.Int32,System.String)">
            <summary>
            Creates a standardized problem details object.
            </summary>
            <param name="statusCode">The HTTP status code.</param>
            <param name="detail">The problem detail message.</param>
            <returns>A standardized problem details object.</returns>
        </member>
        <member name="M:ADMS.API.Controllers.FileController.CreateInternalServerErrorResponse(System.String)">
            <summary>
            Creates a standardized internal server error response.
            </summary>
            <param name="operationContext">A description of the operation that failed.</param>
            <returns>A standardized internal server error response.</returns>
        </member>
        <member name="T:ADMS.API.Controllers.MatterController">
            <summary>
            Controller for managing matters within the ADMS system.
            </summary>
            <remarks>
            This controller provides comprehensive matter management functionality including:
            - Matter creation with validation and duplicate checking
            - Matter retrieval with flexible inclusion options (documents, history)
            - Matter updates with audit trail maintenance
            - Matter deletion with business rule enforcement
            - Matter restoration capabilities
            - Paginated matter listings with filtering and sorting
            - Comprehensive audit history retrieval
            
            All endpoints implement consistent error handling, centralized validation,
            structured logging, and security best practices including:
            - Comprehensive input validation using data annotations and custom validation
            - Centralized validation service integration
            - Proper HTTP status code usage following REST conventions
            - Detailed error responses using RFC 7807 Problem Details format
            - Structured logging with correlation IDs for traceability
            - API versioning support with proper headers
            
            Business Rules Enforced:
            - Matter descriptions must be unique across the system
            - Matters can only be deleted when all associated documents are deleted and checked in
            - All operations maintain comprehensive audit trails
            - Date/time handling uses UTC with local formatting options
            
            The controller supports advanced features like:
            - Pagination with metadata headers for efficient data retrieval
            - Flexible filtering and sorting through resource parameters
            - Audit history tracking with directional queries (from/to)
            - Matter restoration with proper validation
            </remarks>
        </member>
        <member name="M:ADMS.API.Controllers.MatterController.#ctor(Microsoft.Extensions.Logging.ILogger{ADMS.API.Controllers.MatterController},ADMS.API.Services.IAdmsRepository,MapsterMapper.IMapper,Microsoft.AspNetCore.Mvc.Infrastructure.ProblemDetailsFactory,ADMS.API.Services.IValidationService)">
            <summary>
            Controller for managing matters within the ADMS system.
            </summary>
            <remarks>
            This controller provides comprehensive matter management functionality including:
            - Matter creation with validation and duplicate checking
            - Matter retrieval with flexible inclusion options (documents, history)
            - Matter updates with audit trail maintenance
            - Matter deletion with business rule enforcement
            - Matter restoration capabilities
            - Paginated matter listings with filtering and sorting
            - Comprehensive audit history retrieval
            
            All endpoints implement consistent error handling, centralized validation,
            structured logging, and security best practices including:
            - Comprehensive input validation using data annotations and custom validation
            - Centralized validation service integration
            - Proper HTTP status code usage following REST conventions
            - Detailed error responses using RFC 7807 Problem Details format
            - Structured logging with correlation IDs for traceability
            - API versioning support with proper headers
            
            Business Rules Enforced:
            - Matter descriptions must be unique across the system
            - Matters can only be deleted when all associated documents are deleted and checked in
            - All operations maintain comprehensive audit trails
            - Date/time handling uses UTC with local formatting options
            
            The controller supports advanced features like:
            - Pagination with metadata headers for efficient data retrieval
            - Flexible filtering and sorting through resource parameters
            - Audit history tracking with directional queries (from/to)
            - Matter restoration with proper validation
            </remarks>
        </member>
        <member name="M:ADMS.API.Controllers.MatterController.CreateMatterAsync(ADMS.API.Models.MatterForCreationDto)">
            <summary>
            Creates a new matter in the system.
            </summary>
            <remarks>
            This endpoint creates a new matter with comprehensive validation including:
            - Input validation using data annotations and custom validation rules
            - Business rule validation including duplicate description checking
            - Automatic audit trail creation for the matter creation event
            - Proper HTTP status codes and error responses following REST conventions
            
            The creation process includes:
            1. Comprehensive DTO validation using centralized validation services
            2. Model state validation for any binding errors
            3. Business rule validation (e.g., unique matter descriptions)
            4. Matter creation with proper entity relationship setup
            5. Audit log creation with creation activity tracking
            
            Upon successful creation, the response includes a Location header pointing
            to the newly created matter and returns the created matter data.
            </remarks>
            <param name="matter">The matter data transfer object containing the information needed to create a new matter.</param>
            <returns>
            <para>201 Created - Matter successfully created with location header and matter data.</para>
            <para>400 BadRequest - Invalid input data, validation errors, or malformed request.</para>
            <para>409 Conflict - A matter with the same description already exists.</para>
            <para>500 InternalServerError - Unexpected server error during matter creation.</para>
            </returns>
        </member>
        <member name="M:ADMS.API.Controllers.MatterController.DeleteMatterAsync(System.Guid)">
            <summary>
            Deletes a specific matter from the system.
            </summary>
            <remarks>
            This endpoint provides secure matter deletion with comprehensive business rule enforcement:
            - Validates that the matter exists before attempting deletion
            - Ensures all associated documents are marked as deleted
            - Verifies that no documents are currently checked out
            - Creates comprehensive audit trail for the deletion operation
            - Implements soft deletion to maintain data integrity and audit history
            
            Business Rules:
            - Matter can only be deleted if all associated documents are deleted
            - Matter can only be deleted if no documents are checked out
            - Deletion creates an audit record for compliance and tracking
            - The deletion is typically a soft delete to preserve referential integrity
            
            The deletion process includes:
            1. Parameter and entity existence validation
            2. Business rule validation (document status checking)
            3. Audit trail creation before deletion
            4. Secure deletion with proper cleanup
            5. Success confirmation without exposing internal details
            </remarks>
            <param name="matterId">The unique identifier of the matter to be deleted.</param>
            <returns>
            <para>204 NoContent - Matter successfully deleted.</para>
            <para>400 BadRequest - Invalid matter ID, business rule violation, or validation errors.</para>
            <para>404 NotFound - The specified matter does not exist.</para>
            <para>500 InternalServerError - Unexpected server error during deletion.</para>
            </returns>
        </member>
        <member name="M:ADMS.API.Controllers.MatterController.GetMatterAsync(System.Guid,System.Boolean)">
            <summary>
            Retrieves a specific matter with flexible inclusion options.
            </summary>
            <remarks>
            This endpoint provides flexible matter retrieval with optional related data inclusion:
            - Basic matter information retrieval with validation
            - Optional document inclusion for complete matter context
            - Proper DTO mapping based on inclusion parameters
            - Audit trail creation for matter access (VIEWED activity)
            - Comprehensive error handling with proper HTTP status codes
            
            The endpoint supports two retrieval modes:
            1. Basic matter information (default) - Returns core matter data without related entities
            2. Matter with documents - Returns complete matter data including all associated documents
            
            Features include:
            - Centralized validation using the validation service
            - Proper DTO selection based on includeDocuments parameter
            - Audit logging for compliance and usage tracking
            - Error handling with detailed problem responses
            - Support for API versioning and correlation tracking
            </remarks>
            <param name="matterId">The unique identifier of the matter to retrieve.</param>
            <param name="includeDocuments">Optional parameter to include associated documents in the response (default: false).</param>
            <returns>
            <para>200 OK - Matter successfully retrieved with requested data.</para>
            <para>400 BadRequest - Invalid matter ID or validation errors.</para>
            <para>404 NotFound - The specified matter does not exist.</para>
            <para>500 InternalServerError - Unexpected server error during retrieval.</para>
            </returns>
        </member>
        <member name="M:ADMS.API.Controllers.MatterController.GetAuditsAsync(System.Guid,System.String)">
            <summary>
            Retrieves the audit history for a specific matter with directional filtering.
            </summary>
            <remarks>
            This endpoint provides comprehensive audit history retrieval with directional filtering:
            - Supports "from" and "to" audit direction filtering for move/copy operations
            - Returns detailed audit records including user, activity, and timestamp information
            - Validates all input parameters including matter existence and history type
            - Implements comprehensive error handling with proper HTTP status codes
            - Validates audit records using centralized validation services
            
            Audit Direction Types:
            - "from": Returns audit records where documents were moved/copied FROM this matter
            - "to": Returns audit records where documents were moved/copied TO this matter
            
            The audit history provides:
            - Complete activity tracking for compliance and reporting
            - User attribution for all activities
            - Timestamp information for activity sequencing
            - Document-level audit details for comprehensive tracking
            - Validation of all returned data for consistency
            </remarks>
            <param name="matterId">The unique identifier of the matter to retrieve audit history for.</param>
            <param name="historyType">The direction of audit history to retrieve ("from" or "to").</param>
            <returns>
            <para>200 OK - Audit history successfully retrieved.</para>
            <para>400 BadRequest - Invalid matter ID, invalid history type, or validation errors.</para>
            <para>404 NotFound - The specified matter does not exist or no audit history found.</para>
            <para>500 InternalServerError - Unexpected server error during audit retrieval.</para>
            </returns>
        </member>
        <member name="M:ADMS.API.Controllers.MatterController.UpdateMatterAsync(System.Guid,ADMS.API.Models.MatterForUpdateDto)">
            <summary>
            Updates a specific matter with comprehensive validation and audit tracking.
            </summary>
            <remarks>
            This endpoint provides secure matter updating with comprehensive validation:
            - Validates all input parameters including matter existence
            - Performs business rule validation for update operations
            - Maintains complete audit trail for all changes
            - Implements optimistic concurrency control where applicable
            - Validates updated data using centralized validation services
            
            Update Process:
            1. Input validation using data annotations and custom rules
            2. Entity existence validation
            3. Business rule validation for update permissions
            4. Data persistence with proper error handling
            5. Audit trail creation for the update operation
            6. Response with appropriate status and headers
            
            Features:
            - Comprehensive error handling with detailed problem responses
            - Audit logging for compliance and change tracking
            - Proper HTTP status codes following REST conventions
            - API versioning and correlation ID support
            </remarks>
            <param name="matterId">The unique identifier of the matter to update.</param>
            <param name="matter">The matter update data transfer object containing the new matter information.</param>
            <returns>
            <para>204 NoContent - Matter successfully updated.</para>
            <para>400 BadRequest - Invalid input data, validation errors, or business rule violations.</para>
            <para>404 NotFound - The specified matter does not exist.</para>
            <para>500 InternalServerError - Unexpected server error during update.</para>
            </returns>
        </member>
        <member name="M:ADMS.API.Controllers.MatterController.GetMatterHistoryAsync(System.Guid)">
            <summary>
            Retrieves the complete audit history for a specific matter.
            </summary>
            <remarks>
            This endpoint provides comprehensive matter history retrieval including:
            - Complete audit trail for all matter-related activities
            - Document-level activity history associated with the matter
            - User attribution and timestamp information for all activities
            - Proper validation and error handling for history data
            - Flexible return format supporting various client needs
            
            History Information Includes:
            - Matter creation, update, and deletion activities
            - Document activities within the matter
            - User access and modification tracking
            - Move/copy operations involving the matter
            - Timestamp and user attribution for all activities
            
            Features:
            - Comprehensive error handling with detailed responses
            - Validation of all returned historical data
            - Support for large history datasets with proper performance
            - API versioning and correlation tracking
            - Structured logging for debugging and monitoring
            </remarks>
            <param name="matterId">The unique identifier of the matter to retrieve complete history for.</param>
            <returns>
            <para>200 OK - Complete matter history successfully retrieved.</para>
            <para>400 BadRequest - Invalid matter ID or validation errors.</para>
            <para>404 NotFound - The specified matter does not exist or no history available.</para>
            <para>500 InternalServerError - Unexpected server error during history retrieval.</para>
            </returns>
        </member>
        <member name="M:ADMS.API.Controllers.MatterController.RestoreMatterAsync(System.Guid)">
            <summary>
            Restores a deleted matter with comprehensive validation and audit tracking.
            </summary>
            <remarks>
            This endpoint provides secure matter restoration functionality:
            - Validates that the matter exists and can be restored
            - Performs business rule validation for restoration eligibility
            - Creates comprehensive audit trail for the restoration operation
            - Implements proper error handling and logging
            - Returns appropriate status codes based on operation results
            
            Restoration Process:
            1. Parameter validation and matter existence checking
            2. Business rule validation for restoration eligibility
            3. Matter restoration with proper state management
            4. Audit trail creation for compliance tracking
            5. Success confirmation with appropriate response
            
            Business Rules:
            - Only deleted matters can be restored
            - Restoration must maintain data integrity
            - All restoration activities are audited for compliance
            - Proper validation ensures system consistency
            </remarks>
            <param name="matterId">The unique identifier of the matter to restore.</param>
            <returns>
            <para>200 OK - Matter successfully restored.</para>
            <para>400 BadRequest - Invalid matter ID, business rule violation, or matter cannot be restored.</para>
            <para>404 NotFound - The specified matter does not exist.</para>
            <para>500 InternalServerError - Unexpected server error during restoration.</para>
            </returns>
        </member>
        <member name="M:ADMS.API.Controllers.MatterController.GetMattersAsync(ADMS.API.ResourceParameters.MattersResourceParameters)">
            <summary>
            Retrieves a paginated list of matters with comprehensive filtering and sorting capabilities.
            </summary>
            <remarks>
            This endpoint provides advanced matter listing functionality with:
            - Comprehensive pagination with metadata headers
            - Advanced filtering options through resource parameters
            - Multiple sorting options with proper validation
            - Performance optimization for large datasets
            - Comprehensive error handling and validation
            
            Pagination Features:
            - Configurable page size with reasonable limits
            - Page navigation with total count information
            - Metadata headers for client-side pagination handling
            - Performance optimization for large result sets
            
            Filtering and Sorting:
            - Multiple filter criteria support
            - Case-insensitive text searching
            - Date range filtering capabilities
            - Multiple sort field options
            - Ascending and descending sort directions
            
            Response Format:
            - JSON/XML content negotiation support
            - Comprehensive pagination metadata in headers
            - Consistent error responses using problem details format
            - API versioning and correlation ID support
            </remarks>
            <param name="resourceParameters">The resource parameters containing pagination, filtering, and sorting options.</param>
            <returns>
            <para>200 OK - Paginated matter list successfully retrieved with metadata headers.</para>
            <para>400 BadRequest - Invalid pagination parameters, filter criteria, or validation errors.</para>
            <para>500 InternalServerError - Unexpected server error during matter retrieval.</para>
            </returns>
        </member>
        <member name="M:ADMS.API.Controllers.MatterController.GetMatterOptions">
            <summary>
            Returns the HTTP methods supported by the matters resource.
            </summary>
            <remarks>
            This endpoint implements the HTTP OPTIONS method to allow clients
            to discover which operations are available on the matters resource.
            This is useful for API documentation tools, CORS preflight requests,
            and client applications that need to determine available functionality dynamically.
            
            The response includes appropriate headers indicating supported methods,
            API version information, and CORS configuration if applicable.
            </remarks>
            <returns>
            <para>204 NoContent - Response with Allow header listing supported HTTP methods.</para>
            <para>500 InternalServerError - Unexpected server error occurred.</para>
            </returns>
        </member>
        <member name="M:ADMS.API.Controllers.MatterController.ValidateCreateMatterParametersAsync(ADMS.API.Models.MatterForCreationDto)">
            <summary>
            Validates parameters for matter creation operations.
            </summary>
        </member>
        <member name="M:ADMS.API.Controllers.MatterController.ValidateDeleteMatterParametersAsync(System.Guid)">
            <summary>
            Validates parameters for matter deletion operations.
            </summary>
        </member>
        <member name="M:ADMS.API.Controllers.MatterController.ValidateGetMatterParametersAsync(System.Guid)">
            <summary>
            Validates parameters for matter retrieval operations.
            </summary>
        </member>
        <member name="M:ADMS.API.Controllers.MatterController.ValidateGetAuditsParametersAsync(System.Guid,System.String)">
            <summary>
            Validates parameters for audit retrieval operations.
            </summary>
        </member>
        <member name="M:ADMS.API.Controllers.MatterController.ValidateUpdateMatterParametersAsync(System.Guid,ADMS.API.Models.MatterForUpdateDto)">
            <summary>
            Validates parameters for matter update operations.
            </summary>
        </member>
        <member name="M:ADMS.API.Controllers.MatterController.ValidateGetMatterHistoryParametersAsync(System.Guid)">
            <summary>
            Validates parameters for matter history retrieval operations.
            </summary>
        </member>
        <member name="M:ADMS.API.Controllers.MatterController.ValidateRestoreMatterParametersAsync(System.Guid)">
            <summary>
            Validates parameters for matter restoration operations.
            </summary>
        </member>
        <member name="M:ADMS.API.Controllers.MatterController.ValidateGetMattersParametersAsync(ADMS.API.ResourceParameters.MattersResourceParameters)">
            <summary>
            Validates parameters for paginated matter retrieval operations.
            </summary>
        </member>
        <member name="M:ADMS.API.Controllers.MatterController.CheckMatterDescriptionExistsAsync(System.String)">
            <summary>
            Checks if a matter description already exists.
            </summary>
        </member>
        <member name="M:ADMS.API.Controllers.MatterController.CreateMatterWithAuditAsync(ADMS.API.Models.MatterForCreationDto)">
            <summary>
            Creates a matter with audit trail.
            </summary>
        </member>
        <member name="M:ADMS.API.Controllers.MatterController.ValidateMatterDeletionBusinessRulesAsync(System.Guid)">
            <summary>
            Validates business rules for matter deletion.
            </summary>
        </member>
        <member name="M:ADMS.API.Controllers.MatterController.DeleteMatterWithAuditAsync(System.Guid)">
            <summary>
            Deletes a matter with audit trail.
            </summary>
        </member>
        <member name="M:ADMS.API.Controllers.MatterController.MapMatterToDtoAsync(ADMS.API.Entities.Matter,System.Boolean)">
            <summary>
            Maps matter entity to appropriate DTO based on inclusion parameters.
            </summary>
        </member>
        <member name="M:ADMS.API.Controllers.MatterController.CreateMatterViewedAuditAsync(System.Guid)">
            <summary>
            Creates audit trail for matter viewing.
            </summary>
        </member>
        <member name="M:ADMS.API.Controllers.MatterController.RetrieveAuditHistoryAsync(System.Guid,System.String)">
            <summary>
            Retrieves audit history based on direction.
            </summary>
        </member>
        <member name="M:ADMS.API.Controllers.MatterController.ValidateAuditRecords(System.Collections.Generic.IEnumerable{ADMS.API.Models.MatterDocumentActivityUserMinimalDto})">
            <summary>
            Validates audit records using centralized validation.
            </summary>
        </member>
        <member name="M:ADMS.API.Controllers.MatterController.UpdateMatterWithAuditAsync(System.Guid,ADMS.API.Models.MatterForUpdateDto)">
            <summary>
            Updates a matter with audit trail.
            </summary>
        </member>
        <member name="M:ADMS.API.Controllers.MatterController.RestoreMatterWithAuditAsync(System.Guid)">
            <summary>
            Restores a matter with audit trail.
            </summary>
        </member>
        <member name="M:ADMS.API.Controllers.MatterController.ValidateReturnedMatters``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Validates returned matters using centralized validation.
            </summary>
        </member>
        <member name="M:ADMS.API.Controllers.MatterController.CreateProblemDetails(System.Int32,System.String)">
            <summary>
            Creates a standardized problem details object.
            </summary>
        </member>
        <member name="M:ADMS.API.Controllers.MatterController.CreateInternalServerErrorResponse(System.String)">
            <summary>
            Creates a standardized internal server error response.
            </summary>
        </member>
        <member name="T:ADMS.API.Controllers.RevisionController">
            <summary>
            Controller for managing document revisions within the ADMS system.
            </summary>
            <remarks>
            This controller provides comprehensive revision management functionality including:
            - Revision creation with automatic numbering and validation
            - Revision retrieval with pagination, filtering, and sorting
            - Revision updates with business rule enforcement
            - Revision deletion with safety checks and audit trails
            - Comprehensive audit history tracking for revisions
            
            All endpoints implement consistent error handling, centralized validation,
            structured logging, and security best practices including:
            - Comprehensive input validation using data annotations and custom validation
            - Centralized validation service integration
            - Proper HTTP status code usage following REST conventions
            - Detailed error responses using RFC 7807 Problem Details format
            - Structured logging with correlation IDs for traceability
            - API versioning support with proper headers
            
            Business Rules Enforced:
            - Revisions must belong to valid documents within valid matters
            - Revision numbers are automatically assigned in sequential order
            - All operations maintain comprehensive audit trails
            - Entity relationships are validated before operations
            - Date/time handling uses UTC with local formatting options
            
            The controller supports advanced features like:
            - Pagination with metadata headers for efficient data retrieval
            - Flexible sorting through resource parameters
            - Comprehensive audit history with user attribution
            - Automatic revision numbering based on existing revisions
            </remarks>
        </member>
        <member name="M:ADMS.API.Controllers.RevisionController.#ctor(Microsoft.Extensions.Logging.ILogger{ADMS.API.Controllers.RevisionController},ADMS.API.Services.IAdmsRepository,MapsterMapper.IMapper,ADMS.API.Services.IPropertyMappingService,Microsoft.AspNetCore.Mvc.Infrastructure.ProblemDetailsFactory,ADMS.API.Services.IValidationService)">
            <summary>
            Controller for managing document revisions within the ADMS system.
            </summary>
            <remarks>
            This controller provides comprehensive revision management functionality including:
            - Revision creation with automatic numbering and validation
            - Revision retrieval with pagination, filtering, and sorting
            - Revision updates with business rule enforcement
            - Revision deletion with safety checks and audit trails
            - Comprehensive audit history tracking for revisions
            
            All endpoints implement consistent error handling, centralized validation,
            structured logging, and security best practices including:
            - Comprehensive input validation using data annotations and custom validation
            - Centralized validation service integration
            - Proper HTTP status code usage following REST conventions
            - Detailed error responses using RFC 7807 Problem Details format
            - Structured logging with correlation IDs for traceability
            - API versioning support with proper headers
            
            Business Rules Enforced:
            - Revisions must belong to valid documents within valid matters
            - Revision numbers are automatically assigned in sequential order
            - All operations maintain comprehensive audit trails
            - Entity relationships are validated before operations
            - Date/time handling uses UTC with local formatting options
            
            The controller supports advanced features like:
            - Pagination with metadata headers for efficient data retrieval
            - Flexible sorting through resource parameters
            - Comprehensive audit history with user attribution
            - Automatic revision numbering based on existing revisions
            </remarks>
        </member>
        <member name="M:ADMS.API.Controllers.RevisionController.CreateRevisionAsync(System.Guid,System.Guid,ADMS.API.Models.RevisionForCreationDto)">
            <summary>
            Creates a new revision for a specified document within a matter.
            </summary>
            <remarks>
            This endpoint creates a new revision with comprehensive validation including:
            - Input validation using data annotations and custom validation rules
            - Entity relationship validation (matter -> document hierarchy)
            - Automatic revision numbering based on existing revisions
            - Business rule validation for revision creation
            - Automatic audit trail creation for the revision creation event
            
            The creation process includes:
            1. Comprehensive DTO and parameter validation using centralized validation services
            2. Entity existence validation with proper hierarchy checking
            3. Automatic revision number assignment (sequential)
            4. Revision creation with proper entity relationship setup
            5. Audit log creation with creation activity tracking
            
            Upon successful creation, the response includes a Location header pointing
            to the newly created revision and returns the created revision data.
            </remarks>
            <param name="matterId">The unique identifier of the matter containing the document.</param>
            <param name="documentId">The unique identifier of the document to add the revision to.</param>
            <param name="revision">The revision data transfer object containing the information needed to create a new revision.</param>
            <returns>
            <para>201 Created - Revision successfully created with location header and revision data.</para>
            <para>400 BadRequest - Invalid input data, validation errors, or malformed request.</para>
            <para>404 NotFound - The specified matter or document does not exist.</para>
            <para>500 InternalServerError - Unexpected server error during revision creation.</para>
            </returns>
        </member>
        <member name="M:ADMS.API.Controllers.RevisionController.DeleteRevisionAsync(System.Guid,System.Guid,System.Guid)">
            <summary>
            Deletes a specific revision from a document within a matter.
            </summary>
            <remarks>
            This endpoint provides secure revision deletion with comprehensive validation:
            - Validates that the revision, document, and matter all exist and are properly related
            - Performs business rule validation to ensure the revision can be safely deleted
            - Creates comprehensive audit trail for the deletion operation
            - Implements soft deletion to maintain data integrity and audit history
            
            Business Rules:
            - Revision must belong to the specified document
            - Document must belong to the specified matter
            - Deletion creates an audit record for compliance and tracking
            - The deletion maintains referential integrity
            
            The deletion process includes:
            1. Parameter and entity existence validation with hierarchy checking
            2. Business rule validation (revision ownership, etc.)
            3. Audit trail creation before deletion
            4. Secure deletion with proper cleanup
            5. Success confirmation without exposing internal details
            </remarks>
            <param name="matterId">The unique identifier of the matter containing the document.</param>
            <param name="documentId">The unique identifier of the document containing the revision.</param>
            <param name="revisionId">The unique identifier of the revision to delete.</param>
            <returns>
            <para>204 NoContent - Revision successfully deleted.</para>
            <para>400 BadRequest - Invalid revision ID, business rule violation, or validation errors.</para>
            <para>404 NotFound - The specified matter, document, or revision does not exist.</para>
            <para>500 InternalServerError - Unexpected server error during deletion.</para>
            </returns>
        </member>
        <member name="M:ADMS.API.Controllers.RevisionController.GetRevisionAsync(System.Guid,System.Guid,System.Guid)">
            <summary>
            Retrieves a specific revision for a document within a matter.
            </summary>
            <remarks>
            This endpoint provides secure revision retrieval with comprehensive validation:
            - Validates entity existence and proper hierarchical relationships
            - Ensures revision belongs to the correct document and matter
            - Returns properly validated and mapped revision data
            - Creates audit trail for revision access (VIEWED activity)
            - Comprehensive error handling with proper HTTP status codes
            
            The retrieval process includes:
            - Parameter validation using centralized validation services
            - Entity existence validation with relationship checking
            - DTO mapping and validation for consistent data format
            - Audit logging for compliance and usage tracking
            - Error handling with detailed problem responses
            </remarks>
            <param name="matterId">The unique identifier of the matter containing the document.</param>
            <param name="documentId">The unique identifier of the document containing the revision.</param>
            <param name="revisionId">The unique identifier of the revision to retrieve.</param>
            <returns>
            <para>200 OK - Revision successfully retrieved with requested data.</para>
            <para>400 BadRequest - Invalid revision ID or validation errors.</para>
            <para>404 NotFound - The specified matter, document, or revision does not exist.</para>
            <para>500 InternalServerError - Unexpected server error during retrieval.</para>
            </returns>
        </member>
        <member name="M:ADMS.API.Controllers.RevisionController.GetRevisionAuditsAsync(System.Guid,System.Guid,System.Guid)">
            <summary>
            Retrieves the audit records (activity history) for a specific revision.
            </summary>
            <remarks>
            This endpoint provides comprehensive revision audit history including:
            - Complete activity tracking for all revision-related operations
            - User attribution and timestamp information for all activities
            - Proper validation of all input parameters and entity relationships
            - Comprehensive error handling with detailed responses
            - Validation of all returned audit data for consistency
            
            Audit History Information Includes:
            - Revision creation, update, and deletion activities
            - User access and modification tracking
            - Timestamp information for activity sequencing
            - Complete user attribution for compliance requirements
            - Activity type classification for reporting purposes
            
            Features:
            - Comprehensive error handling with detailed problem responses
            - Validation of all returned audit data
            - Support for empty audit history with proper 404 response
            - API versioning and correlation ID support
            - Structured logging for debugging and monitoring
            </remarks>
            <param name="matterId">The unique identifier of the matter containing the document.</param>
            <param name="documentId">The unique identifier of the document containing the revision.</param>
            <param name="revisionId">The unique identifier of the revision whose audit records are to be retrieved.</param>
            <returns>
            <para>200 OK - Complete audit history successfully retrieved.</para>
            <para>400 BadRequest - Invalid parameters or validation errors.</para>
            <para>404 NotFound - The specified entities do not exist or no audit history available.</para>
            <para>500 InternalServerError - Unexpected server error during audit retrieval.</para>
            </returns>
        </member>
        <member name="M:ADMS.API.Controllers.RevisionController.GetRevisionsAsync(System.Guid,System.Guid,ADMS.API.ResourceParameters.RevisionsResourceParameters)">
            <summary>
            Retrieves a paginated list of revisions for a specific document within a matter.
            </summary>
            <remarks>
            This endpoint provides advanced revision listing functionality with comprehensive features:
            - Pagination with metadata headers following the same pattern as DocumentController and MatterController
            - Flexible sorting through resource parameters with property mapping validation
            - Comprehensive error handling and validation consistent with other controllers
            - Performance optimization for large revision datasets
            - Consistent pagination metadata format using Response.AddPaginationMetadata()
            
            Pagination Features (consistent with DocumentController):
            - Configurable page size with reasonable limits
            - Page navigation with total count information
            - Metadata headers for client-side pagination handling (X-Pagination header)
            - Performance optimization for large result sets
            - HasNext/HasPrevious navigation indicators
            
            Sorting and Filtering:
            - Multiple sort field options with property mapping validation
            - Ascending and descending sort directions
            - Proper validation of OrderBy parameters using property mapping service
            - Model state validation for query parameters
            
            Response Format:
            - JSON/XML content negotiation support
            - Comprehensive pagination metadata in headers (same as MatterController)
            - Consistent error responses using problem details format
            - API versioning and correlation ID support
            
            The pagination implementation follows the established patterns from:
            - DocumentController.GetDocumentsAsync() for header management
            - MatterController.GetMattersAsync() for parameter validation
            </remarks>
            <param name="matterId">The unique identifier of the matter containing the document.</param>
            <param name="documentId">The unique identifier of the document whose revisions are to be retrieved.</param>
            <param name="resourceParameters">Resource parameters for pagination and sorting, following the same pattern as DocumentsResourceParameters and MattersResourceParameters.</param>
            <returns>
            <para>200 OK - Paginated revision list successfully retrieved with metadata headers.</para>
            <para>400 BadRequest - Invalid pagination parameters, sort criteria, or validation errors.</para>
            <para>404 NotFound - The specified matter or document does not exist.</para>
            <para>500 InternalServerError - Unexpected server error during revision retrieval.</para>
            </returns>
        </member>
        <member name="M:ADMS.API.Controllers.RevisionController.UpdateRevisionAsync(System.Guid,System.Guid,System.Guid,ADMS.API.Models.RevisionForUpdateDto)">
            <summary>
            Updates an existing revision for a specified document within a matter.
            </summary>
            <remarks>
            This endpoint provides secure revision updating with comprehensive validation:
            - Validates all input parameters including revision existence and hierarchy
            - Performs business rule validation for update operations
            - Maintains complete audit trail for all changes
            - Validates updated data using centralized validation services
            - Implements proper entity relationship checking
            
            Update Process:
            1. Input validation using data annotations and custom rules
            2. Entity existence validation with hierarchy checking
            3. Business rule validation for update permissions
            4. Data persistence with proper error handling
            5. Audit trail creation for the update operation
            6. Response with appropriate status and headers
            
            Features:
            - Comprehensive error handling with detailed problem responses
            - Audit logging for compliance and change tracking
            - Proper HTTP status codes following REST conventions
            - API versioning and correlation ID support
            - Entity relationship validation (revision -> document -> matter)
            </remarks>
            <param name="matterId">The unique identifier of the matter containing the document.</param>
            <param name="documentId">The unique identifier of the document containing the revision.</param>
            <param name="revisionId">The unique identifier of the revision to update.</param>
            <param name="revision">The revision update data transfer object containing the new revision information.</param>
            <returns>
            <para>204 NoContent - Revision successfully updated.</para>
            <para>400 BadRequest - Invalid input data, validation errors, or business rule violations.</para>
            <para>404 NotFound - The specified matter, document, or revision does not exist.</para>
            <para>500 InternalServerError - Unexpected server error during update.</para>
            </returns>
        </member>
        <member name="M:ADMS.API.Controllers.RevisionController.GetRevisionOptions">
            <summary>
            Returns the HTTP methods supported by the revision resource.
            </summary>
            <remarks>
            This endpoint implements the HTTP OPTIONS method to allow clients
            to discover which operations are available on the revision resource.
            This is useful for API documentation tools, CORS preflight requests,
            and client applications that need to determine available functionality dynamically.
            
            The response includes appropriate headers indicating supported methods,
            API version information, and CORS configuration if applicable.
            </remarks>
            <returns>
            <para>204 NoContent - Response with Allow header listing supported HTTP methods.</para>
            <para>500 InternalServerError - Unexpected server error occurred.</para>
            </returns>
        </member>
        <member name="M:ADMS.API.Controllers.RevisionController.ValidateCreateRevisionParametersAsync(System.Guid,System.Guid,ADMS.API.Models.RevisionForCreationDto)">
            <summary>
            Validates parameters for revision creation operations.
            </summary>
        </member>
        <member name="M:ADMS.API.Controllers.RevisionController.ValidateDeleteRevisionParametersAsync(System.Guid,System.Guid,System.Guid)">
            <summary>
            Validates parameters for revision deletion operations.
            </summary>
        </member>
        <member name="M:ADMS.API.Controllers.RevisionController.ValidateGetRevisionParametersAsync(System.Guid,System.Guid,System.Guid)">
            <summary>
            Validates parameters for revision retrieval operations.
            </summary>
        </member>
        <member name="M:ADMS.API.Controllers.RevisionController.ValidateGetRevisionAuditsParametersAsync(System.Guid,System.Guid,System.Guid)">
            <summary>
            Validates parameters for revision audit retrieval operations.
            </summary>
        </member>
        <member name="M:ADMS.API.Controllers.RevisionController.ValidateGetRevisionsParametersAsync(System.Guid,System.Guid,ADMS.API.ResourceParameters.RevisionsResourceParameters)">
            <summary>
            Validates parameters for paginated revision retrieval operations.
            Following the pattern from MatterController.ValidateGetMattersParametersAsync()
            </summary>
        </member>
        <member name="M:ADMS.API.Controllers.RevisionController.ValidateUpdateRevisionParametersAsync(System.Guid,System.Guid,System.Guid,ADMS.API.Models.RevisionForUpdateDto)">
            <summary>
            Validates parameters for revision update operations.
            </summary>
        </member>
        <member name="M:ADMS.API.Controllers.RevisionController.ValidateDocumentAndGetRevisionCountAsync(System.Guid,System.Guid)">
            <summary>
            Validates document and retrieves revision count for automatic numbering.
            </summary>
        </member>
        <member name="M:ADMS.API.Controllers.RevisionController.CreateRevisionWithAuditAsync(System.Guid,ADMS.API.Models.RevisionForCreationDto,System.Int32)">
            <summary>
            Creates a revision with audit trail.
            </summary>
        </member>
        <member name="M:ADMS.API.Controllers.RevisionController.ValidateRevisionDeletionBusinessRulesAsync(System.Guid,System.Guid,System.Guid)">
            <summary>
            Validates business rules for revision deletion.
            </summary>
        </member>
        <member name="M:ADMS.API.Controllers.RevisionController.DeleteRevisionWithAuditAsync(System.Guid)">
            <summary>
            Deletes a revision with audit trail.
            </summary>
        </member>
        <member name="M:ADMS.API.Controllers.RevisionController.GetValidatedRevisionAsync(System.Guid,System.Guid,System.Guid)">
            <summary>
            Retrieves and validates a revision with hierarchy checking.
            </summary>
        </member>
        <member name="M:ADMS.API.Controllers.RevisionController.CreateRevisionViewedAuditAsync(System.Guid)">
            <summary>
            Creates audit trail for revision viewing.
            </summary>
        </member>
        <member name="M:ADMS.API.Controllers.RevisionController.RetrieveRevisionAuditHistoryAsync(System.Guid,System.Guid,System.Guid)">
            <summary>
            Retrieves audit history for a revision.
            </summary>
        </member>
        <member name="M:ADMS.API.Controllers.RevisionController.ValidateAuditRecords(System.Collections.Generic.IEnumerable{ADMS.API.Models.RevisionActivityUserDto})">
            <summary>
            Validates audit records using centralized validation.
            </summary>
        </member>
        <member name="M:ADMS.API.Controllers.RevisionController.ValidateDocumentBelongsToMatterAsync(System.Guid,System.Guid)">
            <summary>
            Validates that document belongs to the specified matter.
            Following the pattern from other controllers for business rule validation.
            </summary>
        </member>
        <member name="M:ADMS.API.Controllers.RevisionController.ValidateReturnedRevisions(System.Collections.Generic.IEnumerable{ADMS.API.Models.RevisionDto})">
            <summary>
            Validates returned revisions using centralized validation.
            Following the pattern from MatterController.ValidateReturnedMatters()
            </summary>
        </member>
        <member name="M:ADMS.API.Controllers.RevisionController.ValidateRevisionUpdateBusinessRulesAsync(System.Guid,System.Guid,System.Guid)">
            <summary>
            Validates business rules for revision update.
            </summary>
        </member>
        <member name="M:ADMS.API.Controllers.RevisionController.UpdateRevisionWithAuditAsync(System.Guid,System.Guid,System.Guid,ADMS.API.Models.RevisionForUpdateDto)">
            <summary>
            Updates a revision with audit trail.
            </summary>
        </member>
        <member name="M:ADMS.API.Controllers.RevisionController.CreateProblemDetails(System.Int32,System.String)">
            <summary>
            Creates a standardized problem details object.
            </summary>
        </member>
        <member name="M:ADMS.API.Controllers.RevisionController.CreateInternalServerErrorResponse(System.String)">
            <summary>
            Creates a standardized internal server error response.
            </summary>
        </member>
        <member name="T:ADMS.API.DbContexts.AdmsContext">
            <summary>
                ADMS Context for database access
            </summary>
            <remarks>
                Adms constructor
            </remarks>
            <param name="options"></param>
        </member>
        <member name="M:ADMS.API.DbContexts.AdmsContext.#ctor(Microsoft.EntityFrameworkCore.DbContextOptions{ADMS.API.DbContexts.AdmsContext})">
            <summary>
                ADMS Context for database access
            </summary>
            <remarks>
                Adms constructor
            </remarks>
            <param name="options"></param>
        </member>
        <member name="P:ADMS.API.DbContexts.AdmsContext.Documents">
            <summary>
                Documents database set for database access
            </summary>
        </member>
        <member name="P:ADMS.API.DbContexts.AdmsContext.DocumentActivities">
            <summary>
                DocumentActivities database set for database access
            </summary>
        </member>
        <member name="P:ADMS.API.DbContexts.AdmsContext.Matters">
            <summary>
                Matters database set for database access
            </summary>
        </member>
        <member name="P:ADMS.API.DbContexts.AdmsContext.MatterActivities">
            <summary>
                MatterActivities database set for database access
            </summary>
        </member>
        <member name="P:ADMS.API.DbContexts.AdmsContext.DocumentActivityUsers">
            <summary>
                DocumentActivityUsers database set for database access
            </summary>
        </member>
        <member name="P:ADMS.API.DbContexts.AdmsContext.MatterDocumentActivities">
            <summary>
                MatterDocumentActivities database set for database access
            </summary>
        </member>
        <member name="P:ADMS.API.DbContexts.AdmsContext.MatterDocumentActivityUsersFrom">
            <summary>
                MatterDocumentActivityUsersFrom database set for database access
            </summary>
        </member>
        <member name="P:ADMS.API.DbContexts.AdmsContext.MatterDocumentActivityUsersTo">
            <summary>
                MatterDocumentActivityUsersTo database set for database access
            </summary>
        </member>
        <member name="P:ADMS.API.DbContexts.AdmsContext.RevisionActivities">
            <summary>
                RevisionActivities database set for database access
            </summary>
        </member>
        <member name="P:ADMS.API.DbContexts.AdmsContext.Revisions">
            <summary>
                Revisions database set for database access
            </summary>
        </member>
        <member name="P:ADMS.API.DbContexts.AdmsContext.Users">
            <summary>
                Users database set for database access
            </summary>
        </member>
        <member name="P:ADMS.API.DbContexts.AdmsContext.MatterActivityUsers">
            <summary>
                MatterActivityUsers database set for database access
            </summary>
        </member>
        <member name="P:ADMS.API.DbContexts.AdmsContext.RevisionActivityUsers">
            <summary>
                RevisionActivityUsers database set for database access
            </summary>
        </member>
        <member name="M:ADMS.API.DbContexts.AdmsContext.OnModelCreating(Microsoft.EntityFrameworkCore.ModelBuilder)">
            <summary>
            Configures the entity framework model for the context, including relationships and seed data.
            </summary>
            <param name="modelBuilder">The builder used to construct the model for the context.</param>
        </member>
        <member name="M:ADMS.API.DbContexts.AdmsContext.ConfigureRevisionActivityUser(Microsoft.EntityFrameworkCore.ModelBuilder)">
            <summary>
            Configures the entity relationships and keys for the <see cref="T:ADMS.API.Entities.RevisionActivityUser"/> entity.
            </summary>
            <param name="modelBuilder">The builder used to construct the model for the context.</param>
        </member>
        <member name="M:ADMS.API.DbContexts.AdmsContext.ConfigureDocumentActivityUser(Microsoft.EntityFrameworkCore.ModelBuilder)">
            <summary>
            Configures the entity relationships and keys for the <see cref="T:ADMS.API.Entities.DocumentActivityUser"/> entity.
            </summary>
            <param name="modelBuilder">The builder used to construct the model for the context.</param>
        </member>
        <member name="M:ADMS.API.DbContexts.AdmsContext.ConfigureMatterActivityUser(Microsoft.EntityFrameworkCore.ModelBuilder)">
            <summary>
            Configures the entity relationships and composite primary key for the <see cref="T:ADMS.API.Entities.MatterActivityUser"/> entity.
            The composite key consists of MatterId, MatterActivityId, UserId, and CreatedAt, ensuring that
            only the combination of all four fields must be unique.
            </summary>
            <param name="modelBuilder">The builder used to construct the model for the context.</param>
        </member>
        <member name="M:ADMS.API.DbContexts.AdmsContext.ConfigureMatterDocumentActivityUserFrom(Microsoft.EntityFrameworkCore.ModelBuilder)">
            <summary>
            Configures the entity relationships and keys for the <see cref="T:ADMS.API.Entities.MatterDocumentActivityUserFrom"/> entity.
            </summary>
            <param name="modelBuilder">The builder used to construct the model for the context.</param>
        </member>
        <member name="M:ADMS.API.DbContexts.AdmsContext.ConfigureMatterDocumentActivityUserTo(Microsoft.EntityFrameworkCore.ModelBuilder)">
            <summary>
            Configures the entity relationships and keys for the <see cref="T:ADMS.API.Entities.MatterDocumentActivityUserTo"/> entity.
            </summary>
            <param name="modelBuilder">The builder used to construct the model for the context.</param>
        </member>
        <member name="M:ADMS.API.DbContexts.AdmsContext.SeedInitialData(Microsoft.EntityFrameworkCore.ModelBuilder)">
            <summary>
            Seeds the initial data for activities, users, matters, and audit entries into the model.
            </summary>
            <param name="modelBuilder">The builder used to construct the model for the context.</param>
        </member>
        <member name="M:ADMS.API.DbContexts.AdmsContext.SeedRevisionActivities(Microsoft.EntityFrameworkCore.ModelBuilder)">
            <summary>
            Seeds the initial revision activity data into the model.
            </summary>
            <param name="modelBuilder">The builder used to construct the model for the context.</param>
        </member>
        <member name="M:ADMS.API.DbContexts.AdmsContext.SeedDocumentActivities(Microsoft.EntityFrameworkCore.ModelBuilder)">
            <summary>
            Seeds the initial document activity data into the model.
            </summary>
            <param name="modelBuilder">The builder used to construct the model for the context.</param>
        </member>
        <member name="M:ADMS.API.DbContexts.AdmsContext.SeedMatterActivities(Microsoft.EntityFrameworkCore.ModelBuilder)">
            <summary>
            Seeds the initial matter activity data into the model.
            </summary>
            <param name="modelBuilder">The builder used to construct the model for the context.</param>
        </member>
        <member name="M:ADMS.API.DbContexts.AdmsContext.SeedMatterDocumentActivities(Microsoft.EntityFrameworkCore.ModelBuilder)">
            <summary>
            Seeds the initial matter document activity data into the model.
            </summary>
            <param name="modelBuilder">The builder used to construct the model for the context.</param>
        </member>
        <member name="M:ADMS.API.DbContexts.AdmsContext.SeedUsers(Microsoft.EntityFrameworkCore.ModelBuilder)">
            <summary>
            Seeds the initial user data into the model.
            </summary>
            <param name="modelBuilder">The builder used to construct the model for the context.</param>
        </member>
        <member name="M:ADMS.API.DbContexts.AdmsContext.SeedMatters(Microsoft.EntityFrameworkCore.ModelBuilder)">
            <summary>
            Seeds the initial matter data into the model.
            </summary>
            <param name="modelBuilder">The builder used to construct the model for the context.</param>
        </member>
        <member name="M:ADMS.API.DbContexts.AdmsContext.SeedMatterActivityUsers(Microsoft.EntityFrameworkCore.ModelBuilder)">
            <summary>
            Seeds the initial matter activity user audit entries into the model.
            </summary>
            <param name="modelBuilder">The builder used to construct the model for the context.</param>
        </member>
        <member name="T:ADMS.API.Extensions.HttpResponseExtensions">
            <summary>
            Extension methods for HttpResponse to enhance functionality for API responses.
            </summary>
            <remarks>
            This static class provides extension methods for the HttpResponse class to add
            common functionality such as pagination metadata headers. These extensions
            help maintain consistency across API endpoints and reduce code duplication.
            </remarks>
        </member>
        <member name="M:ADMS.API.Extensions.HttpResponseExtensions.AddPaginationMetadata``1(Microsoft.AspNetCore.Http.HttpResponse,ADMS.API.Helpers.PagedList{``0})">
            <summary>
            Adds pagination metadata to the HTTP response headers as JSON.
            </summary>
            <remarks>
            This method serializes pagination information from a PagedList and adds it
            to the response headers under the 'X-Pagination' key. This allows clients
            to access pagination metadata without needing to inspect the response body.
            
            The pagination metadata includes:
            - TotalCount: Total number of items across all pages
            - PageSize: Number of items per page
            - CurrentPage: Current page number (1-based)
            - TotalPages: Total number of pages
            - HasNext: Boolean indicating if there is a next page
            - HasPrevious: Boolean indicating if there is a previous page
            
            The metadata is serialized using System.Text.Json with camelCase naming policy
            to maintain consistency with the API's JSON response format.
            </remarks>
            <typeparam name="T">The type of items in the paged list.</typeparam>
            <param name="response">The HTTP response to add metadata to. Cannot be null.</param>
            <param name="pagedList">The paged list containing pagination metadata. Cannot be null.</param>
            <exception cref="T:System.ArgumentNullException">
            Thrown when <paramref name="response"/> or <paramref name="pagedList"/> is null.
            </exception>
            <example>
            <code>
            var pagedResult = await _repository.GetPaginatedItemsAsync(pageNumber, pageSize);
            Response.AddPaginationMetadata(pagedResult);
            return Ok(pagedResult);
            </code>
            </example>
        </member>
        <member name="M:ADMS.API.Extensions.HttpResponseExtensions.AddCorrelationId(Microsoft.AspNetCore.Http.HttpResponse,System.String)">
            <summary>
            Adds a correlation ID to the HTTP response headers for request tracing.
            </summary>
            <remarks>
            This method adds a correlation ID to the response headers, which can be used
            for request tracing and logging correlation across distributed systems.
            If no correlation ID is provided, a new GUID will be generated.
            </remarks>
            <param name="response">The HTTP response to add the correlation ID to. Cannot be null.</param>
            <param name="correlationId">
            Optional correlation ID. If null or empty, a new GUID will be generated.
            </param>
            <exception cref="T:System.ArgumentNullException">
            Thrown when <paramref name="response"/> is null.
            </exception>
            <example>
            <code>
            Response.AddCorrelationId();
            // or with a specific correlation ID
            Response.AddCorrelationId("12345678-1234-1234-1234-123456789012");
            </code>
            </example>
        </member>
        <member name="M:ADMS.API.Extensions.HttpResponseExtensions.AddApiVersion(Microsoft.AspNetCore.Http.HttpResponse,System.String)">
            <summary>
            Adds API version information to the HTTP response headers.
            </summary>
            <remarks>
            This method adds version information to the response headers, making it
            easier for clients to identify which API version processed their request.
            This is particularly useful in versioned APIs for debugging and monitoring.
            </remarks>
            <param name="response">The HTTP response to add version information to. Cannot be null.</param>
            <param name="version">The API version string. Cannot be null or empty.</param>
            <exception cref="T:System.ArgumentNullException">
            Thrown when <paramref name="response"/> or <paramref name="version"/> is null.
            </exception>
            <exception cref="T:System.ArgumentException">
            Thrown when <paramref name="version"/> is empty or whitespace.
            </exception>
            <example>
            <code>
            Response.AddApiVersion("1.0");
            </code>
            </example>
        </member>
        <member name="M:ADMS.API.Extensions.HttpResponseExtensions.AddCacheHeaders(Microsoft.AspNetCore.Http.HttpResponse,System.Int32,System.Boolean,System.Boolean)">
            <summary>
            Adds cache control headers to the HTTP response.
            </summary>
            <remarks>
            This method adds appropriate cache control headers to the response,
            allowing fine-grained control over client-side and proxy caching behavior.
            This is useful for optimizing performance and reducing server load for
            cacheable resources.
            </remarks>
            <param name="response">The HTTP response to add cache headers to. Cannot be null.</param>
            <param name="maxAge">Maximum age for caching in seconds. Must be non-negative.</param>
            <param name="isPublic">
            If true, allows public caches (proxies) to cache the response.
            If false, only private caches (browsers) can cache.
            </param>
            <param name="mustRevalidate">
            If true, forces caches to revalidate with the origin server before serving stale content.
            </param>
            <exception cref="T:System.ArgumentNullException">
            Thrown when <paramref name="response"/> is null.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Thrown when <paramref name="maxAge"/> is negative.
            </exception>
            <example>
            <code>
            // Cache for 5 minutes, public cache, must revalidate
            Response.AddCacheHeaders(300, isPublic: true, mustRevalidate: true);
            
            // No caching
            Response.AddCacheHeaders(0, isPublic: false, mustRevalidate: false);
            </code>
            </example>
        </member>
        <member name="T:ADMS.API.Helpers.AuditEnums">
            <summary>
            Provides enumerations related to audit operations.
            </summary>
        </member>
        <member name="T:ADMS.API.Helpers.AuditEnums.AuditDirection">
            <summary>
            Specifies the direction of an audit operation.
            </summary>
        </member>
        <member name="F:ADMS.API.Helpers.AuditEnums.AuditDirection.From">
            <summary>
            Indicates the operation is moving or referencing from a source.
            </summary>
        </member>
        <member name="F:ADMS.API.Helpers.AuditEnums.AuditDirection.To">
            <summary>
            Indicates the operation is moving or referencing to a target.
            </summary>
        </member>
        <member name="M:ADMS.API.Helpers.AuditEnums.TryParseDirection(System.String,ADMS.API.Helpers.AuditEnums.AuditDirection@)">
            <summary>
            Attempts to parse a string to an <see cref="T:ADMS.API.Helpers.AuditEnums.AuditDirection"/> value in a case-insensitive manner.
            </summary>
            <param name="value">The string value to parse.</param>
            <param name="direction">When this method returns, contains the parsed <see cref="T:ADMS.API.Helpers.AuditEnums.AuditDirection"/> value if parsing succeeded, or the default value if parsing failed.</param>
            <returns><c>true</c> if parsing succeeded; otherwise, <c>false</c>.</returns>
        </member>
        <member name="T:ADMS.API.Helpers.QueryableExtensions">
            <summary>
            Provides extension methods for IQueryable to support dynamic sorting using property mapping.
            </summary>
        </member>
        <member name="M:ADMS.API.Helpers.QueryableExtensions.ApplySort``1(System.Linq.IQueryable{``0},System.String,System.Collections.Generic.Dictionary{System.String,ADMS.API.Services.PropertyMappingValue})">
            <summary>
            Applies dynamic sorting to the source IQueryable based on the provided orderBy string and property mapping dictionary.
            </summary>
            <typeparam name="T">The type of the IQueryable elements.</typeparam>
            <param name="source">The source IQueryable to apply sorting to.</param>
            <param name="orderBy">A comma-separated string specifying the sort order (e.g., "Name desc, Age").</param>
            <param name="mappingDictionary">A dictionary mapping source property names to destination property mappings.</param>
            <returns>The sorted IQueryable.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if source or mappingDictionary is null.</exception>
            <exception cref="T:System.ArgumentException">Thrown if a property in orderBy is not found in the mapping dictionary.</exception>
        </member>
        <member name="M:ADMS.API.Helpers.QueryableExtensions.ExtractPropertyName(System.String)">
            <summary>
            Extracts the property name from an orderBy clause.
            </summary>
            <param name="orderByClause">The orderBy clause (e.g., "Name desc").</param>
            <returns>The extracted property name (e.g., "Name").</returns>
        </member>
        <member name="T:ADMS.API.Helpers.PagedList`1">
            <summary>
            Represents a paged list of items with pagination metadata.
            </summary>
            <typeparam name="T">The type of items in the list.</typeparam>
        </member>
        <member name="P:ADMS.API.Helpers.PagedList`1.CurrentPage">
            <summary>
            Gets the current page number (1-based).
            </summary>
        </member>
        <member name="P:ADMS.API.Helpers.PagedList`1.TotalPages">
            <summary>
            Gets the total number of pages.
            </summary>
        </member>
        <member name="P:ADMS.API.Helpers.PagedList`1.PageSize">
            <summary>
            Gets the size of each page.
            </summary>
        </member>
        <member name="P:ADMS.API.Helpers.PagedList`1.TotalCount">
            <summary>
            Gets the total number of items.
            </summary>
        </member>
        <member name="P:ADMS.API.Helpers.PagedList`1.HasPrevious">
            <summary>
            Gets a value indicating whether there is a previous page.
            </summary>
        </member>
        <member name="P:ADMS.API.Helpers.PagedList`1.HasNext">
            <summary>
            Gets a value indicating whether there is a next page.
            </summary>
        </member>
        <member name="M:ADMS.API.Helpers.PagedList`1.#ctor(System.Collections.Generic.List{`0},System.Int32,System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:ADMS.API.Helpers.PagedList`1"/> class.
            </summary>
        </member>
        <member name="M:ADMS.API.Helpers.PagedList`1.CreateAsync(System.Linq.IQueryable{`0},System.Int32,System.Int32)">
            <summary>
            Asynchronously creates a paged list from an <see cref="T:System.Linq.IQueryable`1"/> source.
            </summary>
            <param name="source">The source queryable.</param>
            <param name="pageNumber">The current page number (1-based).</param>
            <param name="pageSize">The size of each page.</param>
            <returns>A <see cref="T:ADMS.API.Helpers.PagedList`1"/> containing the items and pagination metadata.</returns>
        </member>
        <member name="M:ADMS.API.Helpers.PagedList`1.CreateEmpty(System.Int32,System.Int32)">
            <summary>
            Creates an empty paged list with the specified page number and page size.
            </summary>
            <param name="pageNumber">The current page number (1-based).</param>
            <param name="pageSize">The size of each page.</param>
            <returns>An empty <see cref="T:ADMS.API.Helpers.PagedList`1"/>.</returns>
        </member>
        <member name="T:ADMS.API.Migrations.InitialCreate">
            <inheritdoc />
        </member>
        <member name="M:ADMS.API.Migrations.InitialCreate.Up(Microsoft.EntityFrameworkCore.Migrations.MigrationBuilder)">
            <inheritdoc />
        </member>
        <member name="M:ADMS.API.Migrations.InitialCreate.Down(Microsoft.EntityFrameworkCore.Migrations.MigrationBuilder)">
            <inheritdoc />
        </member>
        <member name="M:ADMS.API.Migrations.InitialCreate.BuildTargetModel(Microsoft.EntityFrameworkCore.ModelBuilder)">
            <inheritdoc />
        </member>
        <member name="T:ADMS.API.Profiles.DocumentActivityProfile">
            <summary>
                AutoMapper profile for mapping between <see cref="T:ADMS.API.Entities.DocumentActivity"/>, <see cref="T:ADMS.API.Models.DocumentActivityDto"/>, and <see cref="T:ADMS.API.Models.DocumentActivityMinimalDto"/>.
            </summary>
        </member>
        <member name="M:ADMS.API.Profiles.DocumentActivityProfile.#ctor">
            <summary>
                Initializes a new instance of the <see cref="T:ADMS.API.Profiles.DocumentActivityProfile"/> class and configures entity-to-DTO mappings.
            </summary>
        </member>
        <member name="T:ADMS.API.Profiles.DocumentActivityUserProfile">
            <summary>
                AutoMapper profile for mapping between <see cref="T:ADMS.API.Entities.DocumentActivityUser"/>, <see cref="T:ADMS.API.Models.DocumentActivityUserDto"/>, and <see cref="T:ADMS.API.Models.DocumentActivityUserMinimalDto"/>.
            </summary>
        </member>
        <member name="M:ADMS.API.Profiles.DocumentActivityUserProfile.#ctor">
            <summary>
                Initializes a new instance of the <see cref="T:ADMS.API.Profiles.DocumentActivityUserProfile"/> class and configures entity-to-DTO mappings.
            </summary>
        </member>
        <member name="T:ADMS.API.Profiles.DocumentProfile">
            <summary>
                AutoMapper profile for mapping between <see cref="T:ADMS.API.Entities.Document"/> entities and their DTOs.
            </summary>
        </member>
        <member name="M:ADMS.API.Profiles.DocumentProfile.#ctor">
            <summary>
                Initializes a new instance of the <see cref="T:ADMS.API.Profiles.DocumentProfile"/> class and configures entity-to-DTO and DTO-to-entity mappings.
            </summary>
        </member>
        <member name="T:ADMS.API.Profiles.MatterActivityProfile">
            <summary>
                AutoMapper profile for mapping between <see cref="T:ADMS.API.Entities.MatterActivity"/>, <see cref="T:ADMS.API.Models.MatterActivityDto"/>, and <see cref="T:ADMS.API.Models.MatterActivityMinimalDto"/>.
            </summary>
        </member>
        <member name="M:ADMS.API.Profiles.MatterActivityProfile.#ctor">
            <summary>
                Initializes a new instance of the <see cref="T:ADMS.API.Profiles.MatterActivityProfile"/> class and configures entity-to-DTO mappings.
            </summary>
        </member>
        <member name="T:ADMS.API.Profiles.MatterActivityUserProfile">
            <summary>
                AutoMapper profile for mapping between <see cref="T:ADMS.API.Entities.MatterActivityUser"/>, <see cref="T:ADMS.API.Models.MatterActivityUserDto"/>, and <see cref="T:ADMS.API.Models.MatterActivityUserMinimalDto"/>.
            </summary>
        </member>
        <member name="M:ADMS.API.Profiles.MatterActivityUserProfile.#ctor">
            <summary>
                Initializes a new instance of the <see cref="T:ADMS.API.Profiles.MatterActivityUserProfile"/> class and configures entity-to-DTO mappings.
            </summary>
        </member>
        <member name="T:ADMS.API.Profiles.MatterDocumentActivityProfile">
            <summary>
                AutoMapper profile for mapping between <see cref="T:ADMS.API.Entities.MatterDocumentActivity"/>, <see cref="T:ADMS.API.Models.MatterDocumentActivityDto"/>, and <see cref="T:ADMS.API.Models.MatterDocumentActivityMinimalDto"/>.
            </summary>
        </member>
        <member name="M:ADMS.API.Profiles.MatterDocumentActivityProfile.#ctor">
            <summary>
                Initializes a new instance of the <see cref="T:ADMS.API.Profiles.MatterDocumentActivityProfile"/> class and configures entity-to-DTO mappings.
            </summary>
        </member>
        <member name="T:ADMS.API.Profiles.MatterDocumentActivityUserFromProfile">
            <summary>
                AutoMapper profile for mapping between <see cref="T:ADMS.API.Entities.MatterDocumentActivityUserFrom"/>, <see cref="T:ADMS.API.Models.MatterDocumentActivityUserFromDto"/>, and <see cref="T:ADMS.API.Models.MatterDocumentActivityUserMinimalDto"/>.
            </summary>
        </member>
        <member name="M:ADMS.API.Profiles.MatterDocumentActivityUserFromProfile.#ctor">
            <summary>
                Initializes a new instance of the <see cref="T:ADMS.API.Profiles.MatterDocumentActivityUserFromProfile"/> class and configures entity-to-DTO mappings.
            </summary>
        </member>
        <member name="T:ADMS.API.Profiles.MatterDocumentActivityUserProfile">
            <summary>
                AutoMapper profile for mapping between matter document activity user entities and their DTOs.
            </summary>
        </member>
        <member name="M:ADMS.API.Profiles.MatterDocumentActivityUserProfile.#ctor">
            <summary>
                Initializes a new instance of the <see cref="T:ADMS.API.Profiles.MatterDocumentActivityUserProfile"/> class and configures entity-to-DTO mappings.
            </summary>
        </member>
        <member name="T:ADMS.API.Profiles.MatterDocumentActivityUserToProfile">
            <summary>
                AutoMapper profile for mapping between <see cref="T:ADMS.API.Entities.MatterDocumentActivityUserTo"/>, <see cref="T:ADMS.API.Models.MatterDocumentActivityUserToDto"/>, and <see cref="T:ADMS.API.Models.MatterDocumentActivityUserMinimalDto"/>.
            </summary>
        </member>
        <member name="M:ADMS.API.Profiles.MatterDocumentActivityUserToProfile.#ctor">
            <summary>
                Initializes a new instance of the <see cref="T:ADMS.API.Profiles.MatterDocumentActivityUserToProfile"/> class and configures entity-to-DTO mappings.
            </summary>
        </member>
        <member name="T:ADMS.API.Profiles.MatterProfile">
            <summary>
                AutoMapper profile for mapping between <see cref="T:ADMS.API.Entities.Matter"/> entities and their DTOs.
            </summary>
        </member>
        <member name="M:ADMS.API.Profiles.MatterProfile.#ctor">
            <summary>
                Initializes a new instance of the <see cref="T:ADMS.API.Profiles.MatterProfile"/> class and configures entity-to-DTO and DTO-to-entity mappings.
            </summary>
        </member>
        <member name="T:ADMS.API.Profiles.RevisionActivityProfile">
            <summary>
                AutoMapper profile for mapping between <see cref="T:ADMS.API.Entities.RevisionActivity"/>, <see cref="T:ADMS.API.Models.RevisionActivityDto"/>, and <see cref="T:ADMS.API.Models.RevisionActivityMinimalDto"/>.
            </summary>
        </member>
        <member name="M:ADMS.API.Profiles.RevisionActivityProfile.#ctor">
            <summary>
                Initializes a new instance of the <see cref="T:ADMS.API.Profiles.RevisionActivityProfile"/> class and configures entity-to-DTO mappings.
            </summary>
        </member>
        <member name="T:ADMS.API.Profiles.RevisionActivityUserProfile">
            <summary>
                AutoMapper profile for mapping between <see cref="T:ADMS.API.Entities.RevisionActivityUser"/>, <see cref="T:ADMS.API.Models.RevisionActivityUserDto"/>, and <see cref="T:ADMS.API.Models.RevisionActivityUserMinimalDto"/>.
            </summary>
        </member>
        <member name="M:ADMS.API.Profiles.RevisionActivityUserProfile.#ctor">
            <summary>
                Initializes a new instance of the <see cref="T:ADMS.API.Profiles.RevisionActivityUserProfile"/> class and configures entity-to-DTO mappings.
            </summary>
        </member>
        <member name="T:ADMS.API.Profiles.RevisionProfile">
            <summary>
                AutoMapper profile for mapping between <see cref="T:ADMS.API.Entities.Revision"/> entities and their DTOs.
            </summary>
        </member>
        <member name="M:ADMS.API.Profiles.RevisionProfile.#ctor">
            <summary>
                Initializes a new instance of the <see cref="T:ADMS.API.Profiles.RevisionProfile"/> class and configures entity-to-DTO mappings.
            </summary>
        </member>
        <member name="T:ADMS.API.Profiles.UserProfile">
            <summary>
                MapsterMapper profile for mapping between <see cref="T:ADMS.API.Entities.User"/>, <see cref="T:ADMS.API.Models.UserDto"/>, and <see cref="T:ADMS.API.Models.UserMinimalDto"/>.
            </summary>
        </member>
        <member name="M:ADMS.API.Profiles.UserProfile.#ctor">
            <summary>
                Initializes a new instance of the <see cref="T:ADMS.API.Profiles.UserProfile"/> class and configures entity-to-DTO mappings.
            </summary>
        </member>
        <member name="T:ADMS.API.Services.AdmsRepository">
            <summary>
                Adms Repository containing implementation details.
            </summary>
            <summary>
            Initializes a new instance of the <see cref="T:ADMS.API.Services.AdmsRepository"/> class.
            </summary>
            <param name="logger">The logger used for logging repository operations and errors.</param>
            <param name="context">The database context for accessing ADMS entities.</param>
            <param name="mapper">The AutoMapper instance for mapping between entities and DTOs.</param>
            <param name="propertyMappingService">The service used for property mapping and dynamic sorting.</param>
            <param name="validationService">The service providing centralized validation logic for repository operations.</param>
        </member>
        <member name="M:ADMS.API.Services.AdmsRepository.#ctor(Microsoft.Extensions.Logging.ILogger{ADMS.API.Services.AdmsRepository},ADMS.API.DbContexts.AdmsContext,MapsterMapper.IMapper,ADMS.API.Services.IPropertyMappingService,ADMS.API.Services.IValidationService)">
            <summary>
                Adms Repository containing implementation details.
            </summary>
            <summary>
            Initializes a new instance of the <see cref="T:ADMS.API.Services.AdmsRepository"/> class.
            </summary>
            <param name="logger">The logger used for logging repository operations and errors.</param>
            <param name="context">The database context for accessing ADMS entities.</param>
            <param name="mapper">The AutoMapper instance for mapping between entities and DTOs.</param>
            <param name="propertyMappingService">The service used for property mapping and dynamic sorting.</param>
            <param name="validationService">The service providing centralized validation logic for repository operations.</param>
        </member>
        <member name="M:ADMS.API.Services.AdmsRepository.GetMatterActivityByActivityNameAsync(System.String)">
            <summary>
            Retrieves a <see cref="T:ADMS.API.Entities.MatterActivity"/> by its name.
            Returns <c>null</c> if the activity name is invalid, not found, not unique, or if an unexpected error occurs.
            All error conditions are logged.
            </summary>
            <param name="activityName">The name of the activity to retrieve.</param>
            <returns>
            The requested <see cref="T:ADMS.API.Entities.MatterActivity"/>, or <c>null</c> if not found or if an error occurs.
            </returns>
        </member>
        <member name="M:ADMS.API.Services.AdmsRepository.GetUserByUsernameAsync(System.String)">
            <summary>
            Retrieves a user by their username, using the validation service for input validation and consistent logging.
            </summary>
            <param name="username">The username of the user to retrieve.</param>
            <returns>The requested user, or null if not found.</returns>
        </member>
        <member name="M:ADMS.API.Services.AdmsRepository.SaveChangesAsync">
            <summary>
            Persists all changes made in this context to the database, using centralized validation and consistent logging.
            </summary>
            <returns>True if the changes were successfully saved, false otherwise.</returns>
        </member>
        <member name="M:ADMS.API.Services.AdmsRepository.GetExtendedAuditsAsync(System.Guid,System.Guid,ADMS.API.Helpers.AuditEnums.AuditDirection)">
            <summary>
            Retrieves an extended audit history for a specified matter and document, using centralized validation and consistent logging.
            </summary>
            <param name="matterId">The ID of the matter to retrieve data for.</param>
            <param name="documentId">The ID of the document to retrieve data for.</param>
            <param name="direction">The direction of the operation (From/To).</param>
            <returns>A queryable collection of audit history records.</returns>
            <exception cref="T:System.ArgumentException">Thrown if both <paramref name="matterId"/> and <paramref name="documentId"/> are empty, or if either does not exist.</exception>
        </member>
        <member name="M:ADMS.API.Services.AdmsRepository.ValidateAndProcessAuditDirection(ADMS.API.Helpers.AuditEnums.AuditDirection)">
            <summary>
            Validates and processes the specified audit direction, logging the result.
            </summary>
            <param name="direction">The audit direction to validate and process.</param>
            <returns>The validated <see cref="T:ADMS.API.Helpers.AuditEnums.AuditDirection"/> value.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if the direction is not a valid value.</exception>
        </member>
        <member name="M:ADMS.API.Services.AdmsRepository.GetUserAsync(System.String)">
            <summary>
            Retrieves a user by their username, using the validation service for input validation and consistent logging.
            </summary>
            <param name="username">The username of the user to retrieve.</param>
            <returns>The requested user, or null if not found.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="username"/> is null or empty.</exception>
            <exception cref="T:System.InvalidOperationException">Thrown if multiple users are found with the same username.</exception>
        </member>
        <member name="M:ADMS.API.Services.AdmsRepository.GetDocumentActivityAsync(System.String)">
            <summary>
            Retrieves a DocumentActivity by its name, using the validation service for input validation and consistent logging.
            </summary>
            <param name="activityName">The name of the activity to retrieve.</param>
            <returns>The requested DocumentActivity, or null if not found.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="activityName"/> is null or empty.</exception>
            <exception cref="T:System.InvalidOperationException">Thrown if multiple activities are found with the same name.</exception>
        </member>
        <member name="M:ADMS.API.Services.AdmsRepository.GetRevisionActivityByActivityNameAsync(System.String)">
            <summary>
            Retrieves a RevisionActivity by its name, using the validation service for input validation and consistent logging.
            </summary>
            <param name="activityName">The name of the revision activity to retrieve.</param>
            <returns>The requested RevisionActivity, or null if not found.</returns>
        </member>
        <member name="M:ADMS.API.Services.AdmsRepository.AddAuditLogAsync``2(``1,System.Guid,``0,System.Guid,ADMS.API.Entities.User,System.Guid)">
            <summary>
            Adds an audit log entry for the specified entity, activity, and user, using centralized validation and consistent logging.
            </summary>
            <typeparam name="TActivity">The type of the activity entity (e.g., DocumentActivity, MatterActivity, RevisionActivity).</typeparam>
            <typeparam name="TEntity">The type of the main entity (e.g., Document, Matter, Revision).</typeparam>
            <param name="entity">The entity being audited.</param>
            <param name="entityId">The unique identifier of the entity.</param>
            <param name="activity">The activity performed.</param>
            <param name="activityId">The unique identifier of the activity.</param>
            <param name="user">The user performing the action.</param>
            <param name="userId">The unique identifier of the user.</param>
            <returns>A task representing the asynchronous operation.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if any required argument is null.</exception>
            <exception cref="T:System.ArgumentException">Thrown if any required Guid is empty.</exception>
        </member>
        <member name="M:ADMS.API.Services.AdmsRepository.AddMoveCopyAuditLogAsync``2(``1,System.Guid,``0,System.Guid,ADMS.API.Entities.User,System.Guid,System.String)">
            <summary>
            Adds an audit log entry for the specified document Move / Copy entity, activity, and user, using centralized validation and consistent logging.
            </summary>
            <typeparam name="TActivity">The type of the activity entity (e.g., MatterDocumentActivity).</typeparam>
            <typeparam name="TEntity">The type of the main entity (e.g., Document, Matter, Revision).</typeparam>
            <param name="entity">The entity being audited.</param>
            <param name="entityId">The unique identifier of the entity.</param>
            <param name="activity">The activity performed.</param>
            <param name="activityId">The unique identifier of the activity.</param>
            <param name="user">The user performing the action.</param>
            <param name="userId">The unique identifier of the user.</param>
            <param name="direction">copy / Move FROM or To.</param>
            <returns>A task representing the asynchronous operation.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if any required argument is null.</exception>
            <exception cref="T:System.ArgumentException">Thrown if any required Guid is empty.</exception>
        </member>
        <member name="M:ADMS.API.Services.AdmsRepository.CreateRevisionAsync(System.Guid,ADMS.API.Models.RevisionDto)">
            <summary>
            Creates a new revision for a specified document, using centralized validation and consistent logging.
            </summary>
            <param name="documentId">The ID of the document to add the revision to.</param>
            <param name="revisionToAdd">The revision DTO to be added to the specified document.</param>
            <returns>The created <see cref="T:ADMS.API.Entities.Revision"/> entity, or null if the operation fails.</returns>
            <exception cref="T:System.ArgumentException">Thrown if <paramref name="documentId"/> is invalid.</exception>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="revisionToAdd"/> is null.</exception>
        </member>
        <member name="M:ADMS.API.Services.AdmsRepository.UpdateRevisionAsync(System.Guid,System.Guid,System.Guid,ADMS.API.Entities.Revision)">
            <summary>
            Updates a specified revision and logs the update as an audit activity, using centralized validation and consistent logging.
            </summary>
            <param name="matterId">The ID of the matter containing the revision to update.</param>
            <param name="documentId">The ID of the document containing the revision to update.</param>
            <param name="revisionId">The ID of the revision to update.</param>
            <param name="revision">The updated revision data.</param>
            <returns>The updated revision, or null if the operation fails.</returns>
        </member>
        <member name="M:ADMS.API.Services.AdmsRepository.AddDocumentAsync(System.Guid,ADMS.API.Models.DocumentForCreationDto)">
            <summary>
            Adds a new document to the specified matter, using centralized validation and consistent logging.
            </summary>
            <param name="matterId">The ID of the matter to add the document to.</param>
            <param name="document">The document DTO to add.</param>
            <returns>The created document, or null if the operation fails.</returns>
            <exception cref="T:System.ArgumentException">Thrown if <paramref name="matterId"/> is invalid or the matter does not exist.</exception>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="document"/> is null.</exception>
        </member>
        <member name="M:ADMS.API.Services.AdmsRepository.PerformDocumentOperationAsync(System.Guid,System.Guid,ADMS.API.Models.DocumentWithoutRevisionsDto,System.String)">
            <summary>
            Performs a move or copy operation on a document, using centralized validation and consistent logging.
            </summary>
            <param name="sourceMatterId">The ID of the source matter containing the document.</param>
            <param name="targetMatterId">The ID of the target matter to move or copy the document to.</param>
            <param name="document">The document to move or copy.</param>
            <param name="operationType">The type of operation to perform ("MOVED" or "COPIED").</param>
            <returns>True if the operation was successful, false otherwise.</returns>
            <exception cref="T:System.ArgumentException">Thrown if any matter or document does not exist.</exception>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="document"/> is null.</exception>
        </member>
        <member name="M:ADMS.API.Services.AdmsRepository.SetDocumentCheckStateAsync(System.Guid,System.Boolean)">
            <summary>
            Sets the check-in or check-out state of a document, using centralized validation and consistent logging.
            </summary>
            <param name="documentId">The ID of the document to update.</param>
            <param name="isCheckedOut">True to check out the document, false to check it in.</param>
            <returns>True if the operation was successful, false otherwise.</returns>
            <exception cref="T:System.ArgumentException">Thrown if the document does not exist.</exception>
        </member>
        <member name="M:ADMS.API.Services.AdmsRepository.DeleteDocumentAsync(ADMS.API.Models.DocumentDto)">
            <summary>
            Deletes a specified document by marking it as deleted, using centralized validation and consistent logging.
            </summary>
            <param name="document">The document to be deleted.</param>
            <returns>True if the document was successfully deleted, false otherwise.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="document"/> is null.</exception>
            <exception cref="T:System.ArgumentException">Thrown if the document does not exist.</exception>
        </member>
        <member name="M:ADMS.API.Services.AdmsRepository.DocumentExistsAsync(System.Guid)">
            <summary>
            Checks if a document exists in the database, using centralized validation and consistent logging.
            </summary>
            <param name="documentId">The ID of the document to check.</param>
            <returns>True if the document exists, false otherwise.</returns>
            <exception cref="T:System.ArgumentException">Thrown if <paramref name="documentId"/> is invalid.</exception>
        </member>
        <member name="M:ADMS.API.Services.AdmsRepository.FileNameExists(System.Guid,System.String)">
            <summary>
            Checks if a document with the specified file name already exists in the given matter,
            using centralized validation and consistent logging.
            </summary>
            <param name="matterId">The ID of the matter containing the document.</param>
            <param name="fileName">The file name to check.</param>
            <returns>True if the file name exists, false otherwise.</returns>
            <exception cref="T:System.ArgumentException">
            Thrown if <paramref name="matterId"/> is invalid or <paramref name="fileName"/> is null or empty.
            </exception>
        </member>
        <member name="M:ADMS.API.Services.AdmsRepository.GetDocumentAsync(System.Guid,System.Boolean,System.Boolean)">
            <summary>
            Retrieves a document by its ID, optionally including revisions and history, using centralized validation and consistent logging.
            </summary>
            <param name="documentId">The ID of the document to retrieve.</param>
            <param name="includeRevisions">Whether to include revisions in the result.</param>
            <param name="includeHistory">Whether to include history in the result.</param>
            <returns>The requested document, or null if not found.</returns>
            <exception cref="T:System.ArgumentException">Thrown if <paramref name="documentId"/> is empty or the document does not exist.</exception>
        </member>
        <member name="M:ADMS.API.Services.AdmsRepository.GetPaginatedDocumentsAsync(System.Guid,ADMS.API.ResourceParameters.DocumentsResourceParameters)">
            <summary>
            Retrieves a paginated list of documents for a specified matter, using centralized validation and consistent logging.
            </summary>
            <param name="matterId">The ID of the matter containing the documents.</param>
            <param name="parameters">The parameters for pagination and filtering.</param>
            <returns>A paginated list of documents.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="parameters"/> is null.</exception>
            <exception cref="T:System.ArgumentException">Thrown if <paramref name="matterId"/> is invalid or the matter does not exist.</exception>
        </member>
        <member name="M:ADMS.API.Services.AdmsRepository.UpdateDocumentAsync(System.Guid,ADMS.API.Models.DocumentForUpdateDto)">
            <summary>
            Updates a specified document with new data from a DTO, using centralized validation and consistent logging.
            </summary>
            <param name="documentId">The ID of the document to update.</param>
            <param name="documentForUpdate">The DTO containing updated document data.</param>
            <returns>The updated document, or null if the operation fails.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="documentForUpdate"/> is null.</exception>
            <exception cref="T:System.ArgumentException">Thrown if the document does not exist or validation fails.</exception>
        </member>
        <member name="M:ADMS.API.Services.AdmsRepository.GetDocumentActivityByActivityNameAsync(System.String)">
            <summary>
            Retrieves a DocumentActivity by its name, using the validation service for input validation and consistent logging.
            </summary>
            <param name="activityName">The name of the activity to retrieve.</param>
            <returns>The requested DocumentActivity, or null if not found.</returns>
        </member>
        <member name="M:ADMS.API.Services.AdmsRepository.GetDocumentAuditsAsync(System.Guid)">
            <summary>
            Retrieves document audit records for a specified document, returning appropriate error responses.
            </summary>
            <param name="documentId">The ID of the document to retrieve audits for.</param>
            <returns>
            <para><see cref="T:Microsoft.AspNetCore.Mvc.OkObjectResult"/> with a list of document audit records if successful.</para>
            <para><see cref="T:Microsoft.AspNetCore.Mvc.BadRequestObjectResult"/> if the documentId is invalid.</para>
            <para><see cref="T:Microsoft.AspNetCore.Mvc.NotFoundObjectResult"/> if the document does not exist.</para>
            <para><see cref="T:Microsoft.AspNetCore.Mvc.ObjectResult"/> with status code 500 if an unexpected error occurs.</para>
            </returns>
        </member>
        <member name="M:ADMS.API.Services.AdmsRepository.GetDocumentActivityAuditsAsync(System.Guid,ADMS.API.ResourceParameters.DocumentAuditsResourceParameters)">
            <summary>
            Retrieves a paginated list of document activity audit records (create, save, delete, restore, etc.) for a specified document,
            returning appropriate error responses for all error conditions.
            </summary>
            <param name="documentId">The ID of the document to retrieve audits for.</param>
            <param name="resourceParameters">Pagination and sorting information.</param>
            <returns>
            <para><see cref="T:Microsoft.AspNetCore.Mvc.OkObjectResult"/> with a paged list of document activity audit records if successful.</para>
            <para><see cref="T:Microsoft.AspNetCore.Mvc.BadRequestObjectResult"/> if the documentId or resource parameters are invalid.</para>
            <para><see cref="T:Microsoft.AspNetCore.Mvc.NotFoundObjectResult"/> if the document does not exist.</para>
            <para><see cref="T:Microsoft.AspNetCore.Mvc.ObjectResult"/> with status code 500 if an unexpected error occurs.</para>
            </returns>
        </member>
        <member name="M:ADMS.API.Services.AdmsRepository.GetPaginatedDocumentMoveFromAuditsAsync(System.Guid,ADMS.API.ResourceParameters.DocumentAuditsResourceParameters)">
            <summary>
            Retrieves a paginated list of "move/copy FROM" audit records for a specified document,
            returning appropriate error responses for all error conditions.
            </summary>
            <param name="documentId">The ID of the document to retrieve move/copy FROM audits for.</param>
            <param name="resourceParameters">Pagination and sorting information.</param>
            <returns>
            <para>A paged list of move/copy FROM audit records if successful.</para>
            <para><see cref="T:Microsoft.AspNetCore.Mvc.BadRequestObjectResult"/> if the input is invalid.</para>
            <para><see cref="T:Microsoft.AspNetCore.Mvc.NotFoundObjectResult"/> if the document does not exist.</para>
            <para><see cref="T:Microsoft.AspNetCore.Mvc.ObjectResult"/> with status code 500 if an unexpected error occurs.</para>
            </returns>
        </member>
        <member name="M:ADMS.API.Services.AdmsRepository.GetPaginatedDocumentMoveToAuditsAsync(System.Guid,ADMS.API.ResourceParameters.DocumentAuditsResourceParameters)">
            <summary>
            Retrieves a paginated list of "move/copy TO" audit records for a specified document,
            returning appropriate error responses for all error conditions.
            </summary>
            <param name="documentId">The ID of the document to retrieve move/copy TO audits for.</param>
            <param name="resourceParameters">Pagination and sorting information.</param>
            <returns>
            <para>A paged list of move/copy TO audit records if successful.</para>
            <para><see cref="T:Microsoft.AspNetCore.Mvc.BadRequestObjectResult"/> if the input is invalid.</para>
            <para><see cref="T:Microsoft.AspNetCore.Mvc.NotFoundObjectResult"/> if the document does not exist.</para>
            <para><see cref="T:Microsoft.AspNetCore.Mvc.ObjectResult"/> with status code 500 if an unexpected error occurs.</para>
            </returns>
        </member>
        <member name="M:ADMS.API.Services.AdmsRepository.AddMatterAsync(ADMS.API.Models.MatterForCreationDto)">
            <summary>
            Adds a new matter to the repository and logs the creation as an audit activity.
            Returns appropriate error responses for all error conditions.
            </summary>
            <param name="matter">The matter to be added.</param>
            <returns>
            <para><see cref="T:Microsoft.AspNetCore.Mvc.OkObjectResult"/> with the created matter if successful.</para>
            <para><see cref="T:Microsoft.AspNetCore.Mvc.BadRequestObjectResult"/> if the input is invalid.</para>
            <para><see cref="T:Microsoft.AspNetCore.Mvc.ConflictObjectResult"/> if a matter with the same description already exists.</para>
            <para><see cref="T:Microsoft.AspNetCore.Mvc.ObjectResult"/> with status code 500 if an unexpected error occurs.</para>
            </returns>
        </member>
        <member name="M:ADMS.API.Services.AdmsRepository.MatterExistsAsync(System.Guid)">
            <summary>
            Checks if a matter exists in the database, using centralized validation and consistent logging.
            Returns appropriate error responses for all error conditions.
            </summary>
            <param name="matterId">The ID of the matter to check.</param>
            <returns>
            <para><see cref="T:Microsoft.AspNetCore.Mvc.OkObjectResult"/> with true if the matter exists, false otherwise.</para>
            <para><see cref="T:Microsoft.AspNetCore.Mvc.BadRequestObjectResult"/> if the input is invalid.</para>
            <para><see cref="T:Microsoft.AspNetCore.Mvc.ObjectResult"/> with status code 500 if an unexpected error occurs.</para>
            </returns>
        </member>
        <member name="M:ADMS.API.Services.AdmsRepository.MatterNameExistsAsync(System.String)">
            <summary>
            Checks if a matter with the specified name exists in the database, using centralized validation and consistent logging.
            Returns appropriate error responses for all error conditions.
            </summary>
            <param name="matterName">The name of the matter to check.</param>
            <returns>
            <para><see cref="T:Microsoft.AspNetCore.Mvc.OkObjectResult"/> with true if a matter with the specified name exists, false otherwise.</para>
            <para><see cref="T:Microsoft.AspNetCore.Mvc.BadRequestObjectResult"/> if the input is invalid.</para>
            <para><see cref="T:Microsoft.AspNetCore.Mvc.ObjectResult"/> with status code 500 if an unexpected error occurs.</para>
            </returns>
        </member>
        <member name="M:ADMS.API.Services.AdmsRepository.DeleteMatterAsync(ADMS.API.Models.MatterDto)">
            <summary>
            Deletes a specified matter by marking it as deleted and logs the deletion as an audit activity.
            Returns <c>true</c> if the matter was successfully deleted, <c>false</c> otherwise.
            All error conditions are logged; no exceptions are thrown.
            </summary>
            <param name="matterToDelete">The matter to be deleted.</param>
            <returns>
            <c>true</c> if the matter was successfully deleted; <c>false</c> if validation fails, the matter does not exist, or an error occurs.
            </returns>
        </member>
        <member name="M:ADMS.API.Services.AdmsRepository.GetPaginatedMattersAsync(ADMS.API.ResourceParameters.MattersResourceParameters)">
            <summary>
            Retrieves a paginated list of matters based on the specified resource parameters,
            using centralized validation and consistent logging. Returns an empty paged list if validation fails or an error occurs.
            </summary>
            <param name="resourceParameters">The parameters for pagination, filtering, and sorting.</param>
            <returns>
            A paginated list of matters. If validation fails or an error occurs, returns an empty paged list.
            </returns>
        </member>
        <member name="M:ADMS.API.Services.AdmsRepository.GetMatterAsync(System.Guid,System.Boolean,System.Boolean)">
            <summary>
            Retrieves a matter by its ID, optionally including documents and history, using centralized validation and consistent logging.
            Returns <c>null</c> if the matter does not exist, the ID is invalid, or an error occurs.
            </summary>
            <param name="matterId">The ID of the matter to retrieve.</param>
            <param name="includeDocuments">Whether to include documents in the result.</param>
            <param name="includeHistory">Whether to include history in the result.</param>
            <returns>
            The requested <see cref="T:ADMS.API.Entities.Matter"/>, or <c>null</c> if not found or if an error occurs.
            </returns>
        </member>
        <member name="M:ADMS.API.Services.AdmsRepository.RestoreMatterAsync(System.Guid)">
            <summary>
            Restores a deleted matter by marking it as not deleted and logs the restoration as an audit activity.
            Returns <c>true</c> if the matter was successfully restored; <c>false</c> if validation fails, the matter does not exist, or an error occurs.
            All error conditions are logged; no exceptions are thrown.
            </summary>
            <param name="matterId">The ID of the matter to restore.</param>
            <returns>
            <c>true</c> if the matter was successfully restored; <c>false</c> if validation fails, the matter does not exist, or an error occurs.
            </returns>
        </member>
        <member name="M:ADMS.API.Services.AdmsRepository.UpdateMatterAsync(System.Guid,ADMS.API.Models.MatterForUpdateDto)">
            <summary>
            Updates a specified matter with new data and logs the update as an audit activity.
            Returns the updated <see cref="T:ADMS.API.Entities.Matter"/> if successful; otherwise, returns <c>null</c>.
            All error conditions are logged; no exceptions are thrown.
            </summary>
            <param name="matterId">The ID of the matter to update.</param>
            <param name="matterToUpdate">The updated matter data.</param>
            <returns>
            The updated <see cref="T:ADMS.API.Entities.Matter"/> if the operation succeeds; <c>null</c> if validation fails, the matter does not exist, or an error occurs.
            </returns>
        </member>
        <member name="M:ADMS.API.Services.AdmsRepository.AddRevisionAsync(System.Guid,ADMS.API.Models.RevisionDto)">
            <summary>
            Adds a new revision to a specified document and logs the addition as an audit activity.
            Centralizes all validation using the <see cref="T:ADMS.API.Services.IValidationService"/>.
            Returns <c>null</c> if validation fails or an error occurs.
            </summary>
            <param name="documentId">The ID of the document to add the revision to.</param>
            <param name="revision">The revision to add.</param>
            <returns>The created revision, or <c>null</c> if the operation fails.</returns>
        </member>
        <member name="M:ADMS.API.Services.AdmsRepository.RevisionExistsAsync(System.Guid)">
            <summary>
            Checks if a revision exists in the database, using centralized validation and consistent logging.
            </summary>
            <param name="revisionId">The ID of the revision to check.</param>
            <returns>True if the revision exists, false otherwise.</returns>
        </member>
        <member name="M:ADMS.API.Services.AdmsRepository.DeleteRevisionAsync(ADMS.API.Models.RevisionDto)">
            <summary>
            Deletes a specified revision by marking it as deleted and logs the deletion as an audit activity.
            Centralizes all validation using the <see cref="T:ADMS.API.Services.IValidationService"/>.
            </summary>
            <param name="revision">The revision to be deleted.</param>
            <returns>True if the revision was successfully deleted, false otherwise.</returns>
        </member>
        <member name="M:ADMS.API.Services.AdmsRepository.GetRevisionByIdAsync(System.Guid,System.Boolean)">
            <summary>
            Retrieves a revision by its ID, optionally including its history, using centralized validation and consistent logging.
            </summary>
            <param name="revisionId">The ID of the revision to retrieve.</param>
            <param name="includeHistory">Whether to include history in the result. Default is false.</param>
            <returns>The requested revision, or null if not found.</returns>
        </member>
        <member name="M:ADMS.API.Services.AdmsRepository.GetRevisionsAsync(System.Guid,System.Boolean,System.String)">
            <summary>
            Retrieves a list of revisions for a specified document, optionally including deleted revisions,
            and returns an appropriate error response for all error conditions.
            </summary>
            <param name="documentId">The ID of the document to retrieve revisions for.</param>
            <param name="includeDeleted">Whether to include deleted revisions in the result.</param>
            <param name="orderBy">Optional order by clause.</param>
            <returns>
            <para>
            <see cref="T:Microsoft.AspNetCore.Mvc.OkObjectResult"/> with a queryable list of revisions for the specified document if successful.
            </para>
            <para>
            <see cref="T:Microsoft.AspNetCore.Mvc.BadRequestObjectResult"/> if the documentId is invalid.
            </para>
            <para>
            <see cref="T:Microsoft.AspNetCore.Mvc.NotFoundObjectResult"/> if the document does not exist.
            </para>
            <para>
            <see cref="T:Microsoft.AspNetCore.Mvc.ObjectResult"/> with status code 500 if an unexpected error occurs.
            </para>
            </returns>
            <remarks>
            This method uses centralized validation and consistent logging.
            </remarks>
        </member>
        <member name="M:ADMS.API.Services.AdmsRepository.GetPaginatedRevisionsAsync(System.Guid,ADMS.API.ResourceParameters.RevisionsResourceParameters)">
            <summary>
            Retrieves a paginated list of revisions for a specified document,
            returning appropriate HTTP responses for all error conditions.
            </summary>
            <param name="documentId">The ID of the document containing the revisions.</param>
            <param name="resourceParameters">Parameters for pagination and sorting.</param>
            <returns>
            <para>
            <see cref="T:Microsoft.AspNetCore.Mvc.OkObjectResult"/> with a paginated list of revisions if successful.
            </para>
            <para>
            <see cref="T:Microsoft.AspNetCore.Mvc.BadRequestObjectResult"/> if the input is invalid.
            </para>
            <para>
            <see cref="T:Microsoft.AspNetCore.Mvc.NotFoundObjectResult"/> if the document does not exist.
            </para>
            <para>
            <see cref="T:Microsoft.AspNetCore.Mvc.ObjectResult"/> with status code 500 if an unexpected error occurs.
            </para>
            </returns>
            <remarks>
            This method uses centralized validation and consistent logging.
            </remarks>
        </member>
        <member name="T:ADMS.API.Services.BatchEntityValidator">
            <summary>
            Enterprise-grade batch entity validation service providing efficient multi-entity verification.
            </summary>
            <remarks>
            This class provides comprehensive batch validation functionality including:
            - High-performance batch entity existence checking across multiple types
            - Optimized database queries using IN clauses and parallel execution
            - Intelligent caching with configurable expiration policies
            - Real-time performance metrics and health monitoring
            - Comprehensive error handling and detailed diagnostic information
            </remarks>
        </member>
        <member name="M:ADMS.API.Services.BatchEntityValidator.#ctor(ADMS.API.DbContexts.AdmsContext,Microsoft.Extensions.Logging.ILogger{ADMS.API.Services.BatchEntityValidator},Microsoft.Extensions.Caching.Memory.IMemoryCache,Microsoft.Extensions.Options.IOptions{ADMS.API.Services.BatchValidationOptions})">
            <summary>
            Initializes a new instance of the BatchEntityValidator class.
            </summary>
            <param name="context">The database context for entity operations</param>
            <param name="logger">The logger for diagnostic information</param>
            <param name="cache">The memory cache for performance optimization</param>
            <param name="options">The configuration options for batch validation</param>
        </member>
        <member name="M:ADMS.API.Services.BatchEntityValidator.ValidateEntitiesExistAsync(System.Collections.Generic.IEnumerable{System.Guid},System.Collections.Generic.IEnumerable{System.Guid},System.Collections.Generic.IEnumerable{System.Guid},System.Threading.CancellationToken)">
            <inheritdoc />
        </member>
        <member name="M:ADMS.API.Services.BatchEntityValidator.ValidateRelationshipsAsync(System.Collections.Generic.IEnumerable{System.ValueTuple{System.Guid,System.Guid}},System.Collections.Generic.IEnumerable{System.ValueTuple{System.Guid,System.Guid}},System.Threading.CancellationToken)">
            <inheritdoc />
        </member>
        <member name="M:ADMS.API.Services.BatchEntityValidator.ValidateComprehensiveAsync(ADMS.API.Services.ComprehensiveValidationRequest,System.Threading.CancellationToken)">
            <inheritdoc />
        </member>
        <member name="M:ADMS.API.Services.BatchEntityValidator.ValidateFileNamesAsync(System.Collections.Generic.IEnumerable{ADMS.API.Services.FileNameValidationRequest},System.Threading.CancellationToken)">
            <inheritdoc />
        </member>
        <member name="M:ADMS.API.Services.BatchEntityValidator.ValidateBulkRequestAsync(ADMS.API.Services.BulkValidationRequest,System.Threading.CancellationToken)">
            <inheritdoc />
        </member>
        <member name="M:ADMS.API.Services.BatchEntityValidator.GetPerformanceMetrics">
            <inheritdoc />
        </member>
        <member name="M:ADMS.API.Services.BatchEntityValidator.CheckHealthAsync(System.Threading.CancellationToken)">
            <inheritdoc />
        </member>
        <member name="M:ADMS.API.Services.BatchEntityValidator.GetRealTimeStatistics">
            <inheritdoc />
        </member>
        <member name="M:ADMS.API.Services.BatchEntityValidator.GetConfiguration">
            <inheritdoc />
        </member>
        <member name="M:ADMS.API.Services.BatchEntityValidator.ClearCache(System.String)">
            <inheritdoc />
        </member>
        <member name="M:ADMS.API.Services.BatchEntityValidator.ValidateConfiguration">
            <inheritdoc />
        </member>
        <member name="M:ADMS.API.Services.BatchEntityValidator.Dispose">
            <summary>
            Disposes of resources used by the batch entity validator.
            </summary>
        </member>
        <member name="M:ADMS.API.Services.BatchEntityValidator.ThrowIfDisposed">
            <summary>
            Throws ObjectDisposedException if the service has been disposed.
            </summary>
        </member>
        <member name="M:ADMS.API.Services.BatchEntityValidator.ValidateConfigurationInternal">
            <summary>
            Validates configuration settings during initialization.
            </summary>
        </member>
        <member name="M:ADMS.API.Services.BatchEntityValidator.GenerateOperationId">
            <summary>
            Generates a unique operation identifier for tracking.
            </summary>
        </member>
        <member name="M:ADMS.API.Services.BatchEntityValidator.FilterValidIds(System.Collections.Generic.IEnumerable{System.Guid})">
            <summary>
            Filters and validates entity IDs, removing empty GUIDs and duplicates.
            </summary>
        </member>
        <member name="M:ADMS.API.Services.BatchEntityValidator.ValidateBatchSize(System.Int32,System.String)">
            <summary>
            Validates that the entity count doesn't exceed the maximum batch size.
            </summary>
        </member>
        <member name="M:ADMS.API.Services.BatchEntityValidator.ShouldUseParallelProcessing(System.Int32)">
            <summary>
            Determines whether parallel processing should be used based on entity count.
            </summary>
        </member>
        <member name="M:ADMS.API.Services.BatchEntityValidator.GenerateBatchCacheKey(System.Collections.Generic.List{System.Guid},System.Collections.Generic.List{System.Guid},System.Collections.Generic.List{System.Guid})">
            <summary>
            Generates a cache key for batch validation results.
            </summary>
        </member>
        <member name="M:ADMS.API.Services.BatchEntityValidator.CacheResultAsync(System.Collections.Generic.List{System.Guid},System.Collections.Generic.List{System.Guid},System.Collections.Generic.List{System.Guid},ADMS.API.Services.BatchEntityValidationResult,System.Int32)">
            <summary>
            Caches the batch validation result.
            </summary>
        </member>
        <member name="M:ADMS.API.Services.BatchEntityValidator.ValidateEntitiesParallelAsync(System.Collections.Generic.List{System.Guid},System.Collections.Generic.List{System.Guid},System.Collections.Generic.List{System.Guid},System.Threading.CancellationToken)">
            <summary>
            Validates entities using parallel processing.
            </summary>
        </member>
        <member name="M:ADMS.API.Services.BatchEntityValidator.ValidateEntitiesSequentialAsync(System.Collections.Generic.List{System.Guid},System.Collections.Generic.List{System.Guid},System.Collections.Generic.List{System.Guid},System.Threading.CancellationToken)">
            <summary>
            Validates entities using sequential processing.
            </summary>
        </member>
        <member name="M:ADMS.API.Services.BatchEntityValidator.ValidateMattersBatchAsync(System.Collections.Generic.List{System.Guid},System.Threading.CancellationToken)">
            <summary>
            Validates matters in batch.
            </summary>
        </member>
        <member name="M:ADMS.API.Services.BatchEntityValidator.ValidateDocumentsBatchAsync(System.Collections.Generic.List{System.Guid},System.Threading.CancellationToken)">
            <summary>
            Validates documents in batch.
            </summary>
        </member>
        <member name="M:ADMS.API.Services.BatchEntityValidator.ValidateRevisionsBatchAsync(System.Collections.Generic.List{System.Guid},System.Threading.CancellationToken)">
            <summary>
            Validates revisions in batch.
            </summary>
        </member>
        <member name="M:ADMS.API.Services.BatchEntityValidator.ValidateDocumentMatterRelationshipsAsync(System.Collections.Generic.List{System.ValueTuple{System.Guid,System.Guid}},System.Threading.CancellationToken)">
            <summary>
            Validates document-matter relationships.
            </summary>
        </member>
        <member name="M:ADMS.API.Services.BatchEntityValidator.ValidateRevisionDocumentRelationshipsAsync(System.Collections.Generic.List{System.ValueTuple{System.Guid,System.Guid}},System.Threading.CancellationToken)">
            <summary>
            Validates revision-document relationships.
            </summary>
        </member>
        <member name="M:ADMS.API.Services.BatchEntityValidator.TestDatabaseConnectivityAsync(System.Threading.CancellationToken)">
            <summary>
            Tests database connectivity for health checks.
            </summary>
        </member>
        <member name="M:ADMS.API.Services.BatchEntityValidator.UpdateRealTimeStatistics(System.String,System.Object)">
            <summary>
            Updates real-time statistics with thread-safe operations.
            </summary>
        </member>
        <member name="M:ADMS.API.Services.BatchEntityValidator.InitializeRealTimeStatistics">
            <summary>
            Initializes real-time statistics with baseline values.
            </summary>
        </member>
        <member name="M:ADMS.API.Services.BatchEntityValidator.CreateEntityTypeBreakdown(System.Collections.Generic.List{System.Collections.Generic.KeyValuePair{System.String,ADMS.API.Services.Common.OperationMetrics}})">
            <summary>
            Creates entity type breakdown for performance metrics.
            </summary>
        </member>
        <member name="M:ADMS.API.Services.BatchEntityValidator.CreateBatchSizeDistribution">
            <summary>
            Creates batch size distribution for metrics.
            </summary>
        </member>
        <member name="M:ADMS.API.Services.BatchEntityValidator.CalculateCurrentThroughput">
            <summary>
            Calculates current throughput.
            </summary>
        </member>
        <member name="M:ADMS.API.Services.BatchEntityValidator.CalculateCacheHitRate">
            <summary>
            Calculates cache hit rate.
            </summary>
        </member>
        <member name="M:ADMS.API.Services.BatchEntityValidator.ValidateFileNameRequests(System.Collections.Generic.List{ADMS.API.Services.FileNameValidationRequest})">
            <summary>
            Validates file name requests and separates valid from invalid ones.
            </summary>
        </member>
        <member name="M:ADMS.API.Services.BatchEntityValidator.CreateValidationMetadata(ADMS.API.Services.ComprehensiveValidationRequest,System.TimeSpan,ADMS.API.Services.BatchEntityValidationResult,ADMS.API.Services.BatchRelationshipValidationResult)">
            <summary>
            Creates validation metadata for comprehensive validation results.
            </summary>
        </member>
        <member name="T:ADMS.API.Services.BatchValidationOptions">
            <summary>
            Configuration options for batch validation operations.
            </summary>
        </member>
        <member name="P:ADMS.API.Services.BatchValidationOptions.MaxBatchSize">
            <summary>
            Gets or sets the maximum number of entities allowed in a single batch operation.
            Default value is 1000.
            </summary>
        </member>
        <member name="P:ADMS.API.Services.BatchValidationOptions.BatchTimeoutSeconds">
            <summary>
            Gets or sets the timeout in seconds for batch validation operations.
            Default value is 30 seconds.
            </summary>
        </member>
        <member name="P:ADMS.API.Services.BatchValidationOptions.EnableParallelProcessing">
            <summary>
            Gets or sets whether parallel processing is enabled for batch operations.
            Default value is true.
            </summary>
        </member>
        <member name="P:ADMS.API.Services.BatchValidationOptions.EnableCaching">
            <summary>
            Gets or sets whether caching is enabled for validation results.
            Default value is true.
            </summary>
        </member>
        <member name="P:ADMS.API.Services.BatchValidationOptions.CacheExpirationMinutes">
            <summary>
            Gets or sets the cache expiration time in minutes.
            Default value is 15 minutes.
            </summary>
        </member>
        <member name="M:ADMS.API.Services.BatchValidationOptions.Validate">
            <summary>
            Validates the configuration options and returns any validation errors.
            </summary>
            <returns>A collection of validation error messages.</returns>
        </member>
        <member name="T:ADMS.API.Services.BatchEntityValidationResult">
            <summary>
            Represents the result of a batch entity validation operation.
            </summary>
        </member>
        <member name="P:ADMS.API.Services.BatchEntityValidationResult.AllEntitiesExist">
            <summary>
            Gets whether all entities in the batch exist.
            </summary>
        </member>
        <member name="P:ADMS.API.Services.BatchEntityValidationResult.ExistingMatters">
            <summary>
            Gets the collection of existing matter IDs.
            </summary>
        </member>
        <member name="P:ADMS.API.Services.BatchEntityValidationResult.MissingMatters">
            <summary>
            Gets the collection of missing matter IDs.
            </summary>
        </member>
        <member name="P:ADMS.API.Services.BatchEntityValidationResult.ExistingDocuments">
            <summary>
            Gets the collection of existing document IDs.
            </summary>
        </member>
        <member name="P:ADMS.API.Services.BatchEntityValidationResult.MissingDocuments">
            <summary>
            Gets the collection of missing document IDs.
            </summary>
        </member>
        <member name="P:ADMS.API.Services.BatchEntityValidationResult.ExistingRevisions">
            <summary>
            Gets the collection of existing revision IDs.
            </summary>
        </member>
        <member name="P:ADMS.API.Services.BatchEntityValidationResult.MissingRevisions">
            <summary>
            Gets the collection of missing revision IDs.
            </summary>
        </member>
        <member name="P:ADMS.API.Services.BatchEntityValidationResult.Metadata">
            <summary>
            Gets optional metadata about the validation operation.
            </summary>
        </member>
        <member name="M:ADMS.API.Services.BatchEntityValidationResult.GetTotalExistingCount">
            <summary>
            Gets the total number of existing entities across all types.
            </summary>
        </member>
        <member name="M:ADMS.API.Services.BatchEntityValidationResult.GetTotalMissingCount">
            <summary>
            Gets the total number of missing entities across all types.
            </summary>
        </member>
        <member name="M:ADMS.API.Services.BatchEntityValidationResult.GetMissingEntitiesDescription">
            <summary>
            Gets a human-readable description of missing entities.
            </summary>
        </member>
        <member name="M:ADMS.API.Services.BatchEntityValidationResult.AllExist(System.Collections.Generic.IEnumerable{System.Guid},System.Collections.Generic.IEnumerable{System.Guid},System.Collections.Generic.IEnumerable{System.Guid})">
            <summary>
            Creates a result indicating all entities exist.
            </summary>
        </member>
        <member name="M:ADMS.API.Services.BatchEntityValidationResult.WithMissingEntities(System.Collections.Generic.IEnumerable{System.Guid},System.Collections.Generic.IEnumerable{System.Guid},System.Collections.Generic.IEnumerable{System.Guid},System.Collections.Generic.IEnumerable{System.Guid},System.Collections.Generic.IEnumerable{System.Guid},System.Collections.Generic.IEnumerable{System.Guid})">
            <summary>
            Creates a result with specified missing entities.
            </summary>
        </member>
        <member name="T:ADMS.API.Services.BatchRelationshipValidationResult">
            <summary>
            Represents the result of a batch relationship validation operation.
            </summary>
        </member>
        <member name="P:ADMS.API.Services.BatchRelationshipValidationResult.AllRelationshipsValid">
            <summary>
            Gets whether all relationships in the batch are valid.
            </summary>
        </member>
        <member name="P:ADMS.API.Services.BatchRelationshipValidationResult.ValidDocumentMatterPairs">
            <summary>
            Gets the collection of valid document-matter relationship pairs.
            </summary>
        </member>
        <member name="P:ADMS.API.Services.BatchRelationshipValidationResult.InvalidDocumentMatterPairs">
            <summary>
            Gets the collection of invalid document-matter relationship pairs.
            </summary>
        </member>
        <member name="P:ADMS.API.Services.BatchRelationshipValidationResult.ValidRevisionDocumentPairs">
            <summary>
            Gets the collection of valid revision-document relationship pairs.
            </summary>
        </member>
        <member name="P:ADMS.API.Services.BatchRelationshipValidationResult.InvalidRevisionDocumentPairs">
            <summary>
            Gets the collection of invalid revision-document relationship pairs.
            </summary>
        </member>
        <member name="M:ADMS.API.Services.BatchRelationshipValidationResult.GetTotalValidCount">
            <summary>
            Gets the total number of valid relationships across all types.
            </summary>
        </member>
        <member name="M:ADMS.API.Services.BatchRelationshipValidationResult.GetTotalInvalidCount">
            <summary>
            Gets the total number of invalid relationships across all types.
            </summary>
        </member>
        <member name="M:ADMS.API.Services.BatchRelationshipValidationResult.GetInvalidRelationshipsDescription">
            <summary>
            Gets a human-readable description of invalid relationships.
            </summary>
        </member>
        <member name="M:ADMS.API.Services.BatchRelationshipValidationResult.AllValid(System.Collections.Generic.IEnumerable{System.ValueTuple{System.Guid,System.Guid}},System.Collections.Generic.IEnumerable{System.ValueTuple{System.Guid,System.Guid}})">
            <summary>
            Creates a result indicating all relationships are valid.
            </summary>
        </member>
        <member name="M:ADMS.API.Services.BatchRelationshipValidationResult.WithInvalidRelationships(System.Collections.Generic.IEnumerable{System.ValueTuple{System.Guid,System.Guid}},System.Collections.Generic.IEnumerable{System.ValueTuple{System.Guid,System.Guid}},System.Collections.Generic.IEnumerable{System.ValueTuple{System.Guid,System.Guid}},System.Collections.Generic.IEnumerable{System.ValueTuple{System.Guid,System.Guid}})">
            <summary>
            Creates a result with specified invalid relationships.
            </summary>
        </member>
        <member name="T:ADMS.API.Services.ComprehensiveValidationRequest">
            <summary>
            Represents a comprehensive validation request containing entities and relationships to validate.
            </summary>
        </member>
        <member name="P:ADMS.API.Services.ComprehensiveValidationRequest.MatterIds">
            <summary>
            Gets or sets the collection of matter IDs to validate.
            </summary>
        </member>
        <member name="P:ADMS.API.Services.ComprehensiveValidationRequest.DocumentIds">
            <summary>
            Gets or sets the collection of document IDs to validate.
            </summary>
        </member>
        <member name="P:ADMS.API.Services.ComprehensiveValidationRequest.RevisionIds">
            <summary>
            Gets or sets the collection of revision IDs to validate.
            </summary>
        </member>
        <member name="P:ADMS.API.Services.ComprehensiveValidationRequest.DocumentMatterPairs">
            <summary>
            Gets or sets the collection of document-matter relationship pairs to validate.
            </summary>
        </member>
        <member name="P:ADMS.API.Services.ComprehensiveValidationRequest.RevisionDocumentPairs">
            <summary>
            Gets or sets the collection of revision-document relationship pairs to validate.
            </summary>
        </member>
        <member name="P:ADMS.API.Services.ComprehensiveValidationRequest.ValidateRelationships">
            <summary>
            Gets or sets whether relationship validation should be performed.
            </summary>
        </member>
        <member name="P:ADMS.API.Services.ComprehensiveValidationRequest.IncludeMetadata">
            <summary>
            Gets or sets whether detailed metadata should be included in the result.
            </summary>
        </member>
        <member name="P:ADMS.API.Services.ComprehensiveValidationRequest.RequestId">
            <summary>
            Gets or sets an optional request identifier for tracking purposes.
            </summary>
        </member>
        <member name="P:ADMS.API.Services.ComprehensiveValidationRequest.TotalEntityCount">
            <summary>
            Gets the total number of entities to validate.
            </summary>
        </member>
        <member name="P:ADMS.API.Services.ComprehensiveValidationRequest.TotalRelationshipCount">
            <summary>
            Gets the total number of relationships to validate.
            </summary>
        </member>
        <member name="T:ADMS.API.Services.ComprehensiveValidationResult">
            <summary>
            Represents the result of a comprehensive validation operation.
            </summary>
        </member>
        <member name="P:ADMS.API.Services.ComprehensiveValidationResult.IsValid">
            <summary>
            Gets whether the overall validation is valid (all entities exist and all relationships are valid).
            </summary>
        </member>
        <member name="P:ADMS.API.Services.ComprehensiveValidationResult.EntityValidationResult">
            <summary>
            Gets the entity validation result.
            </summary>
        </member>
        <member name="P:ADMS.API.Services.ComprehensiveValidationResult.RelationshipValidationResult">
            <summary>
            Gets the relationship validation result, if relationship validation was performed.
            </summary>
        </member>
        <member name="P:ADMS.API.Services.ComprehensiveValidationResult.OperationId">
            <summary>
            Gets the operation identifier for tracking purposes.
            </summary>
        </member>
        <member name="P:ADMS.API.Services.ComprehensiveValidationResult.Duration">
            <summary>
            Gets the total duration of the validation operation.
            </summary>
        </member>
        <member name="P:ADMS.API.Services.ComprehensiveValidationResult.Metadata">
            <summary>
            Gets optional metadata about the validation operation.
            </summary>
        </member>
        <member name="M:ADMS.API.Services.ComprehensiveValidationResult.GetValidationSummary">
            <summary>
            Gets a comprehensive validation summary.
            </summary>
        </member>
        <member name="T:ADMS.API.Services.FileNameValidationRequest">
            <summary>
            Represents a request to validate file name uniqueness within a matter.
            </summary>
        </member>
        <member name="P:ADMS.API.Services.FileNameValidationRequest.MatterId">
            <summary>
            Gets or sets the matter ID within which to check for file name uniqueness.
            </summary>
        </member>
        <member name="P:ADMS.API.Services.FileNameValidationRequest.FileName">
            <summary>
            Gets or sets the file name to check for uniqueness.
            </summary>
        </member>
        <member name="M:ADMS.API.Services.FileNameValidationRequest.ValidateRequest">
            <summary>
            Validates the request and returns any validation errors.
            </summary>
            <returns>A collection of validation error messages.</returns>
        </member>
        <member name="T:ADMS.API.Services.BatchFileNameValidationResult">
            <summary>
            Represents the result of a batch file name validation operation.
            </summary>
        </member>
        <member name="P:ADMS.API.Services.BatchFileNameValidationResult.HasConflicts">
            <summary>
            Gets whether any file name conflicts were detected.
            </summary>
        </member>
        <member name="P:ADMS.API.Services.BatchFileNameValidationResult.ConflictingFileNames">
            <summary>
            Gets the collection of conflicting file names with details about the conflicts.
            </summary>
        </member>
        <member name="P:ADMS.API.Services.BatchFileNameValidationResult.ValidFileNames">
            <summary>
            Gets the collection of valid file names that do not have conflicts.
            </summary>
        </member>
        <member name="P:ADMS.API.Services.BatchFileNameValidationResult.Metadata">
            <summary>
            Gets optional metadata about the validation operation.
            </summary>
        </member>
        <member name="M:ADMS.API.Services.BatchFileNameValidationResult.GetValidationSummary">
            <summary>
            Gets a validation summary describing the results.
            </summary>
        </member>
        <member name="T:ADMS.API.Services.BulkValidationRequest">
            <summary>
            Represents a bulk validation request with timeout and configuration options.
            </summary>
        </member>
        <member name="P:ADMS.API.Services.BulkValidationRequest.MatterIds">
            <summary>
            Gets or sets the collection of matter IDs to validate.
            </summary>
        </member>
        <member name="P:ADMS.API.Services.BulkValidationRequest.DocumentIds">
            <summary>
            Gets or sets the collection of document IDs to validate.
            </summary>
        </member>
        <member name="P:ADMS.API.Services.BulkValidationRequest.RevisionIds">
            <summary>
            Gets or sets the collection of revision IDs to validate.
            </summary>
        </member>
        <member name="P:ADMS.API.Services.BulkValidationRequest.ValidateRelationships">
            <summary>
            Gets or sets whether relationship validation should be performed.
            </summary>
        </member>
        <member name="P:ADMS.API.Services.BulkValidationRequest.IncludeMetadata">
            <summary>
            Gets or sets whether detailed metadata should be included in the result.
            </summary>
        </member>
        <member name="P:ADMS.API.Services.BulkValidationRequest.TimeoutMilliseconds">
            <summary>
            Gets or sets the timeout in milliseconds for the validation operation.
            </summary>
        </member>
        <member name="P:ADMS.API.Services.BulkValidationRequest.RequestId">
            <summary>
            Gets or sets an optional request identifier for tracking purposes.
            </summary>
        </member>
        <member name="P:ADMS.API.Services.BulkValidationRequest.TotalEntityCount">
            <summary>
            Gets the total number of entities to validate.
            </summary>
        </member>
        <member name="M:ADMS.API.Services.BulkValidationRequest.ValidateRequest">
            <summary>
            Validates the request and returns any validation errors.
            </summary>
            <returns>A collection of validation error messages.</returns>
        </member>
        <member name="T:ADMS.API.Services.BatchValidationMetrics">
            <summary>
            Represents batch validation performance metrics.
            </summary>
        </member>
        <member name="P:ADMS.API.Services.BatchValidationMetrics.TotalBatchOperations">
            <summary>
            Gets the total number of batch operations performed.
            </summary>
        </member>
        <member name="P:ADMS.API.Services.BatchValidationMetrics.AverageBatchSize">
            <summary>
            Gets the average batch size across all operations.
            </summary>
        </member>
        <member name="P:ADMS.API.Services.BatchValidationMetrics.AverageBatchProcessingTime">
            <summary>
            Gets the average processing time for batch operations.
            </summary>
        </member>
        <member name="P:ADMS.API.Services.BatchValidationMetrics.BatchSuccessRate">
            <summary>
            Gets the success rate for batch operations (0.0 to 1.0).
            </summary>
        </member>
        <member name="P:ADMS.API.Services.BatchValidationMetrics.TotalEntitiesProcessed">
            <summary>
            Gets the total number of entities processed across all batch operations.
            </summary>
        </member>
        <member name="P:ADMS.API.Services.BatchValidationMetrics.EntitiesPerSecond">
            <summary>
            Gets the average number of entities processed per second.
            </summary>
        </member>
        <member name="P:ADMS.API.Services.BatchValidationMetrics.BatchSizeDistribution">
            <summary>
            Gets the distribution of batch sizes.
            </summary>
        </member>
        <member name="P:ADMS.API.Services.BatchValidationMetrics.EntityTypeBreakdown">
            <summary>
            Gets performance metrics broken down by entity type.
            </summary>
        </member>
        <member name="P:ADMS.API.Services.BatchValidationMetrics.AdditionalMetrics">
            <summary>
            Gets additional operational metrics.
            </summary>
        </member>
        <member name="M:ADMS.API.Services.BatchValidationMetrics.Create(System.Int32,System.Double,System.TimeSpan,System.Double)">
            <summary>
            Creates a basic metrics instance for error scenarios.
            </summary>
        </member>
        <member name="T:ADMS.API.Services.EntityTypeMetrics">
            <summary>
            Represents performance metrics for a specific entity type.
            </summary>
        </member>
        <member name="T:ADMS.API.Services.BatchValidationHealthResult">
            <summary>
            Represents the result of a batch validation health check.
            </summary>
        </member>
        <member name="P:ADMS.API.Services.BatchValidationHealthResult.IsHealthy">
            <summary>
            Gets whether the service is healthy.
            </summary>
        </member>
        <member name="P:ADMS.API.Services.BatchValidationHealthResult.HealthScore">
            <summary>
            Gets the health score (0.0 to 1.0).
            </summary>
        </member>
        <member name="P:ADMS.API.Services.BatchValidationHealthResult.Issues">
            <summary>
            Gets the collection of health issues detected.
            </summary>
        </member>
        <member name="P:ADMS.API.Services.BatchValidationHealthResult.LastSuccessfulOperation">
            <summary>
            Gets the timestamp of the last successful operation.
            </summary>
        </member>
        <member name="P:ADMS.API.Services.BatchValidationHealthResult.Metadata">
            <summary>
            Gets additional health check metadata.
            </summary>
        </member>
        <member name="M:ADMS.API.Services.BatchValidationHealthResult.GetHealthStatus">
            <summary>
            Gets a readable health status description.
            </summary>
        </member>
        <member name="T:ADMS.API.Services.ClamAvVirusScanner">
            <summary>
            Enterprise-grade ClamAV virus scanner implementation providing comprehensive malware detection capabilities
            through integration with ClamAV antivirus engine. This implementation offers robust virus scanning
            with extensive error handling, performance monitoring, and operational resilience features.
            </summary>
            <remarks>
            <para>This class provides a production-ready implementation of virus scanning services including:</para>
            
            <para><strong>Core Security Features:</strong></para>
            <list type="bullet">
            <item>Real-time virus detection using ClamAV signature-based scanning engine</item>
            <item>Comprehensive malware detection including viruses, trojans, and suspicious content</item>
            <item>Stream-based scanning for memory-efficient processing of large files</item>
            <item>Secure handling of potentially malicious content with proper isolation</item>
            <item>Integration with up-to-date virus definitions from ClamAV database</item>
            </list>
            
            <para><strong>Performance and Reliability:</strong></para>
            <list type="bullet">
            <item>Asynchronous operations for non-blocking file processing workflows</item>
            <item>Configurable timeouts and connection management for responsive scanning</item>
            <item>Automatic retry logic with exponential backoff for transient failures</item>
            <item>Connection pooling and resource optimization for high-throughput scenarios</item>
            <item>Comprehensive health monitoring and diagnostic capabilities</item>
            </list>
            
            <para><strong>Enterprise Features:</strong></para>
            <list type="bullet">
            <item>Extensive logging and audit trail for compliance and security monitoring</item>
            <item>Configurable scanning parameters and operational thresholds</item>
            <item>Integration with application performance monitoring and alerting systems</item>
            <item>Support for multiple ClamAV server configurations and failover scenarios</item>
            <item>Detailed error handling with actionable diagnostic information</item>
            </list>
            
            <para><strong>Configuration Requirements:</strong></para>
            <list type="bullet">
            <item>ClamAV daemon (clamd) must be running and accessible on configured host/port</item>
            <item>Virus definitions should be regularly updated through freshclam or similar mechanism</item>
            <item>Network connectivity and firewall configuration for scanner communication</item>
            <item>Sufficient system resources for concurrent scanning operations</item>
            <item>Proper security context and permissions for file access and network communication</item>
            </list>
            
            <para><strong>Security Considerations:</strong></para>
            <list type="bullet">
            <item>All potentially infected content is handled in isolated scanning context</item>
            <item>File streams are properly reset and managed during scanning operations</item>
            <item>Comprehensive audit logging of all scanning activities for compliance</item>
            <item>Integration with incident response procedures for threat detection scenarios</item>
            <item>Secure communication with ClamAV server using configured protocols</item>
            </list>
            </remarks>
            <example>
            <code>
            // Dependency injection configuration
            services.Configure&lt;ClamAvScannerOptions&gt;(configuration.GetSection("ClamAV"));
            services.AddScoped&lt;IVirusScanner, ClamAvVirusScanner&gt;();
            
            // Usage in file upload scenario
            public class FileUploadController : ControllerBase
            {
                private readonly IVirusScanner _virusScanner;
                
                public FileUploadController(IVirusScanner virusScanner)
                {
                    _virusScanner = virusScanner;
                }
                
                [HttpPost("upload")]
                public async Task&lt;IActionResult&gt; UploadFile(IFormFile file, CancellationToken cancellationToken)
                {
                    using var stream = file.OpenReadStream();
                    var scanResult = await _virusScanner.ScanFileForVirusesAsync(stream, cancellationToken);
                    
                    if (!scanResult.IsClean)
                    {
                        return BadRequest($"File rejected: {scanResult.ThreatDetails?.ThreatName}");
                    }
                    
                    // Continue with file processing
                    return Ok("File uploaded successfully");
                }
            }
            </code>
            </example>
        </member>
        <member name="M:ADMS.API.Services.ClamAvVirusScanner.#ctor(Microsoft.Extensions.Logging.ILogger{ADMS.API.Services.ClamAvVirusScanner},Microsoft.Extensions.Options.IOptions{ADMS.API.Services.ClamAvScannerOptions})">
            <summary>
            Initializes a new instance of the <see cref="T:ADMS.API.Services.ClamAvVirusScanner"/> class with comprehensive
            configuration and operational monitoring capabilities.
            </summary>
            <param name="logger">
            The logger instance for comprehensive diagnostic and operational information recording.
            Used throughout the scanner lifecycle for security events, performance metrics, and error conditions.
            </param>
            <param name="options">
            The configuration options for ClamAV scanner behavior including server connection details,
            timeout settings, retry policies, and operational parameters.
            </param>
            <exception cref="T:System.ArgumentNullException">
            Thrown when logger or options parameters are null, indicating dependency injection configuration issues.
            </exception>
            <exception cref="T:System.ArgumentException">
            Thrown when scanner configuration validation fails due to invalid server settings or operational parameters.
            </exception>
            <remarks>
            <para>This constructor performs comprehensive initialization including:</para>
            
            <para><strong>Configuration Validation:</strong></para>
            <list type="bullet">
            <item>Validates ClamAV server connection parameters for accessibility and correctness</item>
            <item>Ensures timeout and retry configuration values are within reasonable operational ranges</item>
            <item>Verifies system resource allocation for concurrent scanning operations</item>
            <item>Establishes logging context for all subsequent scanner operations</item>
            </list>
            
            <para><strong>Resource Management Setup:</strong></para>
            <list type="bullet">
            <item>Initializes connection pooling and concurrency control mechanisms</item>
            <item>Establishes health monitoring and diagnostic capabilities</item>
            <item>Sets up performance tracking and operational metrics collection</item>
            <item>Prepares error handling and recovery mechanisms for production resilience</item>
            </list>
            </remarks>
        </member>
        <member name="M:ADMS.API.Services.ClamAvVirusScanner.ScanFileForVirusesAsync(System.IO.Stream,System.Threading.CancellationToken)">
            <summary>
            Performs comprehensive virus scanning of the provided file stream with detailed result information.
            This method provides enterprise-grade malware detection with extensive error handling, retry logic,
            and operational monitoring for production environments.
            </summary>
            <param name="fileStream">
            The file stream to scan for viruses and malicious content. Must be a readable stream containing 
            the file data to be analyzed. The stream position will be reset to the beginning before scanning.
            Stream must remain open during the entire scanning operation.
            </param>
            <param name="cancellationToken">
            Optional cancellation token to allow cancellation of long-running scan operations.
            Implementations respect cancellation requests to provide responsive user experience.
            Default value allows the operation to run to completion without cancellation.
            </param>
            <returns>
            A task that represents the asynchronous scanning operation. The task result contains a 
            VirusScanResult with comprehensive information about whether the file is clean or contains 
            malicious content, detailed threat information including threat names and types, scanning 
            metadata including duration and scanner information, recommended actions for threat mitigation 
            if applicable, and additional context for logging and compliance reporting.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            Thrown when fileStream parameter is null, indicating invalid input parameters.
            </exception>
            <exception cref="T:System.ArgumentException">
            Thrown when fileStream is not readable or is in an invalid state for scanning operations.
            </exception>
            <exception cref="T:System.OperationCanceledException">
            Thrown when the operation is canceled via the cancellation token during scanning.
            </exception>
            <exception cref="T:System.ObjectDisposedException">
            Thrown when the scanner instance has been disposed and is no longer available for operations.
            </exception>
            <remarks>
            <para>This method provides comprehensive virus scanning including:</para>
            
            <para><strong>Scanning Capabilities:</strong></para>
            <list type="bullet">
            <item>Real-time virus detection using up-to-date ClamAV threat definitions</item>
            <item>Multi-layered analysis including signature-based detection</item>
            <item>Support for various file formats and content types</item>
            <item>Detection of viruses, trojans, malware, spyware, and suspicious content</item>
            <item>Integration with ClamAV threat intelligence for emerging threats</item>
            </list>
            
            <para><strong>Performance Characteristics:</strong></para>
            <list type="bullet">
            <item>Asynchronous operation for non-blocking execution</item>
            <item>Memory-efficient stream processing for large files</item>
            <item>Configurable timeout and resource management</item>
            <item>Cancellation token support for responsive cancellation</item>
            <item>Automatic retry logic with exponential backoff for resilience</item>
            </list>
            
            <para><strong>Security Features:</strong></para>
            <list type="bullet">
            <item>Secure handling of potentially malicious content during scanning</item>
            <item>Proper isolation of scanning processes from system resources</item>
            <item>Comprehensive threat classification and severity assessment</item>
            <item>Integration with security monitoring and incident response</item>
            <item>Audit logging of all scanning activities for compliance</item>
            </list>
            </remarks>
            <example>
            <code>
            // Example usage in file upload scenario
            public async Task&lt;IActionResult&gt; UploadFile(IFormFile file, CancellationToken cancellationToken)
            {
                using var stream = file.OpenReadStream();
                var scanResult = await _virusScanner.ScanFileForVirusesAsync(stream, cancellationToken);
                
                if (!scanResult.IsClean)
                {
                    _logger.LogWarning("Virus detected: {ThreatName}", scanResult.ThreatDetails?.ThreatName);
                    return BadRequest($"File rejected: {scanResult.ThreatDetails?.ThreatName}");
                }
                
                return Ok("File uploaded successfully");
            }
            </code>
            </example>
        </member>
        <member name="M:ADMS.API.Services.ClamAvVirusScanner.CheckHealthAsync(System.Threading.CancellationToken)">
            <summary>
            Validates whether the ClamAV virus scanner is properly configured and operational.
            This method performs comprehensive health checking including service availability,
            virus definition currency, scanning functionality, and performance metrics.
            </summary>
            <param name="cancellationToken">
            Optional cancellation token for the health check operation to allow responsive cancellation
            of potentially long-running connectivity and functionality tests.
            </param>
            <returns>
            A task that represents the asynchronous health check operation. The task result contains
            a ScannerHealthResult with comprehensive information about scanner availability and 
            operational status, virus definition version and last update timestamp, performance 
            metrics and operational statistics, configuration validation and system requirements,
            and recommendations for optimization or maintenance.
            </returns>
            <exception cref="T:System.OperationCanceledException">
            Thrown when the health check operation is cancelled via the cancellation token.
            </exception>
            <remarks>
            <para>This method provides comprehensive health checking including:</para>
            
            <para><strong>Health Check Capabilities:</strong></para>
            <list type="bullet">
            <item>Verification of ClamAV daemon service availability and responsiveness</item>
            <item>Validation of virus definition currency and update status</item>
            <item>Assessment of scanning functionality using EICAR test signature</item>
            <item>Performance metrics including response time and connectivity status</item>
            <item>Configuration validation and compatibility checking</item>
            </list>
            
            <para><strong>Operational Monitoring:</strong></para>
            <list type="bullet">
            <item>Real-time status of ClamAV scanning engine and detection capabilities</item>
            <item>Network connectivity and communication channel validation</item>
            <item>Virus definition freshness and update mechanism status</item>
            <item>Service responsiveness and performance characteristics</item>
            <item>Error detection and diagnostic information for troubleshooting</item>
            </list>
            
            <para><strong>Caching and Performance:</strong></para>
            <list type="bullet">
            <item>Results are cached to avoid excessive health check overhead</item>
            <item>Configurable cache duration balances freshness with performance</item>
            <item>Non-invasive testing minimizes impact on scanning performance</item>
            <item>Fast response time suitable for operational monitoring systems</item>
            </list>
            </remarks>
            <example>
            <code>
            // Health check implementation in ASP.NET Core
            [HttpGet("health")]
            public async Task&lt;IActionResult&gt; HealthCheck(CancellationToken cancellationToken)
            {
                try
                {
                    var healthResult = await _virusScanner.CheckHealthAsync(cancellationToken);
                    
                    if (healthResult.OverallHealth == HealthStatus.Healthy)
                    {
                        return Ok(new {
                            Status = "Healthy",
                            Available = healthResult.IsAvailable,
                            DefinitionVersion = healthResult.DefinitionVersion,
                            LastUpdate = healthResult.LastDefinitionUpdate,
                            SuccessRate = healthResult.SuccessRate
                        });
                    }
                    else
                    {
                        return StatusCode(503, new {
                            Status = healthResult.OverallHealth.ToString(),
                            Error = healthResult.ErrorMessage
                        });
                    }
                }
                catch (Exception ex)
                {
                    return StatusCode(503, new { Status = "Unhealthy", Error = ex.Message });
                }
            }
            </code>
            </example>
        </member>
        <member name="M:ADMS.API.Services.ClamAvVirusScanner.GetScannerInfo">
            <summary>
            Retrieves comprehensive information about the ClamAV virus scanner configuration and capabilities.
            This method provides static information about the scanner implementation including product details,
            supported formats, detection capabilities, and operational characteristics.
            </summary>
            <returns>
            A ScannerInfo object containing detailed information about scanner name, version, and vendor
            information, supported file formats and detection capabilities, configuration settings and 
            operational parameters, performance characteristics and resource requirements, and integration
            details and compatibility information.
            </returns>
            <remarks>
            <para>This method provides static information about the scanner implementation including:</para>
            
            <para><strong>Scanner Identification:</strong></para>
            <list type="bullet">
            <item>Product name, version, and build information</item>
            <item>Vendor details and support contact information</item>
            <item>Scanner type and detection methodology</item>
            <item>Integration compatibility and API version</item>
            </list>
            
            <para><strong>Capability Information:</strong></para>
            <list type="bullet">
            <item>Supported file formats and MIME types for scanning</item>
            <item>Detection technologies and threat analysis capabilities</item>
            <item>Performance characteristics and operational limits</item>
            <item>Configuration options and customization features</item>
            </list>
            
            <para><strong>Configuration Details:</strong></para>
            <list type="bullet">
            <item>Server connection configuration and network settings</item>
            <item>Performance tuning parameters and resource limits</item>
            <item>Operational thresholds and timeout configurations</item>
            <item>Concurrency settings and connection pooling parameters</item>
            </list>
            
            <para><strong>Usage Scenarios:</strong></para>
            <list type="bullet">
            <item>System documentation and compliance reporting</item>
            <item>Integration planning and compatibility assessment</item>
            <item>Performance tuning and capacity planning</item>
            <item>Troubleshooting and support diagnostics</item>
            </list>
            </remarks>
            <example>
            <code>
            // Get scanner information for system documentation
            var scannerInfo = _virusScanner.GetScannerInfo();
            
            _logger.LogInformation("Virus Scanner: {ProductName} v{Version} by {Vendor}",
                scannerInfo.ProductName, scannerInfo.ProductVersion, scannerInfo.VendorName);
            
            // Check format support before scanning
            if (scannerInfo.SupportedFormats.Contains("application/pdf"))
            {
                var scanResult = await _virusScanner.ScanFileForVirusesAsync(pdfStream);
            }
            
            // Display configuration for troubleshooting
            var config = scannerInfo.ConfigurationDetails;
            foreach (var setting in config)
            {
                _logger.LogDebug("Scanner Config - {Key}: {Value}", setting.Key, setting.Value);
            }
            </code>
            </example>
        </member>
        <member name="M:ADMS.API.Services.ClamAvVirusScanner.PerformVirusScanWithRetryAsync(System.IO.Stream,System.String,System.Threading.CancellationToken)">
            <summary>
            Performs virus scanning with comprehensive retry logic and error handling for production resilience.
            This method implements exponential backoff retry strategy to handle transient failures gracefully
            while maintaining connection pooling and resource management for optimal performance.
            </summary>
            <param name="fileStream">The file stream to scan for viruses and malicious content.</param>
            <param name="operationId">Unique identifier for operation tracking and correlation across logs.</param>
            <param name="cancellationToken">Cancellation token for responsive cancellation handling.</param>
            <returns>Comprehensive virus scan result with detailed threat information and metadata.</returns>
            <remarks>
            This method provides enterprise-grade retry logic with exponential backoff, connection pooling
            through semaphore management, comprehensive error logging and monitoring, graceful handling of
            cancellation requests, and resource cleanup and stream position management.
            </remarks>
        </member>
        <member name="M:ADMS.API.Services.ClamAvVirusScanner.PerformSingleVirusScanAsync(System.IO.Stream,System.String,System.Threading.CancellationToken)">
            <summary>
            Performs a single virus scan attempt using ClamAV client with comprehensive error handling.
            This method manages the direct communication with ClamAV daemon including connection setup,
            file size validation, scanning operation, and result processing.
            </summary>
            <param name="fileStream">The file stream to scan for viruses.</param>
            <param name="operationId">Unique identifier for operation tracking.</param>
            <param name="cancellationToken">Cancellation token for responsive cancellation.</param>
            <returns>Virus scan result with detailed threat information.</returns>
            <remarks>
            This method handles direct ClamAV communication, file size limit enforcement, timeout management,
            and comprehensive result processing with threat classification.
            </remarks>
        </member>
        <member name="M:ADMS.API.Services.ClamAvVirusScanner.ProcessClamAvScanResult(nClam.ClamScanResult,System.String)">
            <summary>
            Processes ClamAV scan results and creates comprehensive VirusScanResult objects with detailed
            threat information, classification, and metadata for security analysis and operational monitoring.
            </summary>
            <param name="clamResult">The raw ClamAV scan result to process.</param>
            <param name="operationId">Operation identifier for tracking and correlation.</param>
            <returns>Comprehensive virus scan result with threat details and metadata.</returns>
            <remarks>
            This method transforms ClamAV native results into standardized VirusScanResult objects with
            comprehensive threat classification, security metadata, and operational context information.
            </remarks>
        </member>
        <member name="M:ADMS.API.Services.ClamAvVirusScanner.TestConnectivityAsync(System.Threading.CancellationToken)">
            <summary>
            Tests basic connectivity to the ClamAV server for health monitoring using both network
            connectivity validation and ClamAV daemon responsiveness testing.
            </summary>
            <param name="cancellationToken">Cancellation token for responsive cancellation.</param>
            <returns>Connectivity test result with response time and error information.</returns>
            <remarks>
            This method performs comprehensive connectivity testing including network layer validation
            and ClamAV service-specific communication testing for complete health assessment.
            </remarks>
        </member>
        <member name="M:ADMS.API.Services.ClamAvVirusScanner.TestScanningFunctionalityAsync(System.Threading.CancellationToken)">
            <summary>
            Tests ClamAV scanning functionality using EICAR test virus signature to verify that
            the scanning engine can properly detect known malicious content.
            </summary>
            <param name="cancellationToken">Cancellation token for responsive cancellation.</param>
            <returns>Functionality test result indicating whether scanning is working properly.</returns>
            <remarks>
            This method uses the industry-standard EICAR test file to validate that ClamAV can detect
            and classify known malicious signatures, ensuring the scanning functionality is operational.
            </remarks>
        </member>
        <member name="M:ADMS.API.Services.ClamAvVirusScanner.GetVirusDefinitionInfoAsync(System.Threading.CancellationToken)">
            <summary>
            Retrieves virus definition information from ClamAV server for health monitoring including
            version information, update timestamps, and currency assessment.
            </summary>
            <param name="cancellationToken">Cancellation token for responsive cancellation.</param>
            <returns>Virus definition information including version and update status.</returns>
            <remarks>
            This method queries ClamAV for current definition information and assesses whether the
            definitions are sufficiently current based on configured age thresholds.
            </remarks>
        </member>
        <member name="M:ADMS.API.Services.ClamAvVirusScanner.ValidateConfiguration">
            <summary>
            Validates the ClamAV scanner configuration for operational correctness and completeness.
            This method ensures all configuration parameters are within acceptable ranges and
            compatibility requirements are met.
            </summary>
            <exception cref="T:System.ArgumentException">Thrown when configuration validation fails.</exception>
            <remarks>
            This method validates server connectivity parameters, timeout and retry configurations,
            resource allocation settings, and operational thresholds for production deployment.
            </remarks>
        </member>
        <member name="M:ADMS.API.Services.ClamAvVirusScanner.DetermineThreatType(System.String)">
            <summary>
            Determines the threat type based on the threat name using heuristic analysis and
            pattern matching against known threat categories.
            </summary>
            <param name="threatName">The name of the detected threat.</param>
            <returns>The categorized threat type for security classification.</returns>
            <remarks>
            This method uses pattern matching to classify threats into standard categories
            for consistent security analysis and incident response procedures.
            </remarks>
        </member>
        <member name="M:ADMS.API.Services.ClamAvVirusScanner.DetermineThreatSeverity(System.String)">
            <summary>
            Determines the threat severity based on the threat type and name using security
            best practices and threat intelligence classification standards.
            </summary>
            <param name="threatName">The name of the detected threat.</param>
            <returns>The assessed threat severity level for risk management.</returns>
            <remarks>
            This method assigns severity levels based on potential impact and urgency of
            response required for different threat categories.
            </remarks>
        </member>
        <member name="M:ADMS.API.Services.ClamAvVirusScanner.GetScannerVersion">
            <summary>
            Gets the current scanner version information for metadata and reporting purposes.
            </summary>
            <returns>Scanner version string with build information.</returns>
            <remarks>
            This method provides version information for audit trails, compatibility checking,
            and operational monitoring requirements.
            </remarks>
        </member>
        <member name="M:ADMS.API.Services.ClamAvVirusScanner.ExtractVersionFromResponse(System.String)">
            <summary>
            Extracts version information from ClamAV version response for cases where
            standard parsing methods don't capture all version details.
            </summary>
            <param name="versionResponse">The raw version response from ClamAV.</param>
            <returns>Extracted version string or fallback identifier.</returns>
            <remarks>
            This method provides fallback version extraction for improved compatibility
            with different ClamAV versions and response formats.
            </remarks>
        </member>
        <member name="M:ADMS.API.Services.ClamAvVirusScanner.ThrowIfDisposed">
            <summary>
            Validates that the scanner has not been disposed and throws an appropriate exception if it has.
            </summary>
            <exception cref="T:System.ObjectDisposedException">Thrown when the scanner has been disposed.</exception>
            <remarks>
            This method ensures operations are only performed on active scanner instances and provides
            consistent error handling for disposed object access attempts.
            </remarks>
        </member>
        <member name="T:ADMS.API.Services.ClamAvVirusScanner.ConnectivityTestResult">
            <summary>
            Represents the result of a connectivity test to ClamAV server with timing and error information.
            </summary>
        </member>
        <member name="P:ADMS.API.Services.ClamAvVirusScanner.ConnectivityTestResult.IsSuccessful">
            <summary>Gets a value indicating whether the connectivity test was successful.</summary>
        </member>
        <member name="P:ADMS.API.Services.ClamAvVirusScanner.ConnectivityTestResult.ResponseTime">
            <summary>Gets the response time for the connectivity test.</summary>
        </member>
        <member name="P:ADMS.API.Services.ClamAvVirusScanner.ConnectivityTestResult.ErrorMessage">
            <summary>Gets the error message if the test failed, null otherwise.</summary>
        </member>
        <member name="T:ADMS.API.Services.ClamAvVirusScanner.FunctionalityTestResult">
            <summary>
            Represents the result of a functionality test using EICAR signature with success status and error details.
            </summary>
        </member>
        <member name="P:ADMS.API.Services.ClamAvVirusScanner.FunctionalityTestResult.IsSuccessful">
            <summary>Gets a value indicating whether the functionality test was successful.</summary>
        </member>
        <member name="P:ADMS.API.Services.ClamAvVirusScanner.FunctionalityTestResult.ErrorMessage">
            <summary>Gets the error message if the test failed, null otherwise.</summary>
        </member>
        <member name="T:ADMS.API.Services.ClamAvVirusScanner.DefinitionInfoResult">
            <summary>
            Represents virus definition information retrieved from ClamAV server with version and currency details.
            </summary>
        </member>
        <member name="P:ADMS.API.Services.ClamAvVirusScanner.DefinitionInfoResult.IsSuccessful">
            <summary>Gets a value indicating whether the definition info retrieval was successful.</summary>
        </member>
        <member name="P:ADMS.API.Services.ClamAvVirusScanner.DefinitionInfoResult.Version">
            <summary>Gets the virus definition version identifier.</summary>
        </member>
        <member name="P:ADMS.API.Services.ClamAvVirusScanner.DefinitionInfoResult.LastUpdate">
            <summary>Gets the timestamp when virus definitions were last updated.</summary>
        </member>
        <member name="P:ADMS.API.Services.ClamAvVirusScanner.DefinitionInfoResult.IsCurrent">
            <summary>Gets a value indicating whether the definitions are considered current based on age thresholds.</summary>
        </member>
        <member name="P:ADMS.API.Services.ClamAvVirusScanner.DefinitionInfoResult.ErrorMessage">
            <summary>Gets the error message if retrieval failed, null otherwise.</summary>
        </member>
        <member name="M:ADMS.API.Services.ClamAvVirusScanner.Dispose(System.Boolean)">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting resources.
            This method provides comprehensive cleanup of managed resources including semaphores, connections,
            and other disposable objects used by the ClamAV virus scanner implementation.
            </summary>
            <param name="disposing">
            True if disposing managed resources during explicit disposal; false if called from finalizer.
            When true, performs complete cleanup of all managed and unmanaged resources.
            When false, only cleans up unmanaged resources during garbage collection.
            </param>
            <remarks>
            <para>This method implements the standard .NET disposal pattern including:</para>
            
            <para><strong>Resource Cleanup:</strong></para>
            <list type="bullet">
            <item>Disposal of connection semaphores and concurrency control mechanisms</item>
            <item>Cleanup of cached health check results and operational state</item>
            <item>Proper termination of any active scanning operations</item>
            <item>Release of system resources and network connections</item>
            <item>Comprehensive logging of disposal operations for audit purposes</item>
            </list>
            
            <para><strong>Thread Safety:</strong></para>
            <list type="bullet">
            <item>Thread-safe disposal using volatile boolean flag</item>
            <item>Protection against multiple disposal calls</item>
            <item>Proper synchronization during cleanup operations</item>
            <item>Safe handling of concurrent access during disposal</item>
            </list>
            
            <para><strong>Error Handling:</strong></para>
            <list type="bullet">
            <item>Graceful handling of disposal errors without throwing exceptions</item>
            <item>Comprehensive logging of cleanup failures for diagnostics</item>
            <item>Continuation of disposal process even if individual cleanup operations fail</item>
            <item>Prevention of resource leaks through defensive cleanup strategies</item>
            </list>
            </remarks>
        </member>
        <member name="M:ADMS.API.Services.ClamAvVirusScanner.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            This method implements the IDisposable interface to ensure proper cleanup of ClamAV scanner resources
            and integration with .NET's garbage collection and resource management systems.
            </summary>
            <remarks>
            <para>This method provides the public interface for resource disposal including:</para>
            
            <para><strong>Disposal Pattern Implementation:</strong></para>
            <list type="bullet">
            <item>Standard IDisposable pattern with finalizer suppression</item>
            <item>Delegation to protected Dispose(bool) method for actual cleanup</item>
            <item>Integration with using statements and automatic resource management</item>
            <item>Prevention of finalizer execution through GC.SuppressFinalize</item>
            <item>Thread-safe disposal with protection against multiple calls</item>
            </list>
            
            <para><strong>Resource Management Benefits:</strong></para>
            <list type="bullet">
            <item>Deterministic cleanup of system resources and connections</item>
            <item>Prevention of resource leaks in long-running applications</item>
            <item>Integration with dependency injection container lifecycle management</item>
            <item>Support for proper cleanup in exception scenarios</item>
            <item>Compliance with .NET resource management best practices</item>
            </list>
            
            <para><strong>Usage Recommendations:</strong></para>
            <list type="bullet">
            <item>Should be called explicitly when scanner instance is no longer needed</item>
            <item>Automatic disposal when used with dependency injection scoped services</item>
            <item>Integration with using statements for deterministic cleanup</item>
            <item>Essential for preventing resource exhaustion in high-throughput scenarios</item>
            </list>
            </remarks>
            <example>
            <code>
            // Explicit disposal in manual instantiation scenarios
            using var scanner = new ClamAvVirusScanner(logger, options);
            var result = await scanner.ScanFileForVirusesAsync(fileStream);
            // Scanner is automatically disposed when exiting using block
            
            // Dependency injection automatically handles disposal
            services.AddScoped&lt;IVirusScanner, ClamAvVirusScanner&gt;();
            // Scanner instance is disposed at the end of request scope
            
            // Manual disposal when needed
            var scanner = serviceProvider.GetRequiredService&lt;IVirusScanner&gt;();
            try
            {
                var result = await scanner.ScanFileForVirusesAsync(fileStream);
                // Process result...
            }
            finally
            {
                if (scanner is IDisposable disposableScanner)
                    disposableScanner.Dispose();
            }
            </code>
            </example>
        </member>
        <member name="T:ADMS.API.Services.ClamAvScannerOptions">
            <summary>
            Configuration options for ClamAV virus scanner operations and behavior.
            This class provides comprehensive configuration settings for all aspects of ClamAV scanner
            operation including connection management, performance tuning, retry policies, and
            operational thresholds for enterprise deployment scenarios.
            </summary>
            <remarks>
            <para>This configuration class provides comprehensive control over scanner behavior including:</para>
            
            <para><strong>Connection Configuration:</strong></para>
            <list type="bullet">
            <item>ClamAV server host and port specification for network connectivity</item>
            <item>Connection timeout and retry policies for network resilience</item>
            <item>Concurrent connection management for high-throughput scenarios</item>
            <item>Network security and authentication parameters</item>
            </list>
            
            <para><strong>Performance Tuning:</strong></para>
            <list type="bullet">
            <item>File size limits and processing constraints for resource management</item>
            <item>Timeout values for responsive user experience</item>
            <item>Retry logic configuration with exponential backoff</item>
            <item>Health check caching for optimal monitoring performance</item>
            </list>
            
            <para><strong>Operational Parameters:</strong></para>
            <list type="bullet">
            <item>Virus definition currency thresholds for security effectiveness</item>
            <item>Logging levels and diagnostic information configuration</item>
            <item>Integration parameters for enterprise monitoring systems</item>
            <item>Compliance settings for audit and security requirements</item>
            </list>
            
            <para><strong>Configuration Sources:</strong></para>
            <list type="bullet">
            <item>appsettings.json configuration file integration</item>
            <item>Environment variable override support</item>
            <item>Azure Key Vault and secure configuration provider integration</item>
            <item>Runtime configuration updates through IOptionsMonitor</item>
            </list>
            </remarks>
            <example>
            <code>
            // appsettings.json configuration
            {
              "ClamAV": {
                "ServerHost": "clamav.company.com",
                "ServerPort": 3310,
                "TimeoutSeconds": 60,
                "MaxConcurrentConnections": 10,
                "MaxRetryAttempts": 5,
                "BaseRetryDelayMs": 2000,
                "MaxRetryDelayMs": 30000,
                "MaxFileSizeMB": 500,
                "HealthCheckCacheSeconds": 300,
                "MaxDefinitionAgeDays": 3
              }
            }
            
            // Dependency injection configuration
            services.Configure&lt;ClamAvScannerOptions&gt;(
                configuration.GetSection("ClamAV"));
            
            services.AddScoped&lt;IVirusScanner, ClamAvVirusScanner&gt;();
            
            // Environment-specific overrides
            services.Configure&lt;ClamAvScannerOptions&gt;(options =>
            {
                if (environment.IsProduction())
                {
                    options.MaxRetryAttempts = 5;
                    options.TimeoutSeconds = 120;
                    options.MaxDefinitionAgeDays = 1; // Stricter in production
                }
                else if (environment.IsDevelopment())
                {
                    options.ServerHost = "localhost";
                    options.MaxRetryAttempts = 1; // Fail fast in development
                    options.HealthCheckCacheSeconds = 0; // No caching in development
                }
            });
            </code>
            </example>
        </member>
        <member name="P:ADMS.API.Services.ClamAvScannerOptions.ServerHost">
            <summary>
            Gets or sets the hostname or IP address of the ClamAV server for network connectivity.
            This parameter specifies the target server where the ClamAV daemon (clamd) is running
            and accessible for virus scanning operations.
            </summary>
            <value>
            The hostname, fully qualified domain name (FQDN), or IP address of the ClamAV server.
            Default value is "localhost" for local installations.
            </value>
            <remarks>
            <para>Configuration considerations include:</para>
            
            <para><strong>Network Connectivity:</strong></para>
            <list type="bullet">
            <item>Must be a reachable hostname or IP address from the application server</item>
            <item>Firewall rules must allow connections to the specified host</item>
            <item>DNS resolution must be properly configured for hostname specifications</item>
            <item>Network latency should be considered for performance optimization</item>
            </list>
            
            <para><strong>Security Considerations:</strong></para>
            <list type="bullet">
            <item>Should use secure network connections when possible</item>
            <item>Consider network segmentation for security isolation</item>
            <item>Monitor network traffic for security and performance analysis</item>
            <item>Implement proper access controls and authentication if required</item>
            </list>
            
            <para><strong>Common Values:</strong></para>
            <list type="bullet">
            <item>"localhost" - Local ClamAV daemon installation</item>
            <item>"127.0.0.1" - Local IP address specification</item>
            <item>"clamav.company.com" - Dedicated ClamAV server</item>
            <item>"10.0.1.100" - Internal network IP address</item>
            </list>
            </remarks>
        </member>
        <member name="P:ADMS.API.Services.ClamAvScannerOptions.ServerPort">
            <summary>
            Gets or sets the port number for ClamAV server connection and communication.
            This parameter specifies the TCP port where the ClamAV daemon is listening
            for client connections and scanning requests.
            </summary>
            <value>
            The TCP port number for ClamAV server communication.
            Default value is 3310, which is the standard ClamAV daemon port.
            Valid range is 1-65535.
            </value>
            <remarks>
            <para>Port configuration considerations include:</para>
            
            <para><strong>Standard Configuration:</strong></para>
            <list type="bullet">
            <item>Port 3310 is the default and standard port for ClamAV daemon</item>
            <item>Most ClamAV installations use this default port configuration</item>
            <item>Firewall rules and network policies should allow access to this port</item>
            <item>Load balancers and proxy configurations must route to correct port</item>
            </list>
            
            <para><strong>Custom Port Scenarios:</strong></para>
            <list type="bullet">
            <item>Non-standard ports may be used for security through obscurity</item>
            <item>Multiple ClamAV instances on same server require different ports</item>
            <item>Corporate environments may have port usage policies</item>
            <item>Container and orchestration environments may use dynamic port assignment</item>
            </list>
            
            <para><strong>Security and Network Considerations:</strong></para>
            <list type="bullet">
            <item>Ensure port is not exposed to untrusted networks</item>
            <item>Configure appropriate firewall rules for access control</item>
            <item>Monitor port for unauthorized access attempts</item>
            <item>Consider network segmentation for additional security</item>
            </list>
            </remarks>
        </member>
        <member name="P:ADMS.API.Services.ClamAvScannerOptions.TimeoutSeconds">
            <summary>
            Gets or sets the timeout duration in seconds for ClamAV operations and network communications.
            This parameter controls the maximum time allowed for individual scanning operations
            before they are considered failed and terminated.
            </summary>
            <value>
            The timeout duration in seconds for ClamAV operations.
            Default value is 30 seconds, providing reasonable balance between responsiveness and reliability.
            Valid range is 1-300 seconds (5 minutes maximum).
            </value>
            <remarks>
            <para>Timeout configuration considerations include:</para>
            
            <para><strong>Performance Impact:</strong></para>
            <list type="bullet">
            <item>Shorter timeouts provide better user experience but may cause scan failures</item>
            <item>Longer timeouts accommodate large files but may impact system responsiveness</item>
            <item>File size and complexity directly impact required scanning time</item>
            <item>Network latency and server load affect total operation duration</item>
            </list>
            
            <para><strong>Operational Considerations:</strong></para>
            <list type="bullet">
            <item>Should account for peak load scenarios and resource contention</item>
            <item>Must balance user experience with scanning thoroughness</item>
            <item>Integration with application-level timeouts and user interface design</item>
            <item>Monitoring and alerting for timeout occurrences and patterns</item>
            </list>
            
            <para><strong>Recommended Values:</strong></para>
            <list type="bullet">
            <item>30 seconds - Default for most scenarios with moderate file sizes</item>
            <item>60 seconds - Large files or high-latency network environments</item>
            <item>120 seconds - Very large files or resource-constrained environments</item>
            <item>15 seconds - Small files with strict performance requirements</item>
            </list>
            </remarks>
        </member>
        <member name="P:ADMS.API.Services.ClamAvScannerOptions.MaxConcurrentConnections">
            <summary>
            Gets or sets the maximum number of concurrent connections to the ClamAV server.
            This parameter controls connection pooling and resource utilization for
            high-throughput scanning scenarios with concurrent file processing.
            </summary>
            <value>
            The maximum number of concurrent connections allowed to the ClamAV server.
            Default value is 5 connections, providing good balance between performance and resource usage.
            Valid range is 1-100 connections.
            </value>
            <remarks>
            <para>Concurrency configuration considerations include:</para>
            
            <para><strong>Performance Optimization:</strong></para>
            <list type="bullet">
            <item>Higher concurrency improves throughput for multiple simultaneous scans</item>
            <item>Must not exceed ClamAV server capacity and connection limits</item>
            <item>Consider network bandwidth and server resource constraints</item>
            <item>Balance with application server resource availability</item>
            </list>
            
            <para><strong>Resource Management:</strong></para>
            <list type="bullet">
            <item>Each connection consumes memory and system resources</item>
            <item>ClamAV server must be configured to handle concurrent connections</item>
            <item>Network connection pooling and reuse for efficiency</item>
            <item>Monitoring of connection utilization and bottlenecks</item>
            </list>
            
            <para><strong>Scaling Considerations:</strong></para>
            <list type="bullet">
            <item>Should scale with expected concurrent file upload volume</item>
            <item>Consider horizontal scaling with multiple ClamAV servers</item>
            <item>Load balancing and failover for high availability scenarios</item>
            <item>Capacity planning based on peak usage patterns</item>
            </list>
            </remarks>
        </member>
        <member name="P:ADMS.API.Services.ClamAvScannerOptions.MaxRetryAttempts">
            <summary>
            Gets or sets the maximum number of retry attempts for failed scanning operations.
            This parameter controls the resilience and fault tolerance of the scanner
            when encountering transient failures or network issues.
            </summary>
            <value>
            The maximum number of retry attempts for failed operations.
            Default value is 3 attempts, providing reasonable resilience without excessive delays.
            Valid range is 1-10 attempts.
            </value>
            <remarks>
            <para>Retry configuration considerations include:</para>
            
            <para><strong>Reliability Benefits:</strong></para>
            <list type="bullet">
            <item>Handles transient network failures and temporary server unavailability</item>
            <item>Improves overall system reliability and user experience</item>
            <item>Reduces false negatives due to temporary infrastructure issues</item>
            <item>Provides graceful degradation under adverse conditions</item>
            </list>
            
            <para><strong>Performance Impact:</strong></para>
            <list type="bullet">
            <item>More retries increase potential operation duration</item>
            <item>Exponential backoff prevents overwhelming stressed systems</item>
            <item>Must balance reliability with responsiveness requirements</item>
            <item>Consider cumulative timeout including all retry attempts</item>
            </list>
            
            <para><strong>Error Handling Strategy:</strong></para>
            <list type="bullet">
            <item>Distinguish between retryable and non-retryable errors</item>
            <item>Implement circuit breaker patterns for systematic failures</item>
            <item>Log retry attempts for monitoring and diagnostics</item>
            <item>Consider alternative scanning methods after exhausted retries</item>
            </list>
            </remarks>
        </member>
        <member name="P:ADMS.API.Services.ClamAvScannerOptions.BaseRetryDelayMs">
            <summary>
            Gets or sets the base delay in milliseconds for retry attempts using exponential backoff.
            This parameter controls the initial delay between retry attempts, with subsequent
            delays increasing exponentially to prevent overwhelming struggling services.
            </summary>
            <value>
            The base delay in milliseconds for the first retry attempt.
            Default value is 1000ms (1 second), providing reasonable initial delay.
            Valid range is 100-30000ms (30 seconds maximum).
            </value>
            <remarks>
            <para>Retry delay configuration considerations include:</para>
            
            <para><strong>Exponential Backoff Strategy:</strong></para>
            <list type="bullet">
            <item>First retry after base delay (e.g., 1 second)</item>
            <item>Second retry after 2x base delay (e.g., 2 seconds)</item>
            <item>Third retry after 4x base delay (e.g., 4 seconds)</item>
            <item>Prevents overwhelming stressed or recovering services</item>
            </list>
            
            <para><strong>Performance Balance:</strong></para>
            <list type="bullet">
            <item>Shorter delays provide faster recovery from transient issues</item>
            <item>Longer delays reduce system load during outages</item>
            <item>Must consider user experience and timeout expectations</item>
            <item>Balance between responsiveness and system stability</item>
            </list>
            </remarks>
        </member>
        <member name="P:ADMS.API.Services.ClamAvScannerOptions.MaxRetryDelayMs">
            <summary>
            Gets or sets the maximum delay in milliseconds for retry attempts to cap exponential backoff.
            This parameter prevents exponential backoff delays from becoming excessively long
            while maintaining reasonable retry intervals for system recovery.
            </summary>
            <value>
            The maximum delay in milliseconds for any single retry attempt.
            Default value is 10000ms (10 seconds), preventing excessive wait times.
            Valid range is 1000-60000ms (1 minute maximum).
            </value>
            <remarks>
            <para>Maximum delay configuration provides:</para>
            
            <para><strong>Backoff Capping Benefits:</strong></para>
            <list type="bullet">
            <item>Prevents exponential backoff from creating extremely long delays</item>
            <item>Maintains reasonable retry intervals even after multiple failures</item>
            <item>Ensures predictable maximum operation duration</item>
            <item>Balances system recovery time with user experience</item>
            </list>
            
            <para><strong>System Behavior:</strong></para>
            <list type="bullet">
            <item>Once maximum delay is reached, subsequent retries use this interval</item>
            <item>Provides consistent retry pattern for extended outages</item>
            <item>Allows system recovery without overwhelming with requests</item>
            <item>Maintains reasonable user experience during extended failures</item>
            </list>
            </remarks>
        </member>
        <member name="P:ADMS.API.Services.ClamAvScannerOptions.MaxFileSizeMB">
            <summary>
            Gets or sets the maximum file size in megabytes that can be scanned by the virus scanner.
            This parameter provides resource protection by preventing excessively large files
            from consuming system resources or causing performance degradation.
            </summary>
            <value>
            The maximum file size in megabytes that can be processed.
            Default value is 100 MB, suitable for most document and media file scenarios.
            Valid range is 1-1000 MB (1 GB maximum).
            </value>
            <remarks>
            <para>File size limit configuration considerations include:</para>
            
            <para><strong>Resource Protection:</strong></para>
            <list type="bullet">
            <item>Prevents memory exhaustion from extremely large file processing</item>
            <item>Limits network transfer time and bandwidth usage</item>
            <item>Protects ClamAV server from resource exhaustion</item>
            <item>Maintains responsive scanning for normal file sizes</item>
            </list>
            
            <para><strong>Business Requirements:</strong></para>
            <list type="bullet">
            <item>Should accommodate legitimate business file sizes</item>
            <item>Consider typical file types and sizes in your environment</item>
            <item>Balance security scanning with business functionality</item>
            <item>Provide clear error messages for oversized files</item>
            </list>
            
            <para><strong>Recommended Limits:</strong></para>
            <list type="bullet">
            <item>50 MB - Standard document and image processing</item>
            <item>100 MB - Mixed content including presentations and media</item>
            <item>250 MB - Large media files and specialized documents</item>
            <item>500 MB - Enterprise scenarios with large file requirements</item>
            </list>
            </remarks>
        </member>
        <!-- Badly formed XML comment ignored for member "P:ADMS.API.Services.ClamAvScannerOptions.HealthCheckCacheSeconds" -->
        <member name="P:ADMS.API.Services.ClamAvScannerOptions.MaxDefinitionAgeDays">
            <summary>
            Gets or sets the maximum age in days for virus definitions to be considered current.
            This parameter defines the threshold for determining whether virus definitions
            are sufficiently up-to-date for effective threat detection.
            </summary>
            <value>
            The maximum age in days for virus definitions to be considered current.
            Default value is 7 days, providing reasonable balance between security and operational flexibility.
            Valid range is 1-30 days.
            </value>
            <remarks>
            <para>Definition currency configuration considerations include:</para>
            
            <para><strong>Security Effectiveness:</strong></para>
            <list type="bullet">
            <item>More recent definitions provide better protection against new threats</item>
            <item>Older definitions may miss recently discovered malware variants</item>
            <item>Balance between security effectiveness and operational stability</item>
            <item>Consider threat landscape and update frequency requirements</item>
            </list>
            
            <para><strong>Operational Impact:</strong></para>
            <list type="bullet">
            <item>Stricter currency requirements increase maintenance overhead</item>
            <item>More lenient settings provide operational flexibility</item>
            <item>Must align with organizational security policies</item>
            <item>Consider automated update mechanisms and schedules</item>
            </list>
            
            <para><strong>Recommended Settings:</strong></para>
            <list type="bullet">
            <item>1-3 days - High-security environments with frequent updates</item>
            <item>7 days - Standard business environments with weekly update cycles</item>
            <item>14 days - Stable environments with less frequent maintenance</item>
            <item>30 days - Development or testing environments with relaxed requirements</item>
            </list>
            </remarks>
        </member>
        <member name="T:ADMS.API.Services.Common.EntityType">
            <summary>
            Enumeration of entity types supported by the validation system.
            </summary>
        </member>
        <member name="T:ADMS.API.Services.Common.EntityValidationResult">
            <summary>
            Represents the result of a single entity validation operation.
            </summary>
        </member>
        <member name="T:ADMS.API.Services.Common.FileNameConflictType">
            <summary>
            Represents file name conflict information.
            </summary>
        </member>
        <member name="T:ADMS.API.Services.Common.FileNameConflict">
            <summary>
            Represents a file name conflict result.
            </summary>
        </member>
        <member name="T:ADMS.API.Services.Common.IEntityExistenceValidator">
            <summary>
            Defines the contract for entity existence validation services.
            </summary>
        </member>
        <member name="M:ADMS.API.Services.Common.IEntityExistenceValidator.MatterExistsAsync(System.Guid,System.Threading.CancellationToken)">
            <summary>
            Validates whether a matter exists.
            </summary>
        </member>
        <member name="M:ADMS.API.Services.Common.IEntityExistenceValidator.DocumentExistsAsync(System.Guid,System.Threading.CancellationToken)">
            <summary>
            Validates whether a document exists.
            </summary>
        </member>
        <member name="M:ADMS.API.Services.Common.IEntityExistenceValidator.RevisionExistsAsync(System.Guid,System.Threading.CancellationToken)">
            <summary>
            Validates whether a revision exists.
            </summary>
        </member>
        <member name="M:ADMS.API.Services.Common.IEntityExistenceValidator.ValidateDocumentBelongsToMatterAsync(System.Guid,System.Guid,System.Threading.CancellationToken)">
            <summary>
            Validates whether a document belongs to a specific matter.
            </summary>
        </member>
        <member name="M:ADMS.API.Services.Common.IEntityExistenceValidator.ValidateRevisionBelongsToDocumentAsync(System.Guid,System.Guid,System.Threading.CancellationToken)">
            <summary>
            Validates whether a revision belongs to a specific document.
            </summary>
        </member>
        <member name="M:ADMS.API.Services.Common.IEntityExistenceValidator.FileNameExistsAsync(System.Guid,System.String,System.Threading.CancellationToken)">
            <summary>
            Validates whether a file name exists in a matter.
            </summary>
        </member>
        <member name="M:ADMS.API.Services.Common.IEntityExistenceValidator.ValidateEntitiesExistAsync(System.Collections.Generic.IEnumerable{System.Guid},System.Collections.Generic.IEnumerable{System.Guid},System.Collections.Generic.IEnumerable{System.Guid},System.Threading.CancellationToken)">
            <summary>
            Validates multiple entities in a batch operation.
            </summary>
        </member>
        <member name="M:ADMS.API.Services.Common.IEntityExistenceValidator.GetDiagnosticInfo">
            <summary>
            Gets diagnostic information about the validator.
            </summary>
        </member>
        <member name="M:ADMS.API.Services.Common.IEntityExistenceValidator.ClearValidationCache">
            <summary>
            Clears the validation cache.
            </summary>
        </member>
        <member name="T:ADMS.API.Services.Common.PerformanceMetrics">
            <summary>
            Simple performance metrics collection for validation operations.
            </summary>
        </member>
        <member name="M:ADMS.API.Services.Common.PerformanceMetrics.RecordOperation(System.String,System.TimeSpan,System.Boolean,System.Nullable{System.Int32})">
            <summary>
            Records an operation with its duration and success status.
            </summary>
        </member>
        <member name="M:ADMS.API.Services.Common.PerformanceMetrics.GetOperationMetrics(System.String)">
            <summary>
            Gets metrics for a specific operation type.
            </summary>
        </member>
        <member name="M:ADMS.API.Services.Common.PerformanceMetrics.GetAllMetrics">
            <summary>
            Gets all collected metrics.
            </summary>
        </member>
        <member name="M:ADMS.API.Services.Common.PerformanceMetrics.Clear">
            <summary>
            Clears all collected metrics.
            </summary>
        </member>
        <member name="M:ADMS.API.Services.Common.PerformanceMetrics.StartOperation(System.String)">
            <summary>
            Starts tracking an operation and returns a disposable tracker.
            </summary>
        </member>
        <member name="T:ADMS.API.Services.Common.OperationMetrics">
            <summary>
            Represents metrics for a specific operation type.
            </summary>
        </member>
        <member name="T:ADMS.API.Services.Common.OperationTracker">
            <summary>
            Disposable operation tracker for automatic metrics recording.
            </summary>
        </member>
        <member name="T:ADMS.API.Services.EntityExistenceValidator">
            <summary>
            Simple, robust entity existence validation service.
            </summary>
        </member>
        <member name="T:ADMS.API.Services.EntityValidationOptions">
            <summary>
            Configuration options for EntityExistenceValidator.
            </summary>
        </member>
        <member name="T:ADMS.API.Services.FileSystemStorage">
            <summary>
            Enterprise-grade file system storage implementation providing comprehensive file management capabilities.
            </summary>
            <remarks>
            This class provides a robust file system storage implementation including:
            
            Core File System Capabilities:
            - Asynchronous file operations with comprehensive error handling
            - High-performance file I/O optimized for document management scenarios
            - Thread-safe operations supporting concurrent file access
            - Atomic file operations preventing data corruption
            - Automatic directory creation and management
            
            Security and Validation Features:
            - Path validation preventing directory traversal attacks
            - File permission management and access control
            - Input sanitization for secure file operations
            - Audit logging for compliance and security monitoring
            - Integration with security policies and access controls
            
            Performance and Scalability:
            - Stream-based operations for memory-efficient large file handling
            - Cancellation token support for responsive operations
            - Performance metrics collection and monitoring
            - Resource management and cleanup for optimal performance
            - Concurrent operation support with proper synchronization
            
            Error Handling and Resilience:
            - Comprehensive exception handling with detailed error reporting
            - Structured error responses for client applications
            - Recovery recommendations for various failure scenarios
            - Detailed logging for troubleshooting and monitoring
            - Graceful degradation for storage unavailability
            
            Monitoring and Diagnostics:
            - Performance metrics collection for optimization
            - Health monitoring and capacity tracking
            - Detailed audit logging for compliance requirements
            - Integration with application performance monitoring
            - Diagnostic information for operational visibility
            
            The implementation is designed to be:
            - Secure: Comprehensive security validation and access control
            - Performant: Optimized for high-throughput document storage scenarios
            - Reliable: Robust error handling and recovery mechanisms
            - Observable: Rich logging and monitoring capabilities
            - Maintainable: Clean architecture with comprehensive documentation
            </remarks>
            <example>
            <code>
            // Service registration with configuration
            services.Configure&lt;FileSystemStorageOptions&gt;(configuration.GetSection("FileStorage"));
            services.AddScoped&lt;IFileStorage, FileSystemStorage&gt;();
            
            // Usage in document controller
            [HttpPost("upload")]
            public async Task&lt;IActionResult&gt; UploadDocument(IFormFile file)
            {
                using var stream = new MemoryStream();
                await file.CopyToAsync(stream);
                
                var filePath = Path.Combine("documents", $"{Guid.NewGuid()}{Path.GetExtension(file.FileName)}");
                var result = await _fileStorage.SaveFileAsync(filePath, stream.ToArray());
                
                return result.IsSuccess ? Ok(result) : BadRequest(result.ErrorMessage);
            }
            </code>
            </example>
        </member>
        <member name="M:ADMS.API.Services.FileSystemStorage.#ctor(Microsoft.Extensions.Logging.ILogger{ADMS.API.Services.FileSystemStorage},Microsoft.Extensions.Options.IOptions{ADMS.API.Services.FileSystemStorageOptions})">
            <summary>
            Initializes a new instance of the FileSystemStorage class with comprehensive configuration and logging.
            </summary>
            <param name="logger">
            The logger instance for recording file operations, performance metrics, and diagnostic information.
            Used for debugging, monitoring, and audit trail requirements.
            </param>
            <param name="options">
            Configuration options for file system storage including security settings, performance parameters,
            and operational policies. Provides flexibility for different deployment scenarios.
            </param>
            <remarks>
            The initialization process includes:
            
            1. Service Infrastructure Setup:
               - Configures comprehensive logging for all file operations
               - Initializes performance metrics collection and monitoring
               - Sets up security validation and access control mechanisms
               - Establishes error handling and recovery procedures
            
            2. Configuration Validation:
               - Validates storage configuration parameters and paths
               - Ensures base storage directories exist and are accessible
               - Verifies security settings and access permissions
               - Establishes performance and capacity limits
            
            3. Performance Optimization:
               - Initializes concurrent operation support with proper synchronization
               - Sets up file locking mechanisms for atomic operations
               - Configures memory-efficient streaming operations
               - Establishes monitoring and metrics collection
            
            4. Security Configuration:
               - Configures path validation and sanitization rules
               - Sets up access control and permission validation
               - Establishes audit logging for security compliance
               - Initializes threat detection and prevention mechanisms
            
            The service is designed to be fail-fast during initialization to catch
            configuration issues early while maintaining resilience during runtime operations.
            </remarks>
            <exception cref="T:System.ArgumentNullException">
            Thrown when logger or options parameters are null.
            </exception>
            <exception cref="T:System.InvalidOperationException">
            Thrown when storage configuration is invalid or storage directories are inaccessible.
            </exception>
            <example>
            <code>
            // Configuration in appsettings.json
            {
              "FileStorage": {
                "BasePath": "C:\\Storage\\Documents",
                "MaxFileSizeMB": 100,
                "AllowedExtensions": [".pdf", ".docx", ".txt"],
                "EnableAuditLogging": true
              }
            }
            
            // Service registration
            services.Configure&lt;FileSystemStorageOptions&gt;(configuration.GetSection("FileStorage"));
            services.AddScoped&lt;IFileStorage, FileSystemStorage&gt;();
            </code>
            </example>
        </member>
        <member name="M:ADMS.API.Services.FileSystemStorage.SaveFileAsync(System.String,System.Byte[],System.Threading.CancellationToken)">
            <summary>
            Asynchronously saves the specified content to a file at the given path with comprehensive error handling and validation.
            </summary>
            <param name="path">
            The full file path where the content will be saved.
            Must be a valid file path that is accessible for write operations.
            Directory structure will be created automatically if it doesn't exist.
            Path must not contain invalid characters or exceed system path length limits.
            </param>
            <param name="content">
            The byte array containing the content to be written to the file.
            Must not be null and should contain the complete file data.
            Large files will be handled efficiently with appropriate memory management.
            Content will be written atomically to prevent partial file corruption.
            </param>
            <param name="cancellationToken">
            Optional cancellation token to allow cancellation of long-running save operations.
            Implementations should respect cancellation requests to provide responsive user experience.
            Default value allows the operation to run to completion without cancellation.
            </param>
            <returns>
            A task that represents the asynchronous save operation.
            The task result contains a FileOperationResult with comprehensive information about:
            - Success or failure status of the save operation
            - File path and size information for successful operations
            - Detailed error information and recommended actions for failures
            - Operation metadata including timing and storage backend information
            </returns>
        </member>
        <member name="M:ADMS.API.Services.FileSystemStorage.SaveFileAsync(System.String,System.IO.Stream,System.Threading.CancellationToken)">
            <summary>
            Asynchronously saves content from a stream to a file at the given path with memory-efficient processing.
            </summary>
        </member>
        <member name="M:ADMS.API.Services.FileSystemStorage.GetFileAsync(System.String,System.Threading.CancellationToken)">
            <summary>
            Asynchronously retrieves file content as a byte array from the specified path.
            </summary>
        </member>
        <member name="M:ADMS.API.Services.FileSystemStorage.GetFileStreamAsync(System.String,System.Threading.CancellationToken)">
            <summary>
            Asynchronously opens a stream to read file content from the specified path.
            </summary>
        </member>
        <member name="M:ADMS.API.Services.FileSystemStorage.FileExistsAsync(System.String,System.Threading.CancellationToken)">
            <summary>
            Asynchronously checks whether a file exists at the specified path.
            </summary>
        </member>
        <member name="M:ADMS.API.Services.FileSystemStorage.DeleteFileAsync(System.String,System.Threading.CancellationToken)">
            <summary>
            Asynchronously deletes a file at the specified path.
            </summary>
        </member>
        <member name="M:ADMS.API.Services.FileSystemStorage.GetFileMetadataAsync(System.String,System.Threading.CancellationToken)">
            <summary>
            Asynchronously gets metadata information about a file at the specified path.
            </summary>
        </member>
        <member name="M:ADMS.API.Services.FileSystemStorage.CheckStorageHealthAsync(System.Threading.CancellationToken)">
            <summary>
            Asynchronously validates whether the storage system is healthy and operational.
            </summary>
        </member>
        <member name="M:ADMS.API.Services.FileSystemStorage.GetStorageInfo">
            <summary>
            Retrieves comprehensive information about the storage system configuration and capabilities.
            </summary>
        </member>
        <member name="M:ADMS.API.Services.FileSystemStorage.Dispose">
            <summary>
            Releases all resources used by the FileSystemStorage.
            </summary>
        </member>
        <member name="M:ADMS.API.Services.FileSystemStorage.ValidateConfiguration">
            <summary>
            Validates the service configuration during initialization.
            </summary>
        </member>
        <member name="M:ADMS.API.Services.FileSystemStorage.InitializeStorageDirectories">
            <summary>
            Initializes storage directories and ensures they are accessible.
            </summary>
        </member>
        <member name="M:ADMS.API.Services.FileSystemStorage.ValidateInputParameters(System.String,System.Byte[])">
            <summary>
            Validates input parameters for file operations.
            </summary>
        </member>
        <member name="M:ADMS.API.Services.FileSystemStorage.ValidatePathSecurity(System.String)">
            <summary>
            Validates path security to prevent directory traversal and other attacks.
            </summary>
        </member>
        <member name="M:ADMS.API.Services.FileSystemStorage.ResolveFullPath(System.String)">
            <summary>
            Resolves a relative path to a full path within the base storage directory.
            </summary>
        </member>
        <member name="M:ADMS.API.Services.FileSystemStorage.EnsureDirectoryExistsAsync(System.String,System.Threading.CancellationToken)">
            <summary>
            Ensures the directory exists for the given file path.
            </summary>
        </member>
        <member name="M:ADMS.API.Services.FileSystemStorage.ValidateAvailableSpace(System.Int64,System.String)">
            <summary>
            Validates that sufficient disk space is available for the file operation.
            </summary>
        </member>
        <member name="M:ADMS.API.Services.FileSystemStorage.GetFileSemaphore(System.String)">
            <summary>
            Gets or creates a semaphore for the specified file path to ensure atomic operations.
            </summary>
            <param name="filePath">The file path to get a semaphore for.</param>
            <returns>A semaphore for the specified file path.</returns>
        </member>
        <member name="M:ADMS.API.Services.FileSystemStorage.SaveFileAtomicallyAsync(System.String,System.Byte[],System.Threading.CancellationToken)">
            <summary>
            Performs atomic file save operation with asynchronous synchronization.
            </summary>
            <param name="fullPath">The full path where the file will be saved.</param>
            <param name="content">The content to write to the file.</param>
            <param name="cancellationToken">Cancellation token for the operation.</param>
            <returns>A FileOperationResult indicating the success or failure of the operation.</returns>
        </member>
        <member name="M:ADMS.API.Services.FileSystemStorage.SaveStreamToFileAsync(System.String,System.IO.Stream,System.Threading.CancellationToken)">
            <summary>
            Saves stream content to file with memory-efficient processing and asynchronous synchronization.
            </summary>
            <param name="fullPath">The full path where the file will be saved.</param>
            <param name="contentStream">The stream containing the content to save.</param>
            <param name="cancellationToken">Cancellation token for the operation.</param>
            <returns>A FileOperationResult indicating the success or failure of the operation.</returns>
        </member>
        <member name="M:ADMS.API.Services.FileSystemStorage.GetCurrentUser">
            <summary>
            Gets the current user context for audit logging.
            </summary>
        </member>
        <member name="T:ADMS.API.Services.FileSystemStorageOptions">
            <summary>
            Configuration options for FileSystemStorage.
            </summary>
        </member>
        <member name="P:ADMS.API.Services.FileSystemStorageOptions.BasePath">
            <summary>
            Gets or sets the base path for file storage.
            </summary>
        </member>
        <member name="P:ADMS.API.Services.FileSystemStorageOptions.MaxFileSizeMB">
            <summary>
            Gets or sets the maximum file size in megabytes.
            </summary>
        </member>
        <member name="P:ADMS.API.Services.FileSystemStorageOptions.EnableAuditLogging">
            <summary>
            Gets or sets whether audit logging is enabled.
            </summary>
        </member>
        <member name="P:ADMS.API.Services.FileSystemStorageOptions.MinimumFreeSpaceGB">
            <summary>
            Gets or sets the minimum free space required in gigabytes.
            </summary>
        </member>
        <member name="P:ADMS.API.Services.FileSystemStorageOptions.MaxAcceptableErrorRate">
            <summary>
            Gets or sets the maximum acceptable error rate percentage.
            </summary>
        </member>
        <member name="P:ADMS.API.Services.FileSystemStorageOptions.MaxConcurrentOperations">
            <summary>
            Gets or sets the maximum number of concurrent operations.
            </summary>
        </member>
        <member name="T:ADMS.API.Services.PerformanceMetrics">
            <summary>
            Performance metrics collection for file operations.
            </summary>
        </member>
        <member name="T:ADMS.API.Services.IAdmsRepository">
            <summary>
                ADMS Repository identifying actions used.
            </summary>
        </member>
        <member name="M:ADMS.API.Services.IAdmsRepository.GetExtendedAuditsAsync(System.Guid,System.Guid,ADMS.API.Helpers.AuditEnums.AuditDirection)">
            <summary>
              Retrieves a list of extended audits for a specified matter and document.
            </summary>
            <param name="matterId">Matter to be retrieved</param>
            <param name="documentId">Document to be retrieved</param>
            <param name="direction">FROM or TO</param>
            <returns>A queryable collection of audit records.</returns>
        </member>
        <member name="M:ADMS.API.Services.IAdmsRepository.GetMatterActivityByActivityNameAsync(System.String)">
            <summary>
                Retrieves a MatterActivity by its name.
            </summary>
            <param name="activityName">The name of the activity to retrieve.</param>
            <returns>The requested MatterActivity, or null if not found.</returns>
        </member>
        <member name="M:ADMS.API.Services.IAdmsRepository.GetUserByUsernameAsync(System.String)">
            <summary>
                Retrieves a user by their username.
            </summary>
            <param name="username">The username of the user to retrieve.</param>
            <returns>The requested user, or null if not found.</returns>
        </member>
        <member name="M:ADMS.API.Services.IAdmsRepository.SaveChangesAsync">
            <summary>
                Persists changes to the database.
            </summary>
            <returns>True if the changes were successfully saved, false otherwise.</returns>
        </member>
        <member name="M:ADMS.API.Services.IAdmsRepository.AddDocumentAsync(System.Guid,ADMS.API.Models.DocumentForCreationDto)">
            <summary>
                Adds a document to the specified matter.
            </summary>
            <param name="matterId">The ID of the matter to add the document to.</param>
            <param name="document">The document to add.</param>
            <returns>The created document, or null if the operation fails.</returns>
        </member>
        <member name="M:ADMS.API.Services.IAdmsRepository.DocumentExistsAsync(System.Guid)">
            <summary>
                Checks if a document exists.
            </summary>
            <param name="documentId">The ID of the document to check.</param>
            <returns>True if the document exists, false otherwise.</returns>
        </member>
        <member name="M:ADMS.API.Services.IAdmsRepository.FileNameExists(System.Guid,System.String)">
            <summary>
            Checks if a document with the specified file name already exists.
            </summary>
            <param name="matterId">Matter ID containing the document.</param>
            <param name="fileName">The file name to check.</param>
            <returns>True if the file name exists, false otherwise.</returns>
        </member>
        <member name="M:ADMS.API.Services.IAdmsRepository.GetDocumentAsync(System.Guid,System.Boolean,System.Boolean)">
            <summary>
                Retrieves a document by its ID, optionally including revisions and history.
            </summary>
            <param name="documentId">The ID of the document to retrieve.</param>
            <param name="includeRevisions">Whether to include revisions in the result.</param>
            <param name="includeHistory">Whether to include history in the result.</param>
            <returns>The requested document, or null if not found.</returns>
        </member>
        <member name="M:ADMS.API.Services.IAdmsRepository.GetPaginatedDocumentsAsync(System.Guid,ADMS.API.ResourceParameters.DocumentsResourceParameters)">
            <summary>
                Retrieves a paginated list of documents for a specified matter.
            </summary>
            <param name="matterId">The ID of the matter containing the documents.</param>
            <param name="parameters">The parameters for pagination and filtering.</param>
            <returns>A paginated list of documents.</returns>
        </member>
        <member name="M:ADMS.API.Services.IAdmsRepository.DeleteDocumentAsync(ADMS.API.Models.DocumentDto)">
            <summary>
                Deletes a document.
            </summary>
            <param name="document">The document to delete.</param>
            <returns>True if the document was successfully deleted, false otherwise.</returns>
        </member>
        <member name="M:ADMS.API.Services.IAdmsRepository.SetDocumentCheckStateAsync(System.Guid,System.Boolean)">
            <summary>
            Sets the checked-out state of a document.
            </summary>
            <param name="documentId">Document Id to be marked as checked out or checked in.</param>
            <param name="isCheckedOut">True to check out, false to check in.</param>
            <returns>True if the operation was successful, false otherwise.</returns>
        </member>
        <member name="M:ADMS.API.Services.IAdmsRepository.UpdateDocumentAsync(System.Guid,ADMS.API.Models.DocumentForUpdateDto)">
            <summary>
                Updates a document with new details using a DTO.
            </summary>
            <param name="documentId">The ID of the document to update.</param>
            <param name="documentForUpdate">The DTO containing updated document data.</param>
            <returns>The updated document, or null if the operation fails.</returns>
        </member>
        <member name="M:ADMS.API.Services.IAdmsRepository.PerformDocumentOperationAsync(System.Guid,System.Guid,ADMS.API.Models.DocumentWithoutRevisionsDto,System.String)">
            <summary>
                Performs an operation (Move or Copy) on a document.
            </summary>
            <param name="sourceMatterId">The ID of the source matter containing the document.</param>
            <param name="targetMatterId">The ID of the target matter to move or copy the document to.</param>
            <param name="document">The document to move or copy.</param>
            <param name="operationType">The type of operation to perform ("Move" or "Copy").</param>
            <returns>True if the operation was successful, false otherwise.</returns>
        </member>
        <member name="M:ADMS.API.Services.IAdmsRepository.GetDocumentActivityByActivityNameAsync(System.String)">
            <summary>
                Retrieves a DocumentActivity by its name.
            </summary>
            <param name="activityName">The name of the activity to retrieve.</param>
            <returns>The requested DocumentActivity, or null if not found.</returns>
        </member>
        <member name="M:ADMS.API.Services.IAdmsRepository.GetDocumentAuditsAsync(System.Guid)">
            <summary>
            Retrieves document audit records for a specified document, returning appropriate error responses.
            </summary>
            <param name="documentId">The ID of the document to retrieve audits for.</param>
            <returns>
            <para><see cref="T:Microsoft.AspNetCore.Mvc.OkObjectResult"/> with a list of document audit records if successful.</para>
            <para><see cref="T:Microsoft.AspNetCore.Mvc.BadRequestObjectResult"/> if the documentId is invalid.</para>
            <para><see cref="T:Microsoft.AspNetCore.Mvc.NotFoundObjectResult"/> if the document does not exist.</para>
            <para><see cref="T:Microsoft.AspNetCore.Mvc.ObjectResult"/> with status code 500 if an unexpected error occurs.</para>
            </returns>
        </member>
        <member name="M:ADMS.API.Services.IAdmsRepository.GetDocumentActivityAuditsAsync(System.Guid,ADMS.API.ResourceParameters.DocumentAuditsResourceParameters)">
            <summary>
            Retrieves a paginated list of document activity audit records (create, save, delete, restore, etc.) for a specified document.
            </summary>
            <param name="documentId">The ID of the document to retrieve audits for.</param>
            <param name="resourceParameters">Pagination and sorting information.</param>
            <returns>Paged list of document activity audit records.</returns>
        </member>
        <member name="M:ADMS.API.Services.IAdmsRepository.GetPaginatedDocumentMoveFromAuditsAsync(System.Guid,ADMS.API.ResourceParameters.DocumentAuditsResourceParameters)">
            <summary>
            Retrieves a paginated list of "move/copy FROM" audit records for a specified document.
            </summary>
            <param name="documentId">The ID of the document to retrieve move/copy FROM audits for.</param>
            <param name="resourceParameters">Pagination and sorting information.</param>
            <returns>Paged list of move/copy FROM audit records.</returns>
        </member>
        <member name="M:ADMS.API.Services.IAdmsRepository.GetPaginatedDocumentMoveToAuditsAsync(System.Guid,ADMS.API.ResourceParameters.DocumentAuditsResourceParameters)">
            <summary>
            Retrieves a paginated list of "move/copy TO" audit records for a specified document.
            </summary>
            <param name="documentId">The ID of the document to retrieve move/copy TO audits for.</param>
            <param name="resourceParameters">Pagination and sorting information.</param>
            <returns>Paged list of move/copy TO audit records.</returns>
        </member>
        <member name="M:ADMS.API.Services.IAdmsRepository.AddMatterAsync(ADMS.API.Models.MatterForCreationDto)">
            <summary>
                Adds a matter to the repository.
            </summary>
            <param name="matter">The matter to add.</param>
            <returns>The created matter, or null if the operation fails.</returns>
        </member>
        <member name="M:ADMS.API.Services.IAdmsRepository.MatterExistsAsync(System.Guid)">
            <summary>
                Checks if a matter exists.
            </summary>
            <param name="matterId">The ID of the matter to check.</param>
            <returns>True if the matter exists, false otherwise.</returns>
        </member>
        <member name="M:ADMS.API.Services.IAdmsRepository.MatterNameExistsAsync(System.String)">
            <summary>
               Checks if a matter name already exists.
            </summary>
            <param name="matterName">Matter name to check.</param>
            <returns>True if name exists, false otherwise</returns>
        </member>
        <member name="M:ADMS.API.Services.IAdmsRepository.DeleteMatterAsync(ADMS.API.Models.MatterDto)">
            <summary>
               Deletes the specified matter.
            </summary>
            <param name="matterToDelete">Matter to be deleted</param>
            <returns>true if deleted, false otherwise</returns>
        </member>
        <member name="M:ADMS.API.Services.IAdmsRepository.GetPaginatedMattersAsync(ADMS.API.ResourceParameters.MattersResourceParameters)">
            <summary>
                Retrieves a paginated list of matters based on the specified resource parameters.
            </summary>
            <param name="resourceParameters">The parameters for pagination, filtering, and sorting.</param>
            <returns>A paginated list of matters.</returns>
        </member>
        <member name="M:ADMS.API.Services.IAdmsRepository.GetMatterAsync(System.Guid,System.Boolean,System.Boolean)">
            <summary>
                Retrieves a matter by its ID, optionally including documents and history.
            </summary>
            <param name="matterId">The ID of the matter to retrieve.</param>
            <param name="includeDocuments">Whether to include documents in the result.</param>
            <param name="includeHistory">Whether to include history in the result.</param>
            <returns>The requested matter, or null if not found.</returns>
        </member>
        <member name="M:ADMS.API.Services.IAdmsRepository.RestoreMatterAsync(System.Guid)">
            <summary>
                Restores a deleted matter.
            </summary>
            <param name="matterId">The ID of the matter to restore.</param>
            <returns>True if the matter was successfully restored, false otherwise.</returns>
        </member>
        <member name="M:ADMS.API.Services.IAdmsRepository.UpdateMatterAsync(System.Guid,ADMS.API.Models.MatterForUpdateDto)">
            <summary>
            Updates a specified matter with new data and logs the update as an audit activity.
            </summary>
            <param name="matterId">The ID of the matter to update.</param>
            <param name="matterToUpdate">The updated matter data.</param>
            <returns>The updated matter, or null if the operation fails.</returns>
        </member>
        <member name="M:ADMS.API.Services.IAdmsRepository.AddRevisionAsync(System.Guid,ADMS.API.Models.RevisionDto)">
            <summary>
                Adds a revision to the specified document.
            </summary>
            <param name="documentId">The ID of the document to add the revision to.</param>
            <param name="revision">The revision to add.</param>
            <returns>The created revision, or null if the operation fails.</returns>
        </member>
        <member name="M:ADMS.API.Services.IAdmsRepository.RevisionExistsAsync(System.Guid)">
            <summary>
                Checks if a revision exists.
            </summary>
            <param name="revisionId">The ID of the revision to check.</param>
            <returns>True if the revision exists, false otherwise.</returns>
        </member>
        <member name="M:ADMS.API.Services.IAdmsRepository.DeleteRevisionAsync(ADMS.API.Models.RevisionDto)">
            <summary>
                Deletes a revision from a document.
            </summary>
            <param name="revision">The revision to be deleted.</param>
            <returns>True if the revision was successfully deleted, false otherwise.</returns>
        </member>
        <member name="M:ADMS.API.Services.IAdmsRepository.GetRevisionByIdAsync(System.Guid,System.Boolean)">
            <summary>
                Retrieves a revision by its ID.
            </summary>
            <param name="revisionId">The ID of the revision to retrieve.</param>
            <param name="includeHistory">Include revision history in retrieved data.</param>
            <returns>The requested revision, or null if not found.</returns>
        </member>
        <member name="M:ADMS.API.Services.IAdmsRepository.GetRevisionsAsync(System.Guid,System.Boolean,System.String)">
            <summary>
                Retrieves a list of revisions for a specified document.
            </summary>
            <param name="documentId">The ID of the document to retrieve revisions for.</param>
            <param name="includeDeleted">Whether to include deleted revisions.</param>
            <param name="orderBy">Optional order by clause.</param>
            <returns>A list of revisions.</returns>
        </member>
        <member name="M:ADMS.API.Services.IAdmsRepository.GetPaginatedRevisionsAsync(System.Guid,ADMS.API.ResourceParameters.RevisionsResourceParameters)">
            <summary>
               Retrieves a paginated list of revisions for a specified document.
            </summary>
            <param name="documentId">Document ID containing the Revisions.</param>
            <param name="resourceParameters">Parameters to be sent to perform pagination / sorting, etc.</param>
            <returns>Paged list of revisions</returns>
        </member>
        <member name="M:ADMS.API.Services.IAdmsRepository.UpdateRevisionAsync(System.Guid,System.Guid,System.Guid,ADMS.API.Entities.Revision)">
            <summary>
                Updates a revision with new details.
            </summary>
            <param name="matterId">The ID of the matter containing the revision.</param>
            <param name="documentId">The ID of the document containing the revision.</param>
            <param name="revisionId">The ID of the revision to update.</param>
            <param name="revision">The revision details to update.</param>
            <returns>The updated revision, or null if the operation fails.</returns>
        </member>
        <member name="T:ADMS.API.Services.IBatchEntityValidator">
            <summary>
            Defines the contract for enterprise-grade batch entity validation services providing efficient multi-entity verification.
            </summary>
            <remarks>
            <para>This interface provides specialized batch validation capabilities including:</para>
            
            <para><strong>Core Batch Validation Features:</strong></para>
            <list type="bullet">
            <item>High-performance batch entity existence checking across multiple types</item>
            <item>Single database round-trip optimization for multiple entity validation</item>
            <item>Parallel processing of different entity type validations</item>
            <item>Comprehensive result reporting with detailed entity breakdown</item>
            <item>Memory-efficient processing of large entity collections</item>
            </list>
            
            <para><strong>Performance Optimization:</strong></para>
            <list type="bullet">
            <item>Optimized database queries using IN clauses and parallel execution</item>
            <item>Intelligent query batching to minimize database round-trips</item>
            <item>Support for large-scale entity validation operations</item>
            <item>Configurable batch size limits for memory management</item>
            <item>Integration with caching strategies for repeated validations</item>
            </list>
            
            <para><strong>Business Rule Integration:</strong></para>
            <list type="bullet">
            <item>Support for complex multi-entity business rule validation</item>
            <item>Atomic validation of related entity groups</item>
            <item>Cross-entity dependency validation</item>
            <item>Workflow-based validation scenarios</item>
            <item>Data integrity enforcement across entity boundaries</item>
            </list>
            
            <para><strong>Scalability and Reliability:</strong></para>
            <list type="bullet">
            <item>Horizontal scaling support for high-volume validation</item>
            <item>Circuit breaker patterns for resilience</item>
            <item>Retry mechanisms for transient failures</item>
            <item>Load balancing across multiple validation instances</item>
            <item>Comprehensive error handling and recovery</item>
            </list>
            
            <para><strong>Monitoring and Observability:</strong></para>
            <list type="bullet">
            <item>Real-time performance metrics and monitoring</item>
            <item>Detailed operation tracking and analytics</item>
            <item>Health check integration for operational monitoring</item>
            <item>Alert threshold support for proactive monitoring</item>
            <item>Integration with application performance monitoring tools</item>
            </list>
            
            <para><strong>Integration Scenarios:</strong></para>
            <list type="bullet">
            <item>Bulk data import and validation workflows</item>
            <item>Multi-entity API operations requiring validation</item>
            <item>Workflow orchestration with entity dependencies</item>
            <item>Data migration and synchronization processes</item>
            <item>Batch processing and ETL operations</item>
            </list>
            </remarks>
            <example>
            <code>
            // Service registration and configuration
            services.Configure&lt;BatchValidationOptions&gt;(configuration.GetSection("BatchValidation"));
            services.AddScoped&lt;IBatchEntityValidator, BatchEntityValidator&gt;();
            
            // Usage in document service for bulk operations
            public class DocumentService
            {
                private readonly IBatchEntityValidator _batchValidator;
                
                public async Task&lt;BulkOperationResult&gt; CreateMultipleDocumentsAsync(
                    IEnumerable&lt;DocumentCreationRequest&gt; requests,
                    CancellationToken cancellationToken = default)
                {
                    var matterIds = requests.Select(r => r.MatterId).Distinct();
                    
                    var validationResult = await _batchValidator.ValidateEntitiesExistAsync(
                        matterIds, Array.Empty&lt;Guid&gt;(), Array.Empty&lt;Guid&gt;(), cancellationToken);
                        
                    if (!validationResult.AllEntitiesExist)
                    {
                        return BulkOperationResult.Failed(
                            $"Invalid matters: {validationResult.GetMissingEntitiesDescription()}");
                    }
                    
                    return await ProcessBulkDocumentCreation(requests, cancellationToken);
                }
            }
            </code>
            </example>
        </member>
        <member name="M:ADMS.API.Services.IBatchEntityValidator.ValidateEntitiesExistAsync(System.Collections.Generic.IEnumerable{System.Guid},System.Collections.Generic.IEnumerable{System.Guid},System.Collections.Generic.IEnumerable{System.Guid},System.Threading.CancellationToken)">
            <summary>
            Asynchronously validates the existence of multiple entities across different types in a single operation.
            </summary>
            <param name="matterIds">
            A collection of matter IDs to validate for existence.
            Can be empty if no matter validation is required.
            All IDs must be valid GUIDs representing matter entities.
            Supports up to the configured maximum batch size.
            </param>
            <param name="documentIds">
            A collection of document IDs to validate for existence.
            Can be empty if no document validation is required.
            All IDs must be valid GUIDs representing document entities.
            Supports up to the configured maximum batch size.
            </param>
            <param name="revisionIds">
            A collection of revision IDs to validate for existence.
            Can be empty if no revision validation is required.
            All IDs must be valid GUIDs representing revision entities.
            Supports up to the configured maximum batch size.
            </param>
            <param name="cancellationToken">
            Optional cancellation token to allow cancellation of the batch validation operation.
            Implementations should respect cancellation requests for responsive operations.
            </param>
            <returns>
            A task that represents the asynchronous batch validation operation.
            The task result contains a <see cref="T:ADMS.API.Services.BatchEntityValidationResult"/> with comprehensive validation information including:
            - Overall validation status indicating if all entities exist
            - Detailed breakdown of existing vs missing entities by type
            - Performance metrics and operation metadata
            - Human-readable descriptions for error reporting
            </returns>
            <remarks>
            <para>This method provides efficient batch validation including:</para>
            
            <para><strong>Performance Optimization:</strong></para>
            <list type="bullet">
            <item>Single database round-trip for multiple entity validation</item>
            <item>Parallel processing of different entity types when possible</item>
            <item>Optimized queries using IN clauses for efficient database operations</item>
            <item>Intelligent query batching based on database capabilities</item>
            <item>Memory-efficient processing of large entity collections</item>
            </list>
            
            <para><strong>Validation Features:</strong></para>
            <list type="bullet">
            <item>Comprehensive existence checking across all supported entity types</item>
            <item>Detailed results indicating which specific entities exist or are missing</item>
            <item>Support for soft-delete filtering and entity state validation</item>
            <item>Integration with caching strategies for improved performance</item>
            <item>Atomic validation ensuring consistent results across all entities</item>
            </list>
            
            <para><strong>Security and Access Control:</strong></para>
            <list type="bullet">
            <item>Integration with security context for entity access validation</item>
            <item>Support for role-based entity visibility filtering</item>
            <item>Audit logging for batch validation activities</item>
            <item>Prevention of information disclosure through validation responses</item>
            <item>Multi-tenant support with proper data isolation</item>
            </list>
            </remarks>
            <exception cref="T:System.ArgumentNullException">
            Thrown when any entity ID collection is <c>null</c>.
            </exception>
            <exception cref="T:System.ArgumentException">
            Thrown when any entity ID collection contains invalid GUIDs (<see cref="F:System.Guid.Empty"/>)
            or when the total number of entities exceeds the configured maximum batch size.
            </exception>
            <exception cref="T:System.OperationCanceledException">
            Thrown when the operation is canceled via the <paramref name="cancellationToken"/>.
            </exception>
            <exception cref="T:System.InvalidOperationException">
            Thrown when the batch validator is not properly configured or when database
            connectivity issues prevent the validation operation from completing.
            </exception>
            <example>
            <code>
            // Basic batch validation
            var matterIds = new[] { Guid.NewGuid(), Guid.NewGuid() };
            var documentIds = new[] { Guid.NewGuid(), Guid.NewGuid(), Guid.NewGuid() };
            var revisionIds = new[] { Guid.NewGuid() };
            
            var result = await _batchValidator.ValidateEntitiesExistAsync(
                matterIds, documentIds, revisionIds);
                
            if (!result.AllEntitiesExist)
            {
                Console.WriteLine($"Missing entities: {result.GetMissingEntitiesDescription()}");
                Console.WriteLine($"Total missing: {result.GetTotalMissingCount()}");
            }
            
            // Integration with bulk operations
            public async Task&lt;BulkProcessingResult&gt; ProcessEntitiesAsync(
                IEnumerable&lt;EntityProcessingRequest&gt; requests)
            {
                var matterIds = requests.Select(r => r.MatterId).Distinct();
                var documentIds = requests.Select(r => r.DocumentId).Distinct().Where(id => id != Guid.Empty);
                
                var validation = await _batchValidator.ValidateEntitiesExistAsync(
                    matterIds, documentIds, Array.Empty&lt;Guid&gt;());
                    
                if (!validation.AllEntitiesExist)
                {
                    return BulkProcessingResult.ValidationFailed(validation);
                }
                
                return await ProcessValidatedEntities(requests);
            }
            </code>
            </example>
        </member>
        <member name="M:ADMS.API.Services.IBatchEntityValidator.ValidateRelationshipsAsync(System.Collections.Generic.IEnumerable{System.ValueTuple{System.Guid,System.Guid}},System.Collections.Generic.IEnumerable{System.ValueTuple{System.Guid,System.Guid}},System.Threading.CancellationToken)">
            <summary>
            Asynchronously validates entity relationships in batch operations.
            </summary>
            <param name="documentMatterPairs">
            A collection of document-matter ID pairs to validate for proper relationships.
            Each tuple represents a (MatterId, DocumentId) relationship that should exist.
            Can be empty if no document-matter relationship validation is required.
            All IDs must be valid GUIDs representing existing entities.
            </param>
            <param name="revisionDocumentPairs">
            A collection of revision-document ID pairs to validate for proper relationships.
            Each tuple represents a (DocumentId, RevisionId) relationship that should exist.
            Can be empty if no revision-document relationship validation is required.
            All IDs must be valid GUIDs representing existing entities.
            </param>
            <param name="cancellationToken">
            Optional cancellation token to allow cancellation of the batch relationship validation.
            </param>
            <returns>
            A task that represents the asynchronous batch relationship validation operation.
            The task result contains a <see cref="T:ADMS.API.Services.BatchRelationshipValidationResult"/> with comprehensive information including:
            - Overall validation status indicating if all relationships are valid
            - Detailed breakdown of valid vs invalid relationships by type
            - Performance metrics and operation metadata
            - Human-readable descriptions for error reporting and troubleshooting
            </returns>
            <remarks>
            <para>This method provides comprehensive relationship validation including:</para>
            
            <para><strong>Relationship Validation Features:</strong></para>
            <list type="bullet">
            <item>Document-matter ownership validation ensuring proper entity hierarchy</item>
            <item>Revision-document relationship validation for version control integrity</item>
            <item>Batch processing for efficient relationship verification</item>
            <item>Cross-entity reference integrity validation</item>
            <item>Support for complex relationship dependency validation</item>
            </list>
            
            <para><strong>Performance and Efficiency:</strong></para>
            <list type="bullet">
            <item>Optimized database queries using JOIN operations for relationship checking</item>
            <item>Parallel processing of different relationship types when possible</item>
            <item>Single database round-trip for multiple relationship validation</item>
            <item>Intelligent query optimization based on relationship complexity</item>
            <item>Memory-efficient processing of large relationship collections</item>
            </list>
            
            <para><strong>Data Integrity and Consistency:</strong></para>
            <list type="bullet">
            <item>Referential integrity validation across related entities</item>
            <item>Support for soft-delete filtering in relationship validation</item>
            <item>Temporal consistency checking for entity lifecycle relationships</item>
            <item>Transaction isolation support for consistent relationship state</item>
            <item>Integration with entity existence validation for comprehensive checking</item>
            </list>
            </remarks>
            <exception cref="T:System.ArgumentNullException">
            Thrown when any relationship collection is <c>null</c>.
            </exception>
            <exception cref="T:System.ArgumentException">
            Thrown when relationship pairs contain invalid GUIDs or when the total number
            of relationships exceeds the configured maximum batch size.
            </exception>
            <exception cref="T:System.OperationCanceledException">
            Thrown when the operation is canceled via the <paramref name="cancellationToken"/>.
            </exception>
            <exception cref="T:System.InvalidOperationException">
            Thrown when the batch validator is not properly configured for relationship validation.
            </exception>
            <example>
            <code>
            // Document-matter relationship validation
            var documentMatterPairs = new[]
            {
                (matterId1, documentId1),
                (matterId1, documentId2),
                (matterId2, documentId3)
            };
            
            var result = await _batchValidator.ValidateRelationshipsAsync(
                documentMatterPairs, Array.Empty&lt;(Guid, Guid)&gt;());
                
            if (!result.AllRelationshipsValid)
            {
                Console.WriteLine($"Invalid relationships: {result.GetInvalidRelationshipsDescription()}");
                
                foreach (var invalidPair in result.InvalidDocumentMatterPairs)
                {
                    _logger.LogWarning("Document {DocumentId} does not belong to Matter {MatterId}",
                        invalidPair.DocumentId, invalidPair.MatterId);
                }
            }
            
            // Integration with bulk operations
            public async Task&lt;BulkUpdateResult&gt; UpdateDocumentHierarchyAsync(
                IEnumerable&lt;HierarchyUpdateRequest&gt; updates)
            {
                var docMatterPairs = updates.Select(u => (u.MatterId, u.DocumentId)).Distinct();
                var revDocPairs = updates.Select(u => (u.DocumentId, u.RevisionId)).Distinct();
                
                var relationshipValidation = await _batchValidator.ValidateRelationshipsAsync(
                    docMatterPairs, revDocPairs);
                    
                if (!relationshipValidation.AllRelationshipsValid)
                {
                    return BulkUpdateResult.InvalidRelationships(relationshipValidation);
                }
                
                return await ProcessHierarchyUpdates(updates);
            }
            </code>
            </example>
        </member>
        <member name="M:ADMS.API.Services.IBatchEntityValidator.ValidateComprehensiveAsync(ADMS.API.Services.ComprehensiveValidationRequest,System.Threading.CancellationToken)">
            <summary>
            Asynchronously validates entities and their relationships in a single comprehensive operation.
            </summary>
            <param name="request">
            A comprehensive validation request containing entity IDs and relationship pairs to validate.
            Includes configuration options for the validation operation and metadata for tracking.
            Must not be <c>null</c> and should contain valid entity IDs and relationship pairs.
            </param>
            <param name="cancellationToken">
            Optional cancellation token to allow cancellation of the comprehensive validation operation.
            </param>
            <returns>
            A task that represents the asynchronous comprehensive validation operation.
            The task result contains a <see cref="T:ADMS.API.Services.ComprehensiveValidationResult"/> combining both entity and relationship validation.
            </returns>
            <remarks>
            <para>This method provides a comprehensive validation approach that combines:</para>
            
            <para><strong>Integrated Validation Features:</strong></para>
            <list type="bullet">
            <item>Entity existence validation across all types in a single operation</item>
            <item>Relationship validation for complex hierarchies</item>
            <item>Performance optimization through single-operation processing</item>
            <item>Detailed result breakdown for comprehensive error reporting</item>
            <item>Atomic validation ensuring consistency across all validations</item>
            </list>
            
            <para><strong>Performance Benefits:</strong></para>
            <list type="bullet">
            <item>Reduced database round-trips through combined validation</item>
            <item>Optimized query execution for related validations</item>
            <item>Memory-efficient processing of complex validation scenarios</item>
            <item>Parallel processing where possible for better throughput</item>
            </list>
            
            <para><strong>Use Cases:</strong></para>
            <list type="bullet">
            <item>Complex business operations requiring full entity hierarchy validation</item>
            <item>Data import processes with comprehensive validation requirements</item>
            <item>Workflow operations with multiple entity dependencies</item>
            <item>API operations requiring complete validation before processing</item>
            </list>
            </remarks>
            <exception cref="T:System.ArgumentNullException">
            Thrown when <paramref name="request"/> is <c>null</c>.
            </exception>
            <exception cref="T:System.ArgumentException">
            Thrown when the request contains invalid data or exceeds validation limits.
            </exception>
            <exception cref="T:System.OperationCanceledException">
            Thrown when the operation is canceled via the <paramref name="cancellationToken"/>.
            </exception>
            <exception cref="T:System.InvalidOperationException">
            Thrown when the service is not properly configured for comprehensive validation.
            </exception>
            <example>
            <code>
            var request = new ComprehensiveValidationRequest
            {
                MatterIds = new[] { matterId1, matterId2 },
                DocumentIds = new[] { docId1, docId2, docId3 },
                RevisionIds = new[] { revId1, revId2 },
                DocumentMatterPairs = new[] { (matterId1, docId1), (matterId2, docId2) },
                RevisionDocumentPairs = new[] { (docId1, revId1), (docId2, revId2) },
                ValidateRelationships = true,
                IncludeMetadata = true
            };
            
            var result = await _batchValidator.ValidateComprehensiveAsync(request);
            
            if (!result.IsValid)
            {
                Console.WriteLine($"Validation failed: {result.GetValidationSummary()}");
                return BadRequest(result);
            }
            
            // Continue with business operation
            return await ProcessValidatedEntities(request);
            </code>
            </example>
        </member>
        <member name="M:ADMS.API.Services.IBatchEntityValidator.ValidateFileNamesAsync(System.Collections.Generic.IEnumerable{ADMS.API.Services.FileNameValidationRequest},System.Threading.CancellationToken)">
            <summary>
            Asynchronously validates file name uniqueness across multiple matters in batch.
            </summary>
            <param name="fileNameValidationRequests">
            A collection of file name validation requests, each containing a matter ID and file name to check.
            Used for bulk validation of file name conflicts across different matters.
            Must not be <c>null</c> and should contain valid file name validation requests.
            </param>
            <param name="cancellationToken">
            Optional cancellation token for the batch file name validation operation.
            </param>
            <returns>
            A task that represents the asynchronous batch file name validation operation.
            The task result contains a <see cref="T:ADMS.API.Services.BatchFileNameValidationResult"/> with detailed information 
            about file name conflicts and availability.
            </returns>
            <remarks>
            <para>This method provides efficient batch file name validation including:</para>
            
            <para><strong>Conflict Detection Features:</strong></para>
            <list type="bullet">
            <item>Bulk file name conflict detection across multiple matters</item>
            <item>Optimized database queries for file name uniqueness checking</item>
            <item>Support for case-sensitive and case-insensitive file name comparison</item>
            <item>Integration with matter-scoped file naming policies</item>
            <item>Detection of various conflict types (exact, normalized, reserved names)</item>
            </list>
            
            <para><strong>Performance Optimization:</strong></para>
            <list type="bullet">
            <item>Batch processing for reduced database overhead</item>
            <item>Intelligent query optimization for file name lookups</item>
            <item>Memory-efficient processing of large file name collections</item>
            <item>Parallel validation across different matters when possible</item>
            </list>
            
            <para><strong>Business Rule Support:</strong></para>
            <list type="bullet">
            <item>Matter-scoped file naming policy enforcement</item>
            <item>Reserved file name detection and prevention</item>
            <item>File name normalization and conflict resolution</item>
            <item>Integration with document management workflows</item>
            </list>
            </remarks>
            <exception cref="T:System.ArgumentNullException">
            Thrown when <paramref name="fileNameValidationRequests"/> is <c>null</c>.
            </exception>
            <exception cref="T:System.ArgumentException">
            Thrown when the collection contains invalid requests or exceeds batch size limits.
            </exception>
            <exception cref="T:System.OperationCanceledException">
            Thrown when the operation is canceled via the <paramref name="cancellationToken"/>.
            </exception>
            <exception cref="T:System.InvalidOperationException">
            Thrown when the service is not properly configured for file name validation.
            </exception>
            <example>
            <code>
            var requests = new[]
            {
                new FileNameValidationRequest { MatterId = matterId1, FileName = "document1.pdf" },
                new FileNameValidationRequest { MatterId = matterId1, FileName = "document2.docx" },
                new FileNameValidationRequest { MatterId = matterId2, FileName = "contract.pdf" }
            };
            
            var result = await _batchValidator.ValidateFileNamesAsync(requests);
            
            if (result.HasConflicts)
            {
                foreach (var conflict in result.ConflictingFileNames)
                {
                    Console.WriteLine($"File name '{conflict.FileName}' conflicts in matter {conflict.MatterId}: {conflict.ConflictType}");
                }
                
                return BadRequest(new { 
                    Message = "File name conflicts detected", 
                    Conflicts = result.ConflictingFileNames,
                    Summary = result.GetValidationSummary()
                });
            }
            
            // Continue with file operations
            return Ok(result);
            </code>
            </example>
        </member>
        <member name="M:ADMS.API.Services.IBatchEntityValidator.ValidateBulkRequestAsync(ADMS.API.Services.BulkValidationRequest,System.Threading.CancellationToken)">
            <summary>
            Asynchronously validates a bulk validation request with comprehensive entity and relationship checking.
            </summary>
            <param name="request">
            A bulk validation request containing the entities to validate and validation options.
            Must not be <c>null</c> and should pass request validation.
            </param>
            <param name="cancellationToken">
            Optional cancellation token for the bulk validation operation.
            </param>
            <returns>
            A task that represents the asynchronous bulk validation operation.
            The task result contains a <see cref="T:ADMS.API.Services.BatchEntityValidationResult"/> with validation details.
            </returns>
            <remarks>
            <para>This method provides a structured approach to bulk validation using a request object:</para>
            
            <para><strong>Request-Based Validation:</strong></para>
            <list type="bullet">
            <item>Structured request object for complex validation scenarios</item>
            <item>Built-in request validation and parameter checking</item>
            <item>Support for additional validation options and metadata</item>
            <item>Timeout configuration and operation tracking</item>
            </list>
            </remarks>
            <exception cref="T:System.ArgumentNullException">
            Thrown when <paramref name="request"/> is <c>null</c>.
            </exception>
            <exception cref="T:System.ArgumentException">
            Thrown when the request fails validation or contains invalid parameters.
            </exception>
            <exception cref="T:System.OperationCanceledException">
            Thrown when the operation is canceled via the <paramref name="cancellationToken"/>.
            </exception>
            <example>
            <code>
            var bulkRequest = new BulkValidationRequest
            {
                MatterIds = matterIds,
                DocumentIds = documentIds,
                RevisionIds = revisionIds,
                ValidateRelationships = false,
                IncludeMetadata = true,
                TimeoutMilliseconds = 30000
            };
            
            var validationErrors = bulkRequest.ValidateRequest();
            if (validationErrors.Any())
            {
                return BadRequest(validationErrors);
            }
            
            var result = await _batchValidator.ValidateBulkRequestAsync(bulkRequest);
            return Ok(result);
            </code>
            </example>
        </member>
        <!-- Badly formed XML comment ignored for member "M:ADMS.API.Services.IBatchEntityValidator.GetPerformanceMetrics" -->
        <member name="M:ADMS.API.Services.IBatchEntityValidator.CheckHealthAsync(System.Threading.CancellationToken)">
            <summary>
            Asynchronously performs a comprehensive health check of the batch validation service.
            </summary>
            <param name="cancellationToken">
            Optional cancellation token for the health check operation.
            </param>
            <returns>
            A task that represents the asynchronous health check operation.
            The task result contains a <see cref="T:ADMS.API.Services.BatchValidationHealthResult"/> with detailed health information 
            about the batch validation service.
            </returns>
            <remarks>
            <para>This method provides comprehensive health validation including:</para>
            
            <para><strong>System Health Checks:</strong></para>
            <list type="bullet">
            <item>Database connectivity and performance validation</item>
            <item>Service configuration and dependency health</item>
            <item>Performance metrics and threshold validation</item>
            <item>Resource availability and capacity assessment</item>
            <item>Integration point health and connectivity</item>
            </list>
            
            <para><strong>Performance Health:</strong></para>
            <list type="bullet">
            <item>Response time and throughput health indicators</item>
            <item>Error rate and success rate trend analysis</item>
            <item>Resource utilization and capacity health</item>
            <item>Cache performance and effectiveness metrics</item>
            </list>
            
            <para><strong>Integration Benefits:</strong></para>
            <list type="bullet">
            <item>Compatible with ASP.NET Core health check framework</item>
            <item>Suitable for container orchestration health probes</item>
            <item>Integration with monitoring and alerting systems</item>
            <item>Support for custom health check extensions</item>
            </list>
            </remarks>
            <exception cref="T:System.OperationCanceledException">
            Thrown when the operation is canceled via the <paramref name="cancellationToken"/>.
            </exception>
            <example>
            <code>
            // Basic health check
            var health = await _batchValidator.CheckHealthAsync();
            
            Console.WriteLine($"Health Status: {health.GetHealthStatus()}");
            Console.WriteLine($"Health Score: {health.HealthScore:P2}");
            Console.WriteLine($"Is Healthy: {health.IsHealthy}");
            
            if (!health.IsHealthy)
            {
                Console.WriteLine($"Health issues: {string.Join(", ", health.Issues)}");
                _logger.LogWarning("Batch validator health issues detected: {Issues}", health.Issues);
            }
            
            if (health.LastSuccessfulOperation.HasValue)
            {
                var timeSinceLastSuccess = DateTimeOffset.UtcNow - health.LastSuccessfulOperation.Value;
                if (timeSinceLastSuccess > TimeSpan.FromMinutes(10))
                {
                    _logger.LogWarning("No successful operations for {Duration}", timeSinceLastSuccess);
                }
            }
            
            // Health check integration with ASP.NET Core
            public void ConfigureServices(IServiceCollection services)
            {
                services.AddHealthChecks()
                    .AddCheck&lt;BatchValidatorHealthCheck&gt;("batch-validator");
            }
            </code>
            </example>
        </member>
        <member name="M:ADMS.API.Services.IBatchEntityValidator.GetRealTimeStatistics">
            <summary>
            Gets real-time performance statistics for the batch validation service.
            </summary>
            <returns>
            A dictionary containing real-time performance statistics including current throughput,
            active operation count, recent error rates, and resource utilization metrics.
            </returns>
            <remarks>
            <para>This method provides real-time operational insights for:</para>
            
            <para><strong>Real-Time Metrics:</strong></para>
            <list type="bullet">
            <item>Current active operations and queue depths</item>
            <item>Recent throughput and response time statistics</item>
            <item>Current error rates and success percentages</item>
            <item>Resource utilization and capacity indicators</item>
            </list>
            
            <para><strong>Operational Visibility:</strong></para>
            <list type="bullet">
            <item>Live monitoring dashboard integration</item>
            <item>Real-time alerting and threshold monitoring</item>
            <item>Performance trending and anomaly detection</item>
            <item>Capacity planning and scaling indicators</item>
            </list>
            </remarks>
            <example>
            <code>
            var stats = _batchValidator.GetRealTimeStatistics();
            
            if (stats.TryGetValue("CurrentThroughput", out var throughput))
            {
                Console.WriteLine($"Current throughput: {throughput} ops/sec");
            }
            
            if (stats.TryGetValue("ActiveOperations", out var activeOps))
            {
                Console.WriteLine($"Active operations: {activeOps}");
            }
            
            if (stats.TryGetValue("RecentErrorRate", out var errorRate))
            {
                Console.WriteLine($"Recent error rate: {errorRate:P2}");
            }
            </code>
            </example>
        </member>
        <member name="M:ADMS.API.Services.IBatchEntityValidator.GetConfiguration">
            <summary>
            Gets the current configuration settings for the batch validation service.
            </summary>
            <returns>
            A <see cref="T:ADMS.API.Services.BatchValidationOptions"/> object containing current configuration settings including
            batch size limits, timeout values, performance thresholds, and operational parameters.
            </returns>
            <remarks>
            <para>This method provides access to current service configuration for:</para>
            
            <para><strong>Configuration Access:</strong></para>
            <list type="bullet">
            <item>Runtime configuration validation and verification</item>
            <item>Dynamic configuration adjustment recommendations</item>
            <item>Integration with configuration management systems</item>
            <item>Operational visibility into service behavior</item>
            <item>Troubleshooting and diagnostic information</item>
            </list>
            
            <para><strong>Operational Benefits:</strong></para>
            <list type="bullet">
            <item>Configuration drift detection and monitoring</item>
            <item>Performance tuning and optimization guidance</item>
            <item>Compliance and governance reporting</item>
            <item>Change management and audit trails</item>
            </list>
            </remarks>
            <example>
            <code>
            var config = _batchValidator.GetConfiguration();
            
            Console.WriteLine($"Max batch size: {config.MaxBatchSize}");
            Console.WriteLine($"Timeout: {config.BatchTimeoutSeconds}s");
            Console.WriteLine($"Parallel processing: {config.EnableParallelProcessing}");
            Console.WriteLine($"Max parallelism: {config.MaxDegreeOfParallelism}");
            Console.WriteLine($"Caching enabled: {config.EnableCaching}");
            Console.WriteLine($"Cache expiration: {config.CacheExpirationMinutes}min");
            
            // Validate configuration
            var configErrors = config.Validate();
            if (configErrors.Any())
            {
                _logger.LogWarning("Configuration issues detected: {Issues}", configErrors);
            }
            
            // Performance optimization recommendations
            if (config.MaxBatchSize > 5000)
            {
                _logger.LogInformation("Consider reducing batch size for better memory utilization");
            }
            </code>
            </example>
        </member>
        <member name="M:ADMS.API.Services.IBatchEntityValidator.ClearCache(System.String)">
            <summary>
            Clears any cached validation results and performance metrics to reset service state.
            </summary>
            <param name="cacheType">
            Optional parameter to specify which cache type to clear.
            Supported values: "ValidationResults", "PerformanceMetrics", "All".
            If <c>null</c> or "All", clears all cached data.
            </param>
            <remarks>
            <para>This method is useful for:</para>
            
            <para><strong>Operational Scenarios:</strong></para>
            <list type="bullet">
            <item>Memory optimization in long-running applications</item>
            <item>Testing scenarios requiring clean service state</item>
            <item>Performance benchmark preparation</item>
            <item>Cache invalidation after configuration changes</item>
            <item>Troubleshooting scenarios requiring fresh state</item>
            </list>
            
            <para><strong>Cache Management:</strong></para>
            <list type="bullet">
            <item>Selective cache clearing by type</item>
            <item>Complete cache reset when needed</item>
            <item>Memory pressure relief mechanisms</item>
            <item>Development and testing support</item>
            </list>
            </remarks>
            <example>
            <code>
            // Clear all caches for memory optimization
            _batchValidator.ClearCache();
            
            // Clear only validation result cache
            _batchValidator.ClearCache("ValidationResults");
            
            // Clear only performance metrics
            _batchValidator.ClearCache("PerformanceMetrics");
            
            // Verify cache is cleared
            var metrics = _batchValidator.GetPerformanceMetrics();
            Console.WriteLine($"Operations after clear: {metrics.TotalBatchOperations}");
            
            // Memory management scenario
            var beforeMemory = GC.GetTotalMemory(false);
            _batchValidator.ClearCache();
            GC.Collect();
            var afterMemory = GC.GetTotalMemory(true);
            Console.WriteLine($"Memory freed: {(beforeMemory - afterMemory) / 1024 / 1024:F2} MB");
            </code>
            </example>
        </member>
        <member name="M:ADMS.API.Services.IBatchEntityValidator.ValidateConfiguration">
            <summary>
            Validates the service configuration and returns any configuration issues.
            </summary>
            <returns>
            A collection of configuration validation messages. Empty if configuration is valid.
            </returns>
            <remarks>
            <para>This method provides configuration validation including:</para>
            
            <para><strong>Configuration Checks:</strong></para>
            <list type="bullet">
            <item>Parameter range and format validation</item>
            <item>Dependency and integration point validation</item>
            <item>Performance threshold and limit validation</item>
            <item>Security and access control configuration</item>
            </list>
            </remarks>
            <example>
            <code>
            var configIssues = _batchValidator.ValidateConfiguration();
            if (configIssues.Any())
            {
                _logger.LogWarning("Configuration issues detected: {Issues}", 
                    string.Join("; ", configIssues));
            }
            </code>
            </example>
        </member>
        <member name="T:ADMS.API.Services.IFileStorage">
            <summary>
            Defines the contract for enterprise-grade file storage services providing comprehensive file management capabilities.
            </summary>
            <remarks>
            This interface provides a comprehensive contract for file storage implementations including:
            
            Core File Storage Capabilities:
            - Asynchronous file saving and retrieval operations with cancellation support
            - High-performance file operations optimized for large file processing
            - Comprehensive error handling and detailed diagnostic information
            - Support for multiple storage backends (local, cloud, network, database)
            - Thread-safe operations for concurrent file management scenarios
            
            Storage Backend Support:
            - Local file system storage with directory management
            - Cloud storage integration (Azure Blob, AWS S3, Google Cloud)
            - Network attached storage (NAS) and shared file systems
            - Database binary large object (BLOB) storage
            - Hybrid storage configurations with failover support
            
            Security and Access Control:
            - Secure file handling with proper permission validation
            - Integration with access control and authorization systems
            - File encryption support for sensitive document storage
            - Audit logging for all file operations and access attempts
            - Compliance support for data protection and retention policies
            
            Performance and Scalability:
            - Asynchronous operations for non-blocking file processing
            - Cancellation token support for responsive user experience
            - Stream-based processing for memory-efficient large file handling
            - Configurable timeout and resource management
            - Optimized operations for high-throughput scenarios
            
            File Management Features:
            - Atomic file operations with rollback capabilities
            - File versioning and revision management support
            - Metadata management and file classification
            - Duplicate detection and content deduplication
            - Temporary file management and cleanup
            
            Integration Capabilities:
            - Seamless integration with document management systems
            - Support for file upload and download pipelines
            - Integration with virus scanning and content validation
            - Compatibility with backup and archival systems
            - API integration for external storage services
            
            Error Handling and Resilience:
            - Comprehensive error handling with detailed diagnostic information
            - Retry policies and failure recovery mechanisms
            - Storage health monitoring and availability checking
            - Graceful degradation for storage service unavailability
            - Transaction support for complex file operations
            
            Implementation Considerations:
            - Implementations should handle various storage backend types
            - Proper resource management and cleanup of temporary files
            - Thread-safe operations for concurrent file access scenarios
            - Integration with logging infrastructure for operational monitoring
            - Configuration support for storage policies and settings
            
            Common Usage Scenarios:
            - Document storage and retrieval in content management systems
            - File upload processing in web applications and APIs
            - Backup and archival operations for data protection
            - Temporary file management for processing workflows
            - Media storage and delivery for multimedia applications
            
            The interface is designed to be:
            - Extensible: Easy to implement with various storage technologies
            - Performant: Asynchronous operations with cancellation support
            - Secure: Comprehensive security and access control integration
            - Observable: Rich diagnostic information for monitoring and compliance
            - Reliable: Robust error handling and graceful degradation capabilities
            </remarks>
            <example>
            <code>
            // Basic file storage implementation
            public class MyFileStorageService : IFileStorage
            {
                public async Task&lt;FileOperationResult&gt; SaveFileAsync(
                    string path, 
                    byte[] content, 
                    CancellationToken cancellationToken = default)
                {
                    try
                    {
                        await File.WriteAllBytesAsync(path, content, cancellationToken);
                        return FileOperationResult.Success(path, content.Length);
                    }
                    catch (Exception ex)
                    {
                        return FileOperationResult.Failed(ex.Message, ex);
                    }
                }
            }
            
            // Usage in document upload controller
            [HttpPost("upload")]
            public async Task&lt;IActionResult&gt; UploadDocument(
                IFormFile file, 
                CancellationToken cancellationToken)
            {
                using var stream = new MemoryStream();
                await file.CopyToAsync(stream, cancellationToken);
                var content = stream.ToArray();
                
                var filePath = Path.Combine("documents", Guid.NewGuid() + Path.GetExtension(file.FileName));
                var result = await _fileStorage.SaveFileAsync(filePath, content, cancellationToken);
                
                if (result.IsSuccess)
                {
                    return Ok(new { FilePath = result.FilePath, Size = result.FileSize });
                }
                else
                {
                    _logger.LogError("File upload failed: {Error}", result.ErrorMessage);
                    return StatusCode(500, "File upload failed");
                }
            }
            </code>
            </example>
        </member>
        <!-- Badly formed XML comment ignored for member "M:ADMS.API.Services.IFileStorage.SaveFileAsync(System.String,System.Byte[],System.Threading.CancellationToken)" -->
        <member name="M:ADMS.API.Services.IFileStorage.SaveFileAsync(System.String,System.IO.Stream,System.Threading.CancellationToken)">
            <summary>
            Asynchronously saves content from a stream to a file at the given path with memory-efficient processing.
            </summary>
            <param name="path">
            The full file path where the stream content will be saved.
            Must be a valid file path that is accessible for write operations.
            Directory structure will be created automatically if it doesn't exist.
            </param>
            <param name="contentStream">
            The stream containing the content to be written to the file.
            Stream must be readable and positioned at the beginning of the content.
            Stream will be consumed completely and should remain open during the operation.
            </param>
            <param name="cancellationToken">
            Optional cancellation token to allow cancellation of the save operation.
            </param>
            <returns>
            A task that represents the asynchronous save operation with comprehensive result information.
            </returns>
            <remarks>
            This method provides memory-efficient file saving for large files by:
            - Using stream-based operations to minimize memory usage
            - Supporting files larger than available system memory
            - Providing optimal performance for large file transfers
            - Maintaining low memory footprint during processing
            </remarks>
            <example>
            <code>
            // Stream-based file saving for large files
            using var fileStream = File.OpenRead(sourceFile);
            var result = await _fileStorage.SaveFileAsync(targetPath, fileStream, cancellationToken);
            
            if (result.IsSuccess)
            {
                Console.WriteLine($"Large file saved: {result.FileSize} bytes");
            }
            </code>
            </example>
        </member>
        <member name="M:ADMS.API.Services.IFileStorage.GetFileAsync(System.String,System.Threading.CancellationToken)">
            <summary>
            Asynchronously retrieves file content as a byte array from the specified path.
            </summary>
            <param name="path">
            The full file path from which to read the content.
            Must be a valid existing file path that is accessible for read operations.
            </param>
            <param name="cancellationToken">
            Optional cancellation token to allow cancellation of the read operation.
            </param>
            <returns>
            A task that represents the asynchronous read operation with file content and metadata.
            </returns>
            <remarks>
            This method provides comprehensive file retrieval including:
            - Atomic file reading to ensure data consistency
            - File existence validation before reading
            - Large file support with memory management
            - Comprehensive error handling for various failure scenarios
            </remarks>
            <example>
            <code>
            var result = await _fileStorage.GetFileAsync(filePath, cancellationToken);
            if (result.IsSuccess)
            {
                var content = result.Content;
                // Process file content...
            }
            </code>
            </example>
        </member>
        <member name="M:ADMS.API.Services.IFileStorage.GetFileStreamAsync(System.String,System.Threading.CancellationToken)">
            <summary>
            Asynchronously opens a stream to read file content from the specified path.
            </summary>
            <param name="path">
            The full file path from which to open the stream.
            Must be a valid existing file path that is accessible for read operations.
            </param>
            <param name="cancellationToken">
            Optional cancellation token to allow cancellation of the stream opening operation.
            </param>
            <returns>
            A task that represents the asynchronous stream opening operation.
            Returns a FileStreamResult containing the stream and metadata.
            </returns>
            <remarks>
            This method provides memory-efficient file reading for large files by:
            - Opening a stream without loading entire file into memory
            - Supporting files larger than available system memory
            - Providing optimal performance for large file operations
            - Maintaining low memory footprint during processing
            
            Important: The caller is responsible for disposing the returned stream.
            </remarks>
            <example>
            <code>
            var streamResult = await _fileStorage.GetFileStreamAsync(filePath, cancellationToken);
            if (streamResult.IsSuccess)
            {
                using var stream = streamResult.Stream;
                // Process stream content...
            }
            </code>
            </example>
        </member>
        <member name="M:ADMS.API.Services.IFileStorage.FileExistsAsync(System.String,System.Threading.CancellationToken)">
            <summary>
            Asynchronously checks whether a file exists at the specified path.
            </summary>
            <param name="path">
            The full file path to check for existence.
            Must be a valid file path format.
            </param>
            <param name="cancellationToken">
            Optional cancellation token to allow cancellation of the existence check.
            </param>
            <returns>
            A task that represents the asynchronous existence check operation.
            Returns true if the file exists and is accessible; false otherwise.
            </returns>
            <remarks>
            This method provides reliable file existence checking with:
            - Path validation and security checking
            - Access permission verification
            - Network storage connectivity validation
            - Comprehensive error handling for inaccessible files
            </remarks>
            <example>
            <code>
            bool exists = await _fileStorage.FileExistsAsync(filePath, cancellationToken);
            if (exists)
            {
                // File exists - proceed with operations
            }
            </code>
            </example>
        </member>
        <member name="M:ADMS.API.Services.IFileStorage.DeleteFileAsync(System.String,System.Threading.CancellationToken)">
            <summary>
            Asynchronously deletes a file at the specified path.
            </summary>
            <param name="path">
            The full file path of the file to delete.
            Must be a valid existing file path that is accessible for delete operations.
            </param>
            <param name="cancellationToken">
            Optional cancellation token to allow cancellation of the delete operation.
            </param>
            <returns>
            A task that represents the asynchronous delete operation with result information.
            </returns>
            <remarks>
            This method provides secure file deletion including:
            - File existence verification before deletion
            - Permission validation for delete operations
            - Atomic deletion to prevent partial file removal
            - Audit logging for security and compliance
            - Recovery recommendations for failure scenarios
            </remarks>
            <example>
            <code>
            var result = await _fileStorage.DeleteFileAsync(filePath, cancellationToken);
            if (result.IsSuccess)
            {
                _logger.LogInformation("File deleted successfully: {Path}", result.FilePath);
            }
            </code>
            </example>
        </member>
        <member name="M:ADMS.API.Services.IFileStorage.GetFileMetadataAsync(System.String,System.Threading.CancellationToken)">
            <summary>
            Asynchronously gets metadata information about a file at the specified path.
            </summary>
            <param name="path">
            The full file path for which to retrieve metadata.
            Must be a valid existing file path that is accessible for read operations.
            </param>
            <param name="cancellationToken">
            Optional cancellation token to allow cancellation of the metadata retrieval.
            </param>
            <returns>
            A task that represents the asynchronous metadata retrieval operation.
            Returns comprehensive file metadata including size, dates, and attributes.
            </returns>
            <remarks>
            This method provides comprehensive file metadata including:
            - File size and content information
            - Creation, modification, and access timestamps
            - File attributes and permissions
            - Storage backend specific metadata
            - Checksum and integrity information where available
            </remarks>
            <example>
            <code>
            var metadata = await _fileStorage.GetFileMetadataAsync(filePath, cancellationToken);
            if (metadata.IsSuccess)
            {
                Console.WriteLine($"File size: {metadata.FileSize} bytes, Modified: {metadata.LastModified}");
            }
            </code>
            </example>
        </member>
        <member name="M:ADMS.API.Services.IFileStorage.CheckStorageHealthAsync(System.Threading.CancellationToken)">
            <summary>
            Asynchronously validates whether the storage system is healthy and operational.
            </summary>
            <param name="cancellationToken">Optional cancellation token for the health check operation.</param>
            <returns>
            A task that represents the asynchronous health check operation.
            The task result contains a StorageHealthResult with comprehensive health information.
            </returns>
            <remarks>
            This method provides comprehensive storage health checking including:
            - Storage backend connectivity and availability
            - Disk space and capacity monitoring
            - Performance metrics and response times
            - Configuration validation and system requirements
            - Error rates and reliability assessment
            </remarks>
            <example>
            <code>
            var health = await _fileStorage.CheckStorageHealthAsync();
            if (health.IsHealthy)
            {
                _logger.LogInformation("Storage is healthy - Available space: {AvailableSpace} GB", 
                    health.AvailableSpaceGB);
            }
            </code>
            </example>
        </member>
        <member name="M:ADMS.API.Services.IFileStorage.GetStorageInfo">
            <summary>
            Retrieves comprehensive information about the storage system configuration and capabilities.
            </summary>
            <returns>
            A StorageInfo object containing detailed information about the storage implementation.
            </returns>
            <remarks>
            This method provides static information about the storage system including:
            - Storage backend type and configuration details
            - Supported features and capabilities
            - Performance characteristics and limitations
            - Security features and access control mechanisms
            </remarks>
            <example>
            <code>
            var storageInfo = _fileStorage.GetStorageInfo();
            _logger.LogInformation("Storage backend: {Backend}, Max file size: {MaxSize} MB",
                storageInfo.BackendType, storageInfo.MaxFileSizeMB);
            </code>
            </example>
        </member>
        <member name="T:ADMS.API.Services.FileOperationResult">
            <summary>
            Represents the result of a file operation with comprehensive status and metadata information.
            </summary>
        </member>
        <member name="P:ADMS.API.Services.FileOperationResult.IsSuccess">
            <summary>
            Gets a value indicating whether the file operation completed successfully.
            </summary>
        </member>
        <member name="P:ADMS.API.Services.FileOperationResult.FilePath">
            <summary>
            Gets the file path that was operated on.
            </summary>
        </member>
        <member name="P:ADMS.API.Services.FileOperationResult.FileSize">
            <summary>
            Gets the size of the file in bytes for successful operations.
            </summary>
        </member>
        <member name="P:ADMS.API.Services.FileOperationResult.Duration">
            <summary>
            Gets the duration of the file operation.
            </summary>
        </member>
        <member name="P:ADMS.API.Services.FileOperationResult.ErrorMessage">
            <summary>
            Gets the error message for failed operations.
            </summary>
        </member>
        <member name="P:ADMS.API.Services.FileOperationResult.ErrorDetails">
            <summary>
            Gets additional error details for troubleshooting.
            </summary>
        </member>
        <member name="P:ADMS.API.Services.FileOperationResult.Timestamp">
            <summary>
            Gets the timestamp when the operation completed.
            </summary>
        </member>
        <member name="P:ADMS.API.Services.FileOperationResult.Metadata">
            <summary>
            Gets additional operation metadata.
            </summary>
        </member>
        <member name="M:ADMS.API.Services.FileOperationResult.Success(System.String,System.Int64,System.Nullable{System.TimeSpan})">
            <summary>
            Creates a successful file operation result.
            </summary>
        </member>
        <member name="M:ADMS.API.Services.FileOperationResult.Failed(System.String,System.String)">
            <summary>
            Creates a failed file operation result.
            </summary>
        </member>
        <member name="M:ADMS.API.Services.FileOperationResult.Canceled(System.String)">
            <summary>
            Creates a canceled file operation result.
            </summary>
        </member>
        <member name="T:ADMS.API.Services.FileRetrievalResult">
            <summary>
            Represents the result of a file retrieval operation with content and metadata.
            </summary>
        </member>
        <member name="P:ADMS.API.Services.FileRetrievalResult.IsSuccess">
            <summary>
            Gets a value indicating whether the file retrieval completed successfully.
            </summary>
        </member>
        <member name="P:ADMS.API.Services.FileRetrievalResult.Content">
            <summary>
            Gets the file content as a byte array for successful retrievals.
            </summary>
        </member>
        <member name="P:ADMS.API.Services.FileRetrievalResult.FilePath">
            <summary>
            Gets the file path that was retrieved.
            </summary>
        </member>
        <member name="P:ADMS.API.Services.FileRetrievalResult.FileSize">
            <summary>
            Gets the size of the retrieved file in bytes.
            </summary>
        </member>
        <member name="P:ADMS.API.Services.FileRetrievalResult.ErrorMessage">
            <summary>
            Gets the error message for failed retrievals.
            </summary>
        </member>
        <member name="P:ADMS.API.Services.FileRetrievalResult.Metadata">
            <summary>
            Gets additional metadata about the retrieved file.
            </summary>
        </member>
        <member name="M:ADMS.API.Services.FileRetrievalResult.Success(System.String,System.Byte[])">
            <summary>
            Creates a successful file retrieval result.
            </summary>
        </member>
        <member name="M:ADMS.API.Services.FileRetrievalResult.Failed(System.String)">
            <summary>
            Creates a failed file retrieval result.
            </summary>
        </member>
        <member name="T:ADMS.API.Services.FileStreamResult">
            <summary>
            Represents the result of opening a file stream with metadata information.
            </summary>
        </member>
        <member name="P:ADMS.API.Services.FileStreamResult.IsSuccess">
            <summary>
            Gets a value indicating whether the stream opening completed successfully.
            </summary>
        </member>
        <member name="P:ADMS.API.Services.FileStreamResult.Stream">
            <summary>
            Gets the opened file stream for successful operations.
            </summary>
        </member>
        <member name="P:ADMS.API.Services.FileStreamResult.FilePath">
            <summary>
            Gets the file path for the opened stream.
            </summary>
        </member>
        <member name="P:ADMS.API.Services.FileStreamResult.FileSize">
            <summary>
            Gets the size of the file in bytes.
            </summary>
        </member>
        <member name="P:ADMS.API.Services.FileStreamResult.ErrorMessage">
            <summary>
            Gets the error message for failed operations.
            </summary>
        </member>
        <member name="M:ADMS.API.Services.FileStreamResult.Success(System.String,System.IO.Stream,System.Int64)">
            <summary>
            Creates a successful file stream result.
            </summary>
        </member>
        <member name="M:ADMS.API.Services.FileStreamResult.Failed(System.String)">
            <summary>
            Creates a failed file stream result.
            </summary>
        </member>
        <member name="M:ADMS.API.Services.FileStreamResult.Dispose">
            <summary>
            Disposes the underlying stream if it exists.
            </summary>
        </member>
        <member name="T:ADMS.API.Services.FileMetadataResult">
            <summary>
            Represents file metadata information.
            </summary>
        </member>
        <member name="P:ADMS.API.Services.FileMetadataResult.IsSuccess">
            <summary>
            Gets a value indicating whether the metadata retrieval completed successfully.
            </summary>
        </member>
        <member name="P:ADMS.API.Services.FileMetadataResult.FilePath">
            <summary>
            Gets the file path.
            </summary>
        </member>
        <member name="P:ADMS.API.Services.FileMetadataResult.FileSize">
            <summary>
            Gets the file size in bytes.
            </summary>
        </member>
        <member name="P:ADMS.API.Services.FileMetadataResult.CreatedAt">
            <summary>
            Gets the file creation timestamp.
            </summary>
        </member>
        <member name="P:ADMS.API.Services.FileMetadataResult.LastModified">
            <summary>
            Gets the file last modification timestamp.
            </summary>
        </member>
        <member name="P:ADMS.API.Services.FileMetadataResult.LastAccessed">
            <summary>
            Gets the file last access timestamp.
            </summary>
        </member>
        <member name="P:ADMS.API.Services.FileMetadataResult.Attributes">
            <summary>
            Gets file attributes and properties.
            </summary>
        </member>
        <member name="P:ADMS.API.Services.FileMetadataResult.ErrorMessage">
            <summary>
            Gets the error message for failed operations.
            </summary>
        </member>
        <member name="T:ADMS.API.Services.StorageHealthResult">
            <summary>
            Represents the health status of the storage system.
            </summary>
        </member>
        <member name="P:ADMS.API.Services.StorageHealthResult.IsHealthy">
            <summary>
            Gets a value indicating whether the storage system is healthy.
            </summary>
        </member>
        <member name="P:ADMS.API.Services.StorageHealthResult.AvailableSpaceGB">
            <summary>
            Gets the available storage space in gigabytes.
            </summary>
        </member>
        <member name="P:ADMS.API.Services.StorageHealthResult.TotalCapacityGB">
            <summary>
            Gets the total storage capacity in gigabytes.
            </summary>
        </member>
        <member name="P:ADMS.API.Services.StorageHealthResult.AverageResponseTime">
            <summary>
            Gets the average response time for storage operations.
            </summary>
        </member>
        <member name="P:ADMS.API.Services.StorageHealthResult.ErrorRate">
            <summary>
            Gets the error rate percentage for recent operations.
            </summary>
        </member>
        <member name="P:ADMS.API.Services.StorageHealthResult.HealthIssues">
            <summary>
            Gets health check error messages if unhealthy.
            </summary>
        </member>
        <member name="P:ADMS.API.Services.StorageHealthResult.HealthMetrics">
            <summary>
            Gets additional health information and metrics.
            </summary>
        </member>
        <member name="T:ADMS.API.Services.StorageInfo">
            <summary>
            Provides information about the storage system implementation.
            </summary>
        </member>
        <member name="P:ADMS.API.Services.StorageInfo.BackendType">
            <summary>
            Gets the storage backend type (e.g., "FileSystem", "AzureBlob", "AmazonS3").
            </summary>
        </member>
        <member name="P:ADMS.API.Services.StorageInfo.Version">
            <summary>
            Gets the version of the storage implementation.
            </summary>
        </member>
        <member name="P:ADMS.API.Services.StorageInfo.MaxFileSizeMB">
            <summary>
            Gets the maximum file size supported in megabytes.
            </summary>
        </member>
        <member name="P:ADMS.API.Services.StorageInfo.SupportedFeatures">
            <summary>
            Gets the supported features of this storage implementation.
            </summary>
        </member>
        <member name="P:ADMS.API.Services.StorageInfo.PerformanceCharacteristics">
            <summary>
            Gets performance characteristics of the storage system.
            </summary>
        </member>
        <member name="P:ADMS.API.Services.StorageInfo.Configuration">
            <summary>
            Gets configuration information about the storage system.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:ADMS.API.Services.IPropertyCheckerService" -->
        <member name="M:ADMS.API.Services.IPropertyCheckerService.TypeHasProperties``1(System.String)">
            <summary>
            Validates that all specified properties exist on the given type with comprehensive error handling and caching.
            </summary>
            <typeparam name="T">
            The type to validate properties against. Must be a reference type or value type with public properties.
            Common examples include DTO classes, entity classes, or any .NET type with public properties.
            The type must be accessible for reflection operations and property discovery.
            </typeparam>
            <param name="fields">
            A comma-separated string of property names to validate against the specified type.
            Supports simple property names (e.g., "Name,Email") and nested property paths (e.g., "Address.Street,User.Profile.Name").
            Null, empty, or whitespace-only values are considered valid (returns true) as no validation is required.
            Property names are matched case-insensitively for flexible API usage and improved user experience.
            Whitespace around property names is automatically trimmed for robust input handling.
            </param>
            <returns>
            true if all specified properties exist on the type T and are accessible for operations;
            false if any property does not exist, is not accessible, or if validation fails due to reflection errors.
            Returns true for null, empty, or whitespace-only field parameters as no validation is required.
            </returns>
            <remarks>
            This method provides comprehensive property validation including:
            
            Input Processing and Parsing:
            - Handles null, empty, and whitespace-only field parameters gracefully
            - Parses comma-separated field lists with robust whitespace handling
            - Trims individual field names to handle formatting variations
            - Supports flexible input formats common in API parameter usage
            - Validates input format and structure before processing
            
            Property Resolution and Discovery:
            - Uses reflection to discover public instance properties on the target type
            - Supports case-insensitive property name matching for API flexibility
            - Handles nested property paths with dot notation (e.g., "Address.Street")
            - Validates property accessibility and visibility requirements
            - Supports both simple and complex property hierarchies
            
            Caching and Performance:
            - Implements intelligent caching of reflection-based property information
            - Uses concurrent dictionaries for thread-safe cache operations
            - Provides O(1) average case lookup time for cached property information
            - Optimizes memory usage with efficient caching strategies
            - Supports high-frequency validation scenarios with minimal overhead
            
            Error Handling and Resilience:
            - Gracefully handles reflection errors and type resolution failures
            - Provides detailed logging for debugging and troubleshooting
            - Returns false for validation failures rather than throwing exceptions
            - Maintains service stability even with invalid or problematic input
            - Integrates with logging infrastructure for operational monitoring
            
            Thread Safety and Concurrency:
            - All operations are thread-safe for concurrent access scenarios
            - Uses concurrent collections to prevent race conditions
            - No shared mutable state that could cause threading issues
            - Optimized for high-concurrency web application usage
            - Supports parallel validation operations without performance degradation
            
            Security and Validation:
            - Input validation and sanitization for property name parameters
            - Protection against reflection-based attacks and injection attempts
            - Secure property access validation and filtering
            - Integration with security policies and access control
            - Audit trail support for property validation operations
            
            Supported Field Specification Formats:
            - Simple property names: "Name,Email,CreatedDate"
            - Nested property paths: "Address.Street,User.Profile.DisplayName"
            - Mixed formats: "Name,Address.Street,Email"
            - Whitespace variations: " Name , Email , CreatedDate "
            - Case variations: "name,EMAIL,CreatedDate"
            
            Common use cases include:
            - API parameter validation for data shaping operations
            - Dynamic property existence checking before LINQ expression building
            - Model binding validation for complex object structures
            - Entity Framework projection validation for database queries
            - Generic property validation in data transformation pipelines
            - Custom validation scenarios with property-based logic
            
            Performance characteristics:
            - O(1) average case lookup for cached properties
            - O(n) worst case for uncached property discovery
            - Minimal memory allocation for validation operations
            - Efficient string parsing and property matching
            - Optimized for frequent validation scenarios
            </remarks>
            <exception cref="T:System.ArgumentException">
            This method does not throw exceptions for validation failures. Instead, it returns false
            and logs appropriate error information. This design ensures service stability and
            provides predictable behavior for API validation scenarios.
            Implementations may throw ArgumentException for severely malformed input that indicates
            programming errors rather than user input validation failures.
            </exception>
            <example>
            <code>
            // Basic property validation
            bool hasValidProperties = _propertyChecker.TypeHasProperties&lt;DocumentDto&gt;("FileName,FileSize");
            
            // Nested property validation
            bool hasNestedProperties = _propertyChecker.TypeHasProperties&lt;UserDto&gt;("Profile.DisplayName,Address.Street");
            
            // Handle null/empty fields (returns true)
            bool emptyIsValid = _propertyChecker.TypeHasProperties&lt;DocumentDto&gt;(null);        // Returns true
            bool whitespaceIsValid = _propertyChecker.TypeHasProperties&lt;DocumentDto&gt;("  ");  // Returns true
            
            // API parameter validation
            [HttpGet]
            public IActionResult GetDocuments([FromQuery] string? fields)
            {
                if (!_propertyChecker.TypeHasProperties&lt;DocumentDto&gt;(fields))
                {
                    return BadRequest("One or more specified fields do not exist on the Document type");
                }
                
                // Continue with data shaping using validated fields
                var documents = _repository.GetDocuments();
                return Ok(documents.ShapeData(fields));
            }
            
            // Dynamic query building with validation
            public IQueryable&lt;T&gt; BuildDynamicQuery&lt;T&gt;(IQueryable&lt;T&gt; query, string? selectFields)
            {
                if (string.IsNullOrWhiteSpace(selectFields)) return query;
                
                if (!_propertyChecker.TypeHasProperties&lt;T&gt;(selectFields))
                {
                    throw new ArgumentException("Invalid fields specified for selection");
                }
                
                // Safe to build LINQ expression with validated fields
                return query.Select(BuildSelectExpression&lt;T&gt;(selectFields));
            }
            
            // Batch validation for multiple types
            public Dictionary&lt;Type, bool&gt; ValidateFieldsForTypes(string fields, params Type[] types)
            {
                var results = new Dictionary&lt;Type, bool&gt;();
                
                foreach (var type in types)
                {
                    var method = typeof(IPropertyCheckerService).GetMethod(nameof(TypeHasProperties))
                        ?.MakeGenericMethod(type);
                    var result = (bool)(method?.Invoke(this, new object[] { fields }) ?? false);
                    results[type] = result;
                }
                
                return results;
            }
            </code>
            </example>
        </member>
        <member name="M:ADMS.API.Services.IPropertyCheckerService.HasProperty``1(System.String)">
            <summary>
            Validates that a specific property exists on the given type with detailed validation.
            </summary>
            <typeparam name="T">The type to validate the property against.</typeparam>
            <param name="propertyName">
            The name of the property to validate (case-insensitive).
            Supports simple property names and nested property paths with dot notation.
            Cannot be null, empty, or whitespace-only.
            </param>
            <returns>
            true if the property exists and is accessible; 
            false if the property does not exist or is not accessible.
            </returns>
            <remarks>
            This method provides:
            - Single property validation for specific use cases
            - Case-insensitive property name matching for flexibility
            - Support for nested property paths with dot notation
            - Caching for improved performance on repeated calls
            - Detailed logging for debugging and troubleshooting
            
            The method is optimized for scenarios where:
            - Only a single property needs validation
            - Performance is critical and batch validation is not needed
            - Integration with existing validation pipelines is required
            - Detailed per-property validation results are needed
            
            Performance characteristics:
            - O(1) average case for cached property information
            - Minimal memory allocation for single property checks
            - Thread-safe operation for concurrent access
            - Optimized for high-frequency single property validation
            </remarks>
            <example>
            <code>
            // Validate single property
            bool hasFileName = _propertyChecker.HasProperty&lt;DocumentDto&gt;("FileName");
            
            // Validate nested property
            bool hasStreet = _propertyChecker.HasProperty&lt;UserDto&gt;("Address.Street");
            
            // Use in conditional logic
            if (_propertyChecker.HasProperty&lt;DocumentDto&gt;("LastModifiedDate"))
            {
                // Safe to use LastModifiedDate property
                query = query.OrderBy(d =&gt; d.LastModifiedDate);
            }
            </code>
            </example>
        </member>
        <member name="M:ADMS.API.Services.IPropertyCheckerService.GetAvailableProperties``1">
            <summary>
            Gets all public properties available on the specified type for validation and enumeration purposes.
            </summary>
            <typeparam name="T">The type to retrieve properties for.</typeparam>
            <returns>
            An enumerable collection of property names available on the specified type.
            The collection includes all public instance properties that can be accessed.
            </returns>
            <remarks>
            This method provides:
            - Complete enumeration of available properties for validation
            - Cached property information for optimal performance
            - Integration support for dynamic property discovery
            - Debugging and diagnostic capabilities for type inspection
            
            The returned properties include:
            - All public instance properties with get accessors
            - Properties inherited from base classes
            - Properties defined by implemented interfaces
            - Auto-implemented properties and traditional properties
            
            Use cases include:
            - Generating documentation for available data shaping fields
            - Creating dynamic user interfaces for property selection
            - Validating comprehensive property coverage in tests
            - Debugging type structure and property availability
            - API documentation generation for supported fields
            </remarks>
            <example>
            <code>
            // Get all available properties
            var availableProperties = _propertyChecker.GetAvailableProperties&lt;DocumentDto&gt;().ToList();
            
            // Use for documentation
            var helpText = $"Available fields: {string.Join(", ", availableProperties)}";
            
            // Use for validation
            var invalidFields = requestedFields.Except(availableProperties).ToList();
            if (invalidFields.Any())
            {
                return BadRequest($"Invalid fields: {string.Join(", ", invalidFields)}");
            }
            </code>
            </example>
        </member>
        <member name="M:ADMS.API.Services.IPropertyCheckerService.GetDiagnosticInfo">
            <summary>
            Gets comprehensive diagnostic information about the property checker service for monitoring and debugging.
            </summary>
            <returns>
            A dictionary containing diagnostic information about service performance and cache utilization including:
            - Service configuration and operational status
            - Cache utilization statistics and performance metrics
            - Memory usage information for optimization purposes
            - Service health indicators for operational monitoring
            - Performance metrics for cache effectiveness analysis
            </returns>
            <remarks>
            This method provides comprehensive diagnostic capabilities including:
            
            Service Configuration Information:
            - Property cache entries count and utilization statistics
            - Validation cache entries and hit rate analysis
            - Service initialization status and configuration health
            - Supported type information and coverage analysis
            - Error rates and failure patterns for reliability assessment
            
            Performance Metrics:
            - Cache hit rates and miss statistics for optimization
            - Average response times for property validation operations
            - Memory usage patterns and optimization opportunities
            - Request volume and throughput analysis
            - Resource utilization metrics for capacity planning
            
            Operational Monitoring Data:
            - Recent validation patterns and frequency analysis
            - Error tracking and diagnostic information
            - Resource consumption and performance characteristics
            - Integration health with dependent services
            - System resource utilization and recommendations
            
            The diagnostic information is useful for:
            - Performance optimization and capacity planning
            - Memory usage monitoring in long-running applications
            - Service health checking and alerting systems
            - Debugging cache effectiveness and hit rates
            - Operational monitoring and service level compliance
            </remarks>
            <example>
            <code>
            var diagnostics = _propertyChecker.GetDiagnosticInfo();
            
            Console.WriteLine($"Property Cache Entries: {diagnostics["PropertyCacheCount"]}");
            Console.WriteLine($"Validation Cache Entries: {diagnostics["ValidationCacheCount"]}");
            Console.WriteLine($"Service Status: {diagnostics["ServiceStatus"]}");
            
            // Use for monitoring
            var logger = serviceProvider.GetRequiredService&lt;ILogger&gt;();
            logger.LogInformation("PropertyChecker diagnostics: {@Diagnostics}", diagnostics);
            </code>
            </example>
        </member>
        <member name="M:ADMS.API.Services.IPropertyCheckerService.ClearCache">
            <summary>
            Clears all cached property information and validation results to free memory.
            </summary>
            <remarks>
            This method is useful for:
            - Memory optimization in long-running applications
            - Testing scenarios where fresh property resolution is required
            - Dynamic type scenarios where cached information may become stale
            - Performance testing and benchmarking scenarios
            
            Important considerations:
            - Clearing the cache will cause temporary performance impact
            - Property information is re-resolved on subsequent validation requests
            - Thread-safe operation suitable for runtime execution
            - Logged operation for audit trail and monitoring purposes
            
            The method provides:
            - Complete cache invalidation for fresh property discovery
            - Memory optimization for long-running applications
            - Testing support for clean state scenarios
            - Operational maintenance capabilities
            </remarks>
            <example>
            <code>
            // Clear cache for memory optimization
            _propertyChecker.ClearCache();
            
            // Use in testing for fresh state
            [Test]
            public void TestPropertyValidation()
            {
                _propertyChecker.ClearCache(); // Ensure fresh state
                var result = _propertyChecker.TypeHasProperties&lt;TestDto&gt;("TestProperty");
                Assert.IsTrue(result);
            }
            </code>
            </example>
        </member>
        <member name="P:ADMS.API.Services.IPropertyCheckerService.CachedTypeInformation">
            <summary>
            Gets the collection of cached type information for performance monitoring and diagnostics.
            </summary>
            <value>
            An immutable collection of cached type information entries that provides:
            - Read-only access to cached type information for diagnostic purposes
            - Performance monitoring capabilities for cache effectiveness analysis
            - Memory usage insights for optimization and capacity planning
            - Debugging support for property validation troubleshooting
            </value>
            <remarks>
            This property provides access to:
            
            Cached Information Details:
            - Type names and their associated property collections
            - Property metadata for fast lookup operations
            - Reflection information cached for performance optimization
            - Validation results for frequently accessed property combinations
            
            Performance Monitoring:
            - Cache effectiveness and utilization patterns
            - Memory usage tracking for optimization
            - Property access frequency analysis
            - Cache hit/miss ratio calculations
            
            Diagnostic Capabilities:
            - Property validation troubleshooting support
            - Service health monitoring and reporting
            - Configuration validation and verification
            - Development and debugging assistance
            
            Use cases:
            - Performance monitoring and optimization analysis
            - Memory usage tracking for long-running applications
            - Debugging property validation issues and cache effectiveness
            - Service health monitoring and diagnostic reporting
            - Capacity planning and optimization insights
            </remarks>
            <example>
            <code>
            // Monitor cache utilization
            var cachedTypes = _propertyChecker.CachedTypeInformation;
            _logger.LogInformation("Cached {Count} types with property information", cachedTypes.Count);
            
            // Analyze cache effectiveness
            foreach (var kvp in cachedTypes)
            {
                _logger.LogDebug("Type {TypeName} has {PropertyCount} cached properties",
                    kvp.Key, kvp.Value.Length);
            }
            </code>
            </example>
        </member>
        <member name="P:ADMS.API.Services.IPropertyCheckerService.CachedValidationCount">
            <summary>
            Gets the count of cached validation results for performance monitoring.
            </summary>
            <value>
            The total number of cached validation results for performance and utilization analysis.
            Always non-negative and reflects current cache utilization patterns.
            </value>
            <remarks>
            This property provides:
            - Quick access to cache utilization metrics
            - Performance monitoring for cache effectiveness
            - Memory usage insights for optimization purposes
            - Service health indicators for diagnostic scenarios
            
            The cache count reflects:
            - Number of unique type-field combinations validated
            - Cache effectiveness and hit rates over time
            - Memory utilization patterns for capacity planning
            - Service usage patterns for optimization insights
            
            Monitoring applications:
            - Performance dashboard integration
            - Memory usage tracking and alerting
            - Cache optimization and tuning
            - Service health monitoring and reporting
            </remarks>
            <example>
            <code>
            // Monitor cache growth
            var cacheCount = _propertyChecker.CachedValidationCount;
            if (cacheCount > 10000)
            {
                _logger.LogWarning("Property validation cache has grown to {Count} entries", cacheCount);
                // Consider clearing cache or implementing cache size limits
            }
            
            // Performance monitoring
            _performanceLogger.LogMetric("PropertyChecker.CacheSize", cacheCount);
            </code>
            </example>
        </member>
        <member name="T:ADMS.API.Services.IPropertyMapping">
            <summary>
            Defines the contract for strongly-typed property mapping configurations in the ADMS system.
            </summary>
            <remarks>
            This interface provides a comprehensive contract for property mapping implementations including:
            
            Core Property Mapping Capabilities:
            - Type-safe property mapping between source DTOs and destination entities
            - Immutable mapping configurations for thread safety and consistency
            - Comprehensive validation and error handling for mapping operations
            - High-performance property transformation with optimized lookup operations
            - Support for complex property mappings including one-to-many scenarios
            
            Property Mapping Features:
            - Support for simple one-to-one property mappings (DTO.Name -> Entity.Name)
            - Complex one-to-many property mappings (DTO.FullName -> Entity.FirstName, Entity.LastName)
            - Bidirectional property mappings with revert support for inverse operations
            - Case-insensitive property name matching for flexible mapping scenarios
            - Comprehensive property validation against target type schemas
            
            Thread Safety and Performance:
            - Immutable mapping configurations prevent accidental modification after construction
            - Thread-safe operations for concurrent access in multi-threaded scenarios
            - Optimized property lookup operations with O(1) average complexity
            - Memory-efficient storage using optimized collection types
            - Cached property information for improved repeated access patterns
            
            Integration and Framework Support:
            - Seamless integration with Entity Framework Core for database operations
            - Support for LINQ expression building for dynamic sorting and filtering
            - Compatibility with mapping frameworks like AutoMapper for complex scenarios
            - Integration with dependency injection containers for service lifetime management
            - Support for API versioning with evolving mapping requirements
            
            Validation and Error Handling:
            - Comprehensive validation of mapping configurations during initialization
            - Type-safe property mapping validation at compile time where possible
            - Runtime validation of property mappings against target schemas
            - Detailed error messages for troubleshooting mapping configuration issues
            - Integration with logging infrastructure for debugging and monitoring
            
            Security and Data Protection:
            - Input validation and sanitization for property mapping operations
            - Protection against property injection and mapping manipulation attacks
            - Secure property name validation and filtering
            - Integration with security policies and access control mechanisms
            - Audit trail support for mapping operations and configuration changes
            
            The interface is designed to support:
            - Polymorphic usage in property mapping service collections
            - Generic type constraints and compile-time type safety
            - Runtime type information and dynamic property discovery
            - Comprehensive property mapping validation and verification
            - Integration with monitoring and observability frameworks
            
            Implementation Considerations:
            - Implementations must provide immutable mapping configurations
            - Thread-safe operations are required for concurrent access scenarios
            - Proper integration with logging infrastructure for diagnostic capabilities
            - Comprehensive error handling without service interruption
            - Support for both simple and complex property mapping scenarios
            
            Common Usage Patterns:
            - Polymorphic storage in property mapping service collections
            - Type-safe property mapping operations with generic constraints
            - Runtime property mapping validation and verification
            - Integration with dependency injection and service composition
            - Configuration-driven property mapping with validation support
            
            The interface serves as the foundation for:
            - API request/response transformation between DTOs and domain entities
            - Database query result mapping from entities to presentation models
            - Dynamic sorting and filtering operations with property name translation
            - Data validation and transformation pipelines with type safety
            - Cross-layer data transformation in layered architecture patterns
            </remarks>
            <example>
            <code>
            // Example polymorphic usage in a property mapping service
            public class PropertyMappingService
            {
                private readonly List&lt;IPropertyMapping&gt; _mappings;
                
                public PropertyMappingService()
                {
                    _mappings = new List&lt;IPropertyMapping&gt;
                    {
                        new PropertyMapping&lt;DocumentDto, Document&gt;(documentMappings),
                        new PropertyMapping&lt;MatterDto, Matter&gt;(matterMappings),
                        new PropertyMapping&lt;RevisionDto, Revision&gt;(revisionMappings)
                    };
                }
                
                public PropertyMapping&lt;TSource, TDestination&gt; GetMapping&lt;TSource, TDestination&gt;()
                {
                    return _mappings.OfType&lt;PropertyMapping&lt;TSource, TDestination&gt;&gt;().FirstOrDefault()
                        ?? throw new InvalidOperationException($"No mapping found for {typeof(TSource).Name} to {typeof(TDestination).Name}");
                }
            }
            
            // Example validation usage
            public class MappingValidator
            {
                public ValidationResult ValidateAllMappings(IEnumerable&lt;IPropertyMapping&gt; mappings)
                {
                    var errors = new List&lt;string&gt;();
                    
                    foreach (var mapping in mappings)
                    {
                        // Validate each mapping configuration
                        var validationResults = mapping.ValidateConfiguration();
                        if (validationResults.Any())
                        {
                            errors.AddRange(validationResults.Select(r =&gt; r.ErrorMessage));
                        }
                    }
                    
                    return errors.Any() 
                        ? ValidationResult.Failed(string.Join("; ", errors))
                        : ValidationResult.Success();
                }
            }
            </code>
            </example>
        </member>
        <member name="P:ADMS.API.Services.IPropertyMapping.SourceType">
            <summary>
            Gets the source type information for this property mapping configuration.
            </summary>
            <remarks>
            This property provides:
            - Runtime type information for the source type (typically a DTO)
            - Reflection capabilities for dynamic property discovery and validation
            - Type safety validation for mapping operations
            - Integration support for generic mapping frameworks
            
            The source type information is used for:
            - Validation of mapping configurations against source type schema
            - Dynamic property discovery during mapping generation
            - Type compatibility checking for mapping operations
            - Error reporting with specific type context information
            - Integration with reflection-based mapping utilities
            
            Common source types include:
            - Data Transfer Objects (DTOs) for API operations
            - View models for presentation layer operations
            - Request/response models for service integration
            - Configuration objects for system settings
            - Any .NET type with public properties for mapping
            </remarks>
            <value>The Type information for the source type in the mapping configuration.</value>
            <example>
            <code>
            // Example usage in mapping validation
            public bool ValidateSourceType(IPropertyMapping mapping, Type expectedType)
            {
                return mapping.SourceType == expectedType;
            }
            
            // Example usage in dynamic mapping scenarios
            public string GetSourceTypeName(IPropertyMapping mapping)
            {
                return mapping.SourceType.Name; // e.g., "DocumentDto"
            }
            
            // Example usage in mapping discovery
            public IEnumerable&lt;PropertyInfo&gt; GetSourceProperties(IPropertyMapping mapping)
            {
                return mapping.SourceType.GetProperties(BindingFlags.Public | BindingFlags.Instance);
            }
            </code>
            </example>
        </member>
        <member name="P:ADMS.API.Services.IPropertyMapping.DestinationType">
            <summary>
            Gets the destination type information for this property mapping configuration.
            </summary>
            <remarks>
            This property provides:
            - Runtime type information for the destination type (typically an entity)
            - Reflection capabilities for property existence validation
            - Type safety enforcement for mapping operations
            - Support for complex type transformation scenarios
            
            The destination type information is used for:
            - Validation of destination property names in mapping configurations
            - Type compatibility verification during mapping operations
            - Dynamic property discovery for automatic mapping generation
            - Error reporting with destination type context information
            - Integration with Entity Framework and ORM operations
            
            Common destination types include:
            - Domain entities for business logic operations
            - Database entities for persistence operations
            - Service models for inter-service communication
            - Configuration entities for system management
            - Any .NET type with public writable properties
            </remarks>
            <value>The Type information for the destination type in the mapping configuration.</value>
            <example>
            <code>
            // Example usage in entity validation
            public bool IsEntityMapping(IPropertyMapping mapping)
            {
                return mapping.DestinationType.Assembly.GetName().Name.Contains("Entities");
            }
            
            // Example usage in database mapping scenarios
            public string GetTableName(IPropertyMapping mapping)
            {
                var tableAttribute = mapping.DestinationType.GetCustomAttribute&lt;TableAttribute&gt;();
                return tableAttribute?.Name ?? mapping.DestinationType.Name;
            }
            
            // Example usage in property validation
            public bool ValidateDestinationProperty(IPropertyMapping mapping, string propertyName)
            {
                return mapping.DestinationType.GetProperty(propertyName) != null;
            }
            </code>
            </example>
        </member>
        <member name="P:ADMS.API.Services.IPropertyMapping.MappingDictionary">
            <summary>
            Gets the immutable dictionary containing the property mapping configuration.
            </summary>
            <remarks>
            This property provides:
            - Read-only access to the complete property mapping configuration
            - Thread-safe enumeration and lookup of property mappings
            - Integration support for external mapping frameworks and tools
            - Debugging capabilities for troubleshooting mapping issues
            
            Dictionary Characteristics:
            - Case-insensitive string keys for flexible property name matching
            - Immutable after construction to prevent accidental modification
            - Optimized for frequent lookup operations with O(1) average complexity
            - Memory-efficient storage using dictionary optimization techniques
            
            Key-Value Structure:
            - Keys: Source property names from the source type (case-insensitive)
            - Values: PropertyMappingValue instances containing destination property information
            - Supports one-to-one and one-to-many property mapping scenarios
            - Enables complex property transformations and bidirectional mappings
            
            Usage Patterns:
            - Direct property lookup: MappingDictionary["PropertyName"]
            - Enumeration of all mappings: foreach(var kvp in MappingDictionary)
            - Existence checking: MappingDictionary.ContainsKey("PropertyName")
            - Integration with LINQ: MappingDictionary.Where(kvp => condition)
            
            The dictionary is used extensively by:
            - Property mapping services for dynamic property transformation
            - LINQ expression builders for database query generation
            - Validation services for mapping configuration verification
            - Sorting and filtering operations for property name translation
            - Debugging and diagnostic tools for mapping analysis
            </remarks>
            <value>
            An immutable dictionary mapping source property names to PropertyMappingValue instances.
            The dictionary uses case-insensitive string comparison for robust property matching.
            </value>
            <example>
            <code>
            // Example property lookup
            public PropertyMappingValue? GetPropertyMapping(IPropertyMapping mapping, string propertyName)
            {
                return mapping.MappingDictionary.TryGetValue(propertyName, out var value) ? value : null;
            }
            
            // Example mapping enumeration
            public void LogAllMappings(IPropertyMapping mapping)
            {
                foreach (var kvp in mapping.MappingDictionary)
                {
                    _logger.LogInformation("Property {Source} maps to {Destinations}",
                        kvp.Key, string.Join(", ", kvp.Value.DestinationProperties));
                }
            }
            
            // Example LINQ usage for filtering
            public IEnumerable&lt;string&gt; GetBidirectionalProperties(IPropertyMapping mapping)
            {
                return mapping.MappingDictionary
                    .Where(kvp =&gt; kvp.Value.Revert)
                    .Select(kvp =&gt; kvp.Key);
            }
            </code>
            </example>
        </member>
        <member name="P:ADMS.API.Services.IPropertyMapping.PropertyMappingCount">
            <summary>
            Gets the count of property mappings defined in this configuration.
            </summary>
            <remarks>
            This convenience property provides:
            - Quick access to the number of mapped properties without dictionary enumeration
            - Performance metrics for mapping complexity analysis
            - Validation support for mapping completeness checking
            - Debugging information for mapping configuration inspection
            
            The property count is useful for:
            - Performance optimization based on mapping complexity
            - Validation that required properties are mapped
            - Logging and monitoring of mapping configuration size
            - Unit testing verification of mapping completeness
            - Capacity planning for mapping operations
            
            Typical property counts vary by mapping scenario:
            - Simple DTOs: 5-15 properties
            - Complex entities: 15-50 properties
            - Configuration objects: 3-20 properties
            - Integration models: 10-100+ properties
            </remarks>
            <value>
            The total number of property mappings in the mapping dictionary.
            Always non-negative and reflects the current mapping configuration size.
            </value>
            <example>
            <code>
            // Example usage in validation
            public ValidationResult ValidateMappingCompleteness(IPropertyMapping mapping)
            {
                if (mapping.PropertyMappingCount == 0)
                {
                    return ValidationResult.Failed("Property mapping contains no property mappings");
                }
                
                return ValidationResult.Success();
            }
            
            // Example usage in performance analysis
            public string CategorizeMappingComplexity(IPropertyMapping mapping)
            {
                return mapping.PropertyMappingCount switch
                {
                    &lt; 10 =&gt; "Simple",
                    &lt; 25 =&gt; "Moderate",
                    &lt; 50 =&gt; "Complex",
                    _ =&gt; "Very Complex"
                };
            }
            
            // Example usage in monitoring
            public void LogMappingStatistics(IEnumerable&lt;IPropertyMapping&gt; mappings)
            {
                var totalMappings = mappings.Sum(m =&gt; m.PropertyMappingCount);
                var averageMappings = mappings.Average(m =&gt; m.PropertyMappingCount);
                
                _logger.LogInformation("Mapping statistics: Total={Total}, Average={Average:F1}",
                    totalMappings, averageMappings);
            }
            </code>
            </example>
        </member>
        <member name="P:ADMS.API.Services.IPropertyMapping.IsEmpty">
            <summary>
            Gets a value indicating whether this mapping configuration is empty (contains no property mappings).
            </summary>
            <remarks>
            This convenience property identifies:
            - Mapping configurations that contain no property mappings
            - Potential configuration errors or incomplete setup scenarios
            - Edge cases that require special handling in mapping operations
            - Validation scenarios for mapping completeness checking
            
            Empty mappings might indicate:
            - Incomplete mapping configuration during development
            - Types with no compatible properties for automatic mapping
            - Configuration errors that need to be addressed
            - Special cases where no property transformation is needed
            - Mapping configurations that failed during initialization
            
            The property is commonly used for:
            - Configuration validation during service initialization
            - Error detection and reporting in mapping setup
            - Conditional logic for handling empty mapping scenarios
            - Unit testing validation of mapping configuration
            - Diagnostic and troubleshooting scenarios
            </remarks>
            <value>
            true if the mapping configuration contains no property mappings;
            false if one or more property mappings are defined.
            </value>
            <example>
            <code>
            // Example validation usage
            public void ValidateMappingConfiguration(IEnumerable&lt;IPropertyMapping&gt; mappings)
            {
                var emptyMappings = mappings.Where(m =&gt; m.IsEmpty).ToList();
                
                if (emptyMappings.Any())
                {
                    var emptyTypes = emptyMappings.Select(m =&gt; $"{m.SourceType.Name}-&gt;{m.DestinationType.Name}");
                    _logger.LogWarning("Empty property mappings detected: {EmptyMappings}",
                        string.Join(", ", emptyTypes));
                }
            }
            
            // Example conditional processing
            public ProcessingResult ProcessMapping(IPropertyMapping mapping, object source)
            {
                if (mapping.IsEmpty)
                {
                    _logger.LogInformation("Skipping empty mapping for {SourceType}", 
                        mapping.SourceType.Name);
                    return ProcessingResult.Skipped("No mappings defined");
                }
                
                return ProcessMappingWithProperties(mapping, source);
            }
            
            // Example testing usage
            [Test]
            public void ValidateNoEmptyMappings()
            {
                var mappings = _mappingService.GetAllMappings();
                var emptyMappings = mappings.Where(m =&gt; m.IsEmpty);
                
                Assert.That(emptyMappings, Is.Empty, "No mappings should be empty after initialization");
            }
            </code>
            </example>
        </member>
        <member name="M:ADMS.API.Services.IPropertyMapping.ValidateConfiguration">
            <summary>
            Validates the entire property mapping configuration against the source and destination type schemas.
            </summary>
            <returns>
            An enumerable collection of ValidationResult objects describing any configuration issues found.
            An empty collection indicates that the mapping configuration is valid and ready for use.
            Each ValidationResult includes detailed error messages and affected property names for debugging.
            </returns>
            <remarks>
            This method provides comprehensive validation including:
            
            Source Type Validation:
            - Verifies that all mapped source properties exist on the source type
            - Validates property accessibility and visibility requirements
            - Checks for deprecated or obsolete property usage
            - Ensures property name spelling and casing consistency
            - Validates property types and compatibility requirements
            
            Destination Type Validation:
            - Confirms that all destination properties exist on the destination type
            - Validates property write accessibility for mapping operations
            - Checks type compatibility between source and destination properties
            - Ensures complex property paths are valid (e.g., "Address.Street")
            - Validates property constraints and business rule compliance
            
            Mapping Configuration Validation:
            - Identifies duplicate property mappings and conflicting configurations
            - Validates bidirectional mapping configurations for consistency
            - Checks for circular references in complex property mappings
            - Ensures mapping completeness for critical properties
            - Validates mapping metadata and configuration parameters
            
            Business Rule Validation:
            - Applies domain-specific validation rules where applicable
            - Validates against known property mapping anti-patterns
            - Checks for performance implications of complex mappings
            - Ensures security considerations are addressed
            - Validates compliance with organizational mapping standards
            
            Validation Result Format:
            - Detailed error descriptions for each validation failure
            - Property names and context information for troubleshooting
            - Severity levels (errors, warnings, informational messages)
            - Recommended actions for resolving configuration issues
            - Integration with structured logging and monitoring systems
            
            The validation is particularly useful for:
            - Unit testing of property mapping configurations
            - Development-time validation of mapping completeness
            - Configuration validation during application startup
            - Debugging complex property mapping scenarios
            - Continuous integration validation pipelines
            </remarks>
            <exception cref="T:System.InvalidOperationException">
            Thrown when validation process itself fails due to reflection errors,
            type loading issues, or other infrastructure problems.
            The original exception is included as the inner exception for debugging.
            </exception>
            <example>
            <code>
            // Example validation in service initialization
            public class PropertyMappingService
            {
                public void ValidateAllMappings()
                {
                    foreach (var mapping in _registeredMappings)
                    {
                        var validationResults = mapping.ValidateConfiguration();
                        
                        if (validationResults.Any())
                        {
                            var errors = validationResults.Select(r =&gt; r.ErrorMessage);
                            _logger.LogError("Mapping validation failed for {SourceType}-&gt;{DestinationType}: {Errors}",
                                mapping.SourceType.Name, mapping.DestinationType.Name, string.Join("; ", errors));
                            
                            throw new InvalidOperationException($"Invalid mapping configuration detected: {string.Join("; ", errors)}");
                        }
                    }
                }
            }
            
            // Example unit testing validation
            [Test]
            public void ValidateMappingConfiguration()
            {
                var mapping = new PropertyMapping&lt;DocumentDto, Document&gt;(testMappings);
                var validationResults = mapping.ValidateConfiguration();
                
                Assert.That(validationResults, Is.Empty, 
                    $"Mapping validation failed: {string.Join(", ", validationResults.Select(r =&gt; r.ErrorMessage))}");
            }
            
            // Example diagnostic validation
            public class MappingDiagnosticService
            {
                public DiagnosticReport GenerateValidationReport(IEnumerable&lt;IPropertyMapping&gt; mappings)
                {
                    var report = new DiagnosticReport();
                    
                    foreach (var mapping in mappings)
                    {
                        var validationResults = mapping.ValidateConfiguration();
                        
                        if (validationResults.Any())
                        {
                            report.AddMappingIssues(mapping.SourceType, mapping.DestinationType, validationResults);
                        }
                        else
                        {
                            report.AddValidMapping(mapping.SourceType, mapping.DestinationType);
                        }
                    }
                    
                    return report;
                }
            }
            </code>
            </example>
        </member>
        <member name="M:ADMS.API.Services.IPropertyMapping.ToString">
            <summary>
            Returns a comprehensive string representation of the property mapping configuration.
            </summary>
            <returns>
            A detailed string containing summary information about the property mapping configuration
            in a human-readable format suitable for debugging, logging, and diagnostic purposes.
            </returns>
            <remarks>
            The string representation includes:
            - Source and destination type names for context identification
            - Total count of property mappings for configuration overview
            - Summary of mapping characteristics (simple, complex, bidirectional)
            - Memory and performance characteristics for optimization insights
            - Configuration health and validation status
            
            The formatted output provides:
            - Consistent formatting for logging and monitoring scenarios
            - Sufficient detail for debugging configuration issues
            - Concise summary suitable for diagnostic displays
            - Integration with standard .NET logging frameworks
            - Structured information for automated parsing and analysis
            
            Example output formats:
            - "PropertyMapping&lt;DocumentDto, Document&gt;: 8 mappings (6 simple, 2 complex, 1 bidirectional)"
            - "PropertyMapping&lt;MatterDto, Matter&gt;: 12 mappings (10 simple, 2 complex)"
            - "PropertyMapping&lt;RevisionDto, Revision&gt;: Empty mapping configuration"
            
            This method is particularly useful for:
            - Debugging property mapping configuration issues
            - Logging mapping information for audit and monitoring
            - Displaying configuration summaries in diagnostic tools
            - Unit testing verification of mapping characteristics
            - Integration with application performance monitoring
            
            Integration scenarios:
            - Structured logging with mapping context information
            - Exception messages with detailed mapping information
            - Diagnostic displays and configuration summaries
            - Performance monitoring and optimization analysis
            - Automated testing and validation reporting
            </remarks>
            <example>
            <code>
            // Example logging integration
            public void LogMappingConfiguration(IPropertyMapping mapping)
            {
                _logger.LogInformation("Initialized property mapping: {Mapping}", mapping);
                // Output: "Initialized property mapping: PropertyMapping&lt;DocumentDto, Document&gt;: 8 mappings (6 simple, 2 complex)"
            }
            
            // Example exception handling
            public void ValidateMapping(IPropertyMapping mapping)
            {
                try
                {
                    var validationResults = mapping.ValidateConfiguration();
                    if (validationResults.Any())
                    {
                        throw new InvalidOperationException($"Mapping validation failed for {mapping}");
                    }
                }
                catch (Exception ex)
                {
                    _logger.LogError(ex, "Error validating mapping: {Mapping}", mapping);
                    throw;
                }
            }
            
            // Example diagnostic collection
            public class MappingDiagnosticCollector
            {
                public void CollectMappingDiagnostics(IEnumerable&lt;IPropertyMapping&gt; mappings)
                {
                    var diagnostics = mappings.Select(m =&gt; new
                    {
                        MappingInfo = m.ToString(),
                        PropertyCount = m.PropertyMappingCount,
                        IsEmpty = m.IsEmpty,
                        SourceType = m.SourceType.Name,
                        DestinationType = m.DestinationType.Name
                    });
                    
                    _logger.LogInformation("Mapping diagnostics: {@Diagnostics}", diagnostics);
                }
            }
            </code>
            </example>
        </member>
        <!-- Badly formed XML comment ignored for member "T:ADMS.API.Services.IPropertyMappingService" -->
        <member name="M:ADMS.API.Services.IPropertyMappingService.GetPropertyMapping``2">
            <summary>
            Retrieves the comprehensive property mapping dictionary for the specified source and destination types.
            </summary>
            <typeparam name="TSource">
            The source DTO type for the mapping lookup.
            Must be a type with public properties that can be mapped to the destination type.
            Common examples include DocumentDto, MatterDto, RevisionDto, and other API data transfer objects.
            </typeparam>
            <typeparam name="TDestination">
            The destination entity type for the mapping lookup.
            Must be a type with public properties that can receive mapped values from the source type.
            Common examples include Document, Matter, Revision, and other domain entities.
            </typeparam>
            <returns>
            A dictionary mapping source property names (keys) to PropertyMappingValue instances (values).
            The dictionary provides complete mapping configuration for transforming between the specified types.
            Keys are case-insensitive source property names from the TSource type.
            Values contain destination property information, bidirectional flags, and mapping metadata.
            </returns>
            <remarks>
            This method provides high-performance property mapping retrieval with:
            
            Caching and Performance Features:
            - Implements intelligent caching to avoid repeated lookup operations
            - Uses concurrent dictionary for thread-safe caching in multi-threaded scenarios
            - Optimizes frequently accessed mappings for improved response times
            - Provides consistent performance characteristics under varying loads
            - Memory-efficient caching with automatic cleanup and optimization
            
            Mapping Resolution Process:
            1. Generates a unique cache key based on source and destination type information
            2. Checks the mapping cache for previously resolved mapping configurations
            3. If cached mapping exists, returns the cached result for optimal performance
            4. If no cached mapping exists, performs mapping resolution from registered mappings
            5. Caches the resolved mapping for future requests to improve performance
            6. Validates mapping completeness and consistency before returning
            
            Error Handling and Validation:
            - Validates that exactly one matching mapping exists for the specified types
            - Provides detailed error messages when mappings are missing or ambiguous
            - Handles edge cases where multiple mappings might match the same type pair
            - Logs mapping resolution activities for debugging and monitoring purposes
            - Integrates with diagnostic logging for operational visibility
            
            Thread Safety and Concurrency:
            - All mapping resolution operations are thread-safe for concurrent access
            - Uses concurrent collections to prevent race conditions during caching
            - Supports high-concurrency scenarios without performance degradation
            - No shared mutable state that could cause threading issues
            - Optimized for multi-threaded web application usage patterns
            
            Mapping Dictionary Characteristics:
            - Case-insensitive string keys for flexible property name matching
            - PropertyMappingValue objects containing destination property information
            - Support for one-to-one and one-to-many property mapping scenarios
            - Bidirectional mapping support with revert flag configuration
            - Immutable mapping configurations for thread safety and consistency
            
            The returned mapping dictionary is used extensively for:
            - Building dynamic LINQ expressions for database queries with property translation
            - Translating API parameter names to entity property names
            - Constructing sort and filter expressions for paginated operations
            - Validating that requested sort/filter fields have valid mappings
            - Data transformation operations between different object layers
            
            Common usage patterns include:
            - Direct property lookup: mapping["PropertyName"] for specific property access
            - Enumeration: foreach(var kvp in mapping) for complete mapping iteration
            - Existence checking: mapping.ContainsKey("PropertyName") for validation
            - LINQ operations: mapping.Where(kvp => condition) for filtering scenarios
            </remarks>
            <exception cref="T:System.InvalidOperationException">
            Thrown when no mapping is found for the specified type pair, multiple ambiguous mappings exist,
            or mapping resolution fails due to configuration errors or infrastructure issues.
            The exception includes detailed information about the failure reason and context.
            </exception>
            <example>
            <code>
            // Get mapping for DocumentDto to Document entity transformation
            var mapping = _mappingService.GetPropertyMapping&lt;DocumentDto, Document&gt;();
            
            // Use mapping for property existence validation
            bool canSortByFileName = mapping.ContainsKey("FileName");
            bool canSortByCreatedDate = mapping.ContainsKey("CreatedDate");
            
            // Get specific property mapping for transformation
            if (mapping.TryGetValue("FileName", out var fileNameMapping))
            {
                string destinationProperty = fileNameMapping.GetPrimaryProperty(); // "FileName"
                bool shouldReverse = fileNameMapping.Revert; // false for normal mapping
                var destinationProperties = fileNameMapping.DestinationProperties; // ["FileName"]
            }
            
            // Build LINQ expression using property mapping
            public IQueryable&lt;Document&gt; ApplySorting(IQueryable&lt;Document&gt; query, string sortBy)
            {
                var mapping = _mappingService.GetPropertyMapping&lt;DocumentDto, Document&gt;();
                
                if (mapping.TryGetValue(sortBy, out var mappingValue))
                {
                    var propertyName = mappingValue.GetPrimaryProperty();
                    return mappingValue.Revert 
                        ? query.OrderByDescending(GetPropertyExpression&lt;Document&gt;(propertyName))
                        : query.OrderBy(GetPropertyExpression&lt;Document&gt;(propertyName));
                }
                
                return query; // Return original query if no mapping found
            }
            </code>
            </example>
        </member>
        <!-- Badly formed XML comment ignored for member "M:ADMS.API.Services.IPropertyMappingService.ValidMappingExistsFor``2(System.String)" -->
        <member name="M:ADMS.API.Services.IPropertyMappingService.GetDiagnosticInfo">
            <summary>
            Retrieves comprehensive diagnostic information about the property mapping service configuration and performance.
            </summary>
            <returns>
            A dictionary containing detailed diagnostic information about:
            - Service configuration and operational status
            - Registered property mappings count and details
            - Cache statistics and performance metrics
            - Memory usage and optimization insights
            - Configuration validation results and health indicators
            </returns>
            <remarks>
            This method provides comprehensive diagnostic capabilities including:
            
            Service Configuration Information:
            - Total count of registered property mappings across all type pairs
            - Service initialization status and configuration validation results
            - Supported type pairs and mapping coverage analysis
            - Configuration errors or warnings detected during initialization
            - Service health indicators and operational status
            
            Performance Metrics and Statistics:
            - Cache hit rates and miss statistics for mapping lookups
            - Average response times for mapping resolution operations
            - Memory usage statistics for cached mapping configurations
            - Request volume and throughput metrics for monitoring
            - Performance bottlenecks and optimization opportunities
            
            Operational Monitoring Data:
            - Recent mapping lookup patterns and frequency analysis
            - Error rates and failure patterns for reliability assessment
            - Resource utilization metrics for capacity planning
            - Integration health with dependent services and components
            - System resource consumption and optimization recommendations
            
            The diagnostic information is particularly useful for:
            - Service health monitoring and alerting in production environments
            - Performance optimization and capacity planning initiatives
            - Configuration validation and verification during deployment
            - Development and debugging scenarios for mapping issues
            - Operational monitoring and service level agreement compliance
            
            Integration with monitoring systems:
            - Compatible with application performance monitoring tools
            - Structured data format suitable for logging and analytics
            - Metric collection support for dashboard and alerting systems
            - Health check integration for load balancer and orchestration
            - Audit trail support for compliance and governance requirements
            </remarks>
            <example>
            <code>
            // Basic diagnostic information retrieval
            var diagnostics = _mappingService.GetDiagnosticInfo();
            
            // Log key metrics for monitoring
            _logger.LogInformation("Property mapping service diagnostics: " +
                "Registered mappings: {RegisteredMappings}, " +
                "Cache entries: {CacheEntries}, " +
                "Service status: {ServiceStatus}",
                diagnostics["RegisteredMappingCount"],
                diagnostics["CachedMappingCount"],
                diagnostics["ServiceStatus"]);
            
            // Health check integration
            public class PropertyMappingHealthCheck : IHealthCheck
            {
                private readonly IPropertyMappingService _mappingService;
                
                public async Task&lt;HealthCheckResult&gt; CheckHealthAsync(
                    HealthCheckContext context, 
                    CancellationToken cancellationToken = default)
                {
                    try
                    {
                        var diagnostics = _mappingService.GetDiagnosticInfo();
                        var status = diagnostics["ServiceStatus"]?.ToString();
                        
                        if (status == "Healthy")
                        {
                            return HealthCheckResult.Healthy(
                                "Property mapping service is operating normally", 
                                diagnostics);
                        }
                        else
                        {
                            return HealthCheckResult.Degraded(
                                $"Property mapping service status: {status}", 
                                data: diagnostics);
                        }
                    }
                    catch (Exception ex)
                    {
                        return HealthCheckResult.Unhealthy(
                            "Property mapping service health check failed", 
                            ex);
                    }
                }
            }
            
            // Performance monitoring integration
            public class PropertyMappingMonitor
            {
                public void LogPerformanceMetrics()
                {
                    var diagnostics = _mappingService.GetDiagnosticInfo();
                    
                    // Extract performance metrics
                    if (diagnostics.TryGetValue("CacheHitRate", out var hitRate))
                    {
                        _performanceLogger.LogMetric("PropertyMapping.CacheHitRate", (double)hitRate);
                    }
                    
                    if (diagnostics.TryGetValue("AverageResponseTime", out var responseTime))
                    {
                        _performanceLogger.LogMetric("PropertyMapping.AvgResponseTime", (TimeSpan)responseTime);
                    }
                }
            }
            </code>
            </example>
        </member>
        <member name="M:ADMS.API.Services.IPropertyMappingService.ClearMappingCache">
            <summary>
            Clears all cached property mappings to free memory and force re-resolution of mapping configurations.
            </summary>
            <remarks>
            This method provides cache management capabilities for:
            
            Memory Optimization Scenarios:
            - Long-running application memory optimization and cleanup
            - Periodic cache maintenance to prevent memory leaks
            - Resource management in memory-constrained environments
            - Cache size control in high-volume applications
            
            Development and Testing Support:
            - Testing scenarios where fresh mapping resolution is required
            - Development environment cache invalidation during testing
            - Configuration change scenarios requiring cache refresh
            - Performance testing and benchmarking with clean cache state
            
            Dynamic Configuration Management:
            - Runtime configuration changes requiring cache invalidation
            - Dynamic mapping updates in configuration-driven scenarios
            - Hot-swapping of mapping configurations without service restart
            - A/B testing scenarios with different mapping configurations
            
            Operational Maintenance:
            - Scheduled maintenance procedures for cache optimization
            - Memory pressure response and resource management
            - Diagnostic procedures for troubleshooting mapping issues
            - Performance optimization and capacity management
            
            Important Considerations:
            - Clearing the cache will cause temporary performance impact
            - Property mappings will be re-resolved on subsequent requests
            - Thread-safe operation suitable for runtime execution
            - Logged operation for audit trail and monitoring purposes
            - No impact on registered mapping configurations (only cache cleared)
            
            The method is designed to be:
            - Safe: No risk to service stability or mapping configurations
            - Fast: Efficient cache clearing with minimal service disruption
            - Observable: Comprehensive logging for operational monitoring
            - Recoverable: Automatic cache rebuilding on subsequent requests
            </remarks>
            <example>
            <code>
            // Scheduled cache maintenance
            public class PropertyMappingMaintenanceService
            {
                private readonly IPropertyMappingService _mappingService;
                private readonly Timer _maintenanceTimer;
                
                public void StartMaintenanceSchedule()
                {
                    // Clear cache every hour for memory optimization
                    _maintenanceTimer = new Timer(PerformMaintenance, null, 
                        TimeSpan.FromHours(1), TimeSpan.FromHours(1));
                }
                
                private void PerformMaintenance(object state)
                {
                    _logger.LogInformation("Performing scheduled property mapping cache maintenance");
                    _mappingService.ClearMappingCache();
                    _logger.LogInformation("Property mapping cache maintenance completed");
                }
            }
            
            // Memory pressure response
            public class MemoryPressureHandler
            {
                public void HandleMemoryPressure()
                {
                    _logger.LogWarning("Memory pressure detected - clearing property mapping cache");
                    _mappingService.ClearMappingCache();
                    
                    // Force garbage collection after cache clearing
                    GC.Collect();
                    GC.WaitForPendingFinalizers();
                    GC.Collect();
                }
            }
            
            // Configuration change handler
            public class MappingConfigurationService
            {
                public async Task UpdateMappingConfigurationAsync(MappingConfiguration newConfig)
                {
                    _logger.LogInformation("Updating property mapping configuration");
                    
                    // Clear existing cache before applying new configuration
                    _mappingService.ClearMappingCache();
                    
                    // Apply new configuration
                    await ApplyConfigurationAsync(newConfig);
                    
                    _logger.LogInformation("Property mapping configuration update completed");
                }
            }
            
            // Testing utility
            public class PropertyMappingTestHelper
            {
                public void PrepareCleanTestEnvironment()
                {
                    // Ensure clean cache state for testing
                    _mappingService.ClearMappingCache();
                    
                    // Verify cache is empty
                    var diagnostics = _mappingService.GetDiagnosticInfo();
                    Assert.Equal(0, diagnostics["CachedMappingCount"]);
                }
            }
            </code>
            </example>
        </member>
        <member name="P:ADMS.API.Services.IPropertyMappingService.RegisteredMappings">
            <summary>
            Gets the collection of registered property mappings in an immutable format for inspection and validation.
            </summary>
            <value>
            An immutable collection of property mapping configurations that provides:
            - Read-only access to all registered property mappings
            - Thread-safe enumeration of mapping configurations
            - Integration support for mapping validation and diagnostics
            - Debugging capabilities for troubleshooting mapping issues
            </value>
            <remarks>
            This property provides comprehensive access to mapping configurations including:
            
            Mapping Configuration Information:
            - All automatically generated property mappings between DTO and entity types
            - Custom property mapping overrides and configurations
            - Bidirectional mappings for reverse transformation scenarios
            - Complex mappings with multiple destination properties
            
            Diagnostic and Validation Support:
            - Configuration validation during application startup
            - Runtime introspection of available mapping capabilities
            - Unit testing scenarios for mapping configuration verification
            - Debugging and troubleshooting of mapping issues
            
            Integration Capabilities:
            - Monitoring tools for mapping configuration analysis
            - Documentation generation for API specifications
            - Configuration management and deployment validation
            - Health checking and service verification
            
            Thread Safety and Performance:
            - Immutable collection prevents accidental modification
            - Thread-safe enumeration for concurrent access scenarios
            - Efficient access without performance overhead
            - Cached collection for repeated access operations
            
            The collection is particularly useful for:
            - Service initialization validation and configuration checking
            - Development tools and diagnostic utilities
            - Automated testing and configuration verification
            - Documentation and API specification generation
            - Operational monitoring and health checking
            </remarks>
            <example>
            <code>
            // Configuration validation during startup
            public class PropertyMappingValidator
            {
                public ValidationResult ValidateAllMappings()
                {
                    var mappings = _mappingService.RegisteredMappings;
                    var errors = new List&lt;string&gt;();
                    
                    foreach (var mapping in mappings)
                    {
                        // Validate each mapping configuration
                        if (mapping.PropertyMappingCount == 0)
                        {
                            errors.Add($"Empty mapping found: {mapping}");
                        }
                    }
                    
                    return errors.Any() 
                        ? ValidationResult.Failed(errors)
                        : ValidationResult.Success();
                }
            }
            
            // Documentation generation
            public class ApiDocumentationGenerator
            {
                public string GenerateMappingDocumentation()
                {
                    var mappings = _mappingService.RegisteredMappings;
                    var documentation = new StringBuilder();
                    
                    documentation.AppendLine("## Property Mappings");
                    
                    foreach (var mapping in mappings)
                    {
                        documentation.AppendLine($"- {mapping}");
                    }
                    
                    return documentation.ToString();
                }
            }
            </code>
            </example>
        </member>
        <member name="T:ADMS.API.Services.IValidationService">
            <summary>
            Defines the contract for enterprise-grade validation services providing comprehensive validation logic for ADMS API operations.
            </summary>
            <remarks>
            This interface provides a comprehensive contract for validation implementations including:
            
            Core Validation Capabilities:
            - Object validation using data annotations and custom validation logic
            - Entity existence validation with proper error responses
            - Parameter validation with standardized error handling
            - Business rule validation for complex scenarios
            - Specialized validation for file operations, email addresses, and data formats
            
            Validation Framework Integration:
            - ASP.NET Core model binding and validation infrastructure integration
            - Data annotation validation with detailed error reporting
            - Custom validation through IValidatableObject implementation
            - ValidationResult collections for structured error information
            - Problem Details format compliance for consistent API responses
            
            Security and Input Validation:
            - Input sanitization through comprehensive validation
            - SQL injection prevention through parameterized validation
            - Cross-site scripting (XSS) prevention through format validation
            - File type validation to prevent malicious uploads
            - Checksum validation for data integrity verification
            
            Entity and Business Logic Validation:
            - Database entity existence validation with proper error responses
            - Business rule enforcement for document management operations
            - Complex validation scenarios with multiple interdependent rules
            - Workflow validation for document lifecycle management
            - Compliance validation for regulatory requirements
            
            Performance and Reliability:
            - Asynchronous validation operations for database checks
            - Efficient validation with minimal performance overhead
            - Thread-safe operations for concurrent validation scenarios
            - Graceful error handling with detailed diagnostic information
            - Integration with logging infrastructure for monitoring and debugging
            
            API Integration Features:
            - Seamless integration with ASP.NET Core controllers and actions
            - Support for model binding validation scenarios
            - Consistent error response formatting using Problem Details
            - Integration with API versioning and content negotiation
            - Comprehensive audit trail support for validation activities
            
            Implementation Considerations:
            - Implementations should provide consistent error response formats
            - Proper integration with logging infrastructure for diagnostic capabilities
            - Thread-safe operations for use in multi-threaded web applications
            - Graceful handling of validation errors without service interruption
            - Configuration support for validation rules and business logic
            
            The interface is designed to support:
            - High-performance validation operations with minimal overhead
            - Comprehensive error reporting with actionable information
            - Extensible validation logic for evolving business requirements
            - Integration with monitoring and observability frameworks
            - Compliance with security and data protection standards
            
            Common Implementation Patterns:
            - Centralized validation logic to eliminate code duplication
            - Consistent error response formatting across all validation methods
            - Integration with dependency injection for service composition
            - Configuration-driven validation rules for flexible business logic
            - Comprehensive logging and monitoring for operational visibility
            
            Usage Scenarios:
            - API request validation in controller actions
            - Business rule enforcement in service layers
            - Data integrity validation before database operations
            - File upload security and format validation
            - User input sanitization and security validation
            </remarks>
            <example>
            <code>
            // Example implementation usage in a controller
            [HttpPost]
            public async Task&lt;IActionResult&gt; CreateDocument(
                [FromBody] DocumentForCreationDto document)
            {
                // Parameter validation
                var parameterValidation = _validationService.ValidateNotNull(document, nameof(document));
                if (parameterValidation != null) return parameterValidation;
                
                // Object validation
                var objectValidation = _validationService.ValidateObject(document);
                if (objectValidation != null) return objectValidation;
                
                // Model state validation
                var modelStateValidation = _validationService.ValidateModelState(ModelState);
                if (modelStateValidation != null) return modelStateValidation;
                
                // Business rule validation
                var businessValidation = await _validationService.ValidateDocumentForCreationAsync(matterId, document);
                if (businessValidation.Any())
                {
                    return BadRequest(CreateValidationResponse(businessValidation));
                }
                
                // Continue with document creation...
                return Ok();
            }
            
            // Example service implementation
            public class ValidationService : IValidationService
            {
                public ActionResult? ValidateObject&lt;T&gt;(T obj)
                {
                    ArgumentNullException.ThrowIfNull(obj);
                    
                    var context = new ValidationContext(obj);
                    var results = new List&lt;ValidationResult&gt;();
                    
                    if (Validator.TryValidateObject(obj, context, results, true))
                        return null;
                        
                    return new BadRequestObjectResult(new ValidationProblemDetails(
                        results.GroupBy(r =&gt; r.MemberNames.FirstOrDefault() ?? string.Empty)
                               .ToDictionary(g =&gt; g.Key, g =&gt; g.Select(r =&gt; r.ErrorMessage).ToArray())));
                }
            }
            </code>
            </example>
        </member>
        <member name="M:ADMS.API.Services.IValidationService.ValidateObject``1(``0)">
            <summary>
            Validates the specified object against its data annotations and custom validation logic with comprehensive error reporting.
            </summary>
            <typeparam name="T">
            The type of the object to validate. Must be a reference type or value type with validation attributes.
            Common examples include DTO classes, entity classes, or any .NET type with data annotation validation.
            </typeparam>
            <param name="obj">
            The object instance to validate against its validation attributes and IValidatableObject implementation.
            Cannot be null - implementations should validate this parameter and provide appropriate error responses.
            The object will be validated using its data annotation attributes and any custom validation logic.
            </param>
            <returns>
            A BadRequestObjectResult containing ValidationProblemDetails if validation fails;
            null if the object passes all validation rules and is considered valid.
            The ValidationProblemDetails follows RFC 7807 format with property-level error grouping.
            </returns>
            <remarks>
            This method provides comprehensive object validation including:
            
            Validation Types Supported:
            - Data annotation validation (Required, Range, MaxLength, RegularExpression, etc.)
            - Custom validation through IValidatableObject implementation
            - Recursive validation of complex object properties and nested objects
            - Property-level validation with detailed error attribution
            - Cross-property validation for complex business rules
            
            Error Response Format:
            - Uses ValidationProblemDetails following RFC 7807 Problem Details specification
            - Groups errors by property name for client-side error handling
            - Provides detailed error messages for each validation failure
            - Includes HTTP status code 400 (Bad Request) for validation errors
            - Supports content negotiation for JSON and XML response formats
            
            Performance Considerations:
            - Efficient validation with minimal performance overhead
            - Caches validation metadata where possible for improved performance
            - Thread-safe operations suitable for concurrent validation scenarios
            - Minimal memory allocation during validation processes
            
            The method is commonly used for:
            - API request body validation in controller actions
            - DTO validation before business logic processing
            - Entity validation before database persistence operations
            - Complex object validation in service layer operations
            - Input validation in data transformation pipelines
            </remarks>
            <exception cref="T:System.ArgumentNullException">
            Implementations should handle null objects gracefully by returning appropriate
            BadRequestObjectResult rather than throwing exceptions to maintain API consistency.
            </exception>
            <example>
            <code>
            // Validate a document creation DTO
            var validationResult = _validationService.ValidateObject(documentForCreation);
            if (validationResult != null)
            {
                // Validation failed - return error response to client
                return validationResult; // Returns BadRequestObjectResult with ValidationProblemDetails
            }
            
            // Object is valid - continue with processing
            var createdDocument = await _documentService.CreateAsync(documentForCreation);
            return CreatedAtRoute("GetDocument", new { id = createdDocument.Id }, createdDocument);
            </code>
            </example>
        </member>
        <member name="M:ADMS.API.Services.IValidationService.ValidateModelState(Microsoft.AspNetCore.Mvc.ModelBinding.ModelStateDictionary)">
            <summary>
            Validates the provided ASP.NET Core model state dictionary and returns appropriate error responses.
            </summary>
            <param name="modelState">
            The ModelStateDictionary from ASP.NET Core model binding to validate.
            Contains model binding errors, validation errors, and any custom errors added during processing.
            Cannot be null - implementations should validate this parameter appropriately.
            </param>
            <returns>
            A BadRequestObjectResult containing ValidationProblemDetails if model state is invalid;
            null if the model state is valid and contains no errors.
            The ValidationProblemDetails includes all model binding and validation errors with proper formatting.
            </returns>
            <remarks>
            This method validates ASP.NET Core model state which captures:
            
            Model State Error Types:
            - Model binding errors (type conversion failures, format issues)
            - Data annotation validation errors from automatic model validation
            - Custom validation errors added during model binding process
            - Property-level validation errors with specific property attribution
            - Model-level validation errors affecting multiple properties
            
            Error Response Characteristics:
            - Structured error responses with property-level error grouping
            - Consistent error formatting using ValidationProblemDetails
            - Proper HTTP status codes following REST conventions (400 Bad Request)
            - Detailed error messages suitable for client-side error handling
            - Integration with ASP.NET Core's built-in validation infrastructure
            
            Common Error Scenarios Handled:
            - Invalid JSON format in request body causing binding failures
            - Type conversion errors (e.g., string to integer conversion failures)
            - Missing required properties in JSON request payload
            - Format validation failures (e.g., invalid email address format)
            - Range validation failures (e.g., negative values where positive required)
            - Custom validation errors added by model binding filters
            
            Integration Benefits:
            - Seamless integration with ASP.NET Core's model binding pipeline
            - Consistent error response format across all validation scenarios
            - Proper handling of complex validation scenarios and edge cases
            - Support for both simple and complex object model validation
            - Integration with custom model binding and validation attributes
            
            The method is essential for:
            - API controller action validation before processing requests
            - Comprehensive input validation in web API scenarios
            - Integration with ASP.NET Core's automatic model validation
            - Consistent error response formatting across API endpoints
            - Client-friendly error reporting with actionable information
            </remarks>
            <example>
            <code>
            [HttpPost]
            public async Task&lt;IActionResult&gt; CreateDocument([FromBody] DocumentForCreationDto document)
            {
                // Validate model state from model binding
                var modelStateResult = _validationService.ValidateModelState(ModelState);
                if (modelStateResult != null)
                {
                    // Model binding or validation errors occurred
                    return modelStateResult; // Returns BadRequestObjectResult with detailed errors
                }
                
                // Model state is valid - continue with business logic
                var result = await _documentService.CreateDocumentAsync(document);
                return CreatedAtRoute("GetDocument", new { id = result.Id }, result);
            }
            
            // Custom model state error handling
            public IActionResult ProcessWithCustomValidation(MyModel model)
            {
                // Add custom validation errors to model state
                if (model.StartDate &gt; model.EndDate)
                {
                    ModelState.AddModelError("EndDate", "End date must be after start date");
                }
                
                // Validate the updated model state
                var validationResult = _validationService.ValidateModelState(ModelState);
                return validationResult ?? Ok("Validation passed");
            }
            </code>
            </example>
        </member>
        <member name="M:ADMS.API.Services.IValidationService.ValidateGuid(System.Guid,System.String)">
            <summary>
            Validates that the provided GUID parameter is not empty and returns appropriate error responses.
            </summary>
            <param name="id">
            The GUID value to validate for emptiness.
            Should be a valid GUID that is not equal to Guid.Empty (all zeros).
            Commonly used for entity identifiers, route parameters, and foreign key references.
            </param>
            <param name="parameterName">
            The name of the parameter being validated for error reporting and logging.
            Used in error messages and diagnostic information to identify which parameter failed validation.
            Should match the actual parameter name for consistency and debugging purposes.
            </param>
            <returns>
            A BadRequestObjectResult with Problem Details if the GUID is empty (Guid.Empty);
            null if the GUID is valid and not empty.
            The error response includes the parameter name and descriptive error message.
            </returns>
            <remarks>
            This method validates GUID parameters which are commonly used as:
            
            Common GUID Usage Scenarios:
            - Entity identifiers (matterId, documentId, revisionId) in route parameters
            - Foreign key references in API request payloads
            - Query parameters for resource identification and filtering
            - Correlation IDs and tracking identifiers for request tracing
            - Session identifiers and security tokens for authentication
            
            Validation Characteristics:
            - Detects empty GUIDs (Guid.Empty or 00000000-0000-0000-0000-000000000000)
            - Provides descriptive error messages with parameter context
            - Uses Problem Details format for consistent error responses
            - Integrates with structured logging for diagnostic capabilities
            - Thread-safe operation suitable for concurrent validation scenarios
            
            Error Response Format:
            - HTTP 400 Bad Request status code for invalid GUIDs
            - Problem Details JSON format following RFC 7807 specification
            - Parameter name included in error context for debugging
            - Descriptive error message suitable for client-side error handling
            - Consistent format with other validation error responses
            
            The method is essential for:
            - Route parameter validation in RESTful API controllers
            - Entity identifier validation before database query operations
            - Foreign key validation in entity relationship scenarios
            - Request parameter sanitization and security validation
            - Preventing downstream errors from empty or invalid identifiers
            
            Performance and Security:
            - Fast validation with minimal computational overhead
            - No database access required for GUID format validation
            - Prevents potential security issues from malformed identifiers
            - Early validation failure to avoid unnecessary processing
            </remarks>
            <example>
            <code>
            [HttpGet("{matterId}/documents/{documentId}")]
            public async Task&lt;IActionResult&gt; GetDocument(Guid matterId, Guid documentId)
            {
                // Validate route parameters
                var matterIdValidation = _validationService.ValidateGuid(matterId, nameof(matterId));
                if (matterIdValidation != null) return matterIdValidation;
                
                var documentIdValidation = _validationService.ValidateGuid(documentId, nameof(documentId));
                if (documentIdValidation != null) return documentIdValidation;
                
                // Parameters are valid - continue with business logic
                var document = await _documentService.GetAsync(matterId, documentId);
                return Ok(document);
            }
            
            // Batch parameter validation
            public async Task&lt;IActionResult&gt; ProcessMultipleItems(Guid[] itemIds)
            {
                for (int i = 0; i &lt; itemIds.Length; i++)
                {
                    var validation = _validationService.ValidateGuid(itemIds[i], $"itemIds[{i}]");
                    if (validation != null) return validation;
                }
                
                // All IDs are valid
                return await ProcessItems(itemIds);
            }
            </code>
            </example>
        </member>
        <member name="M:ADMS.API.Services.IValidationService.ValidateStringNotEmpty(System.String,System.String)">
            <summary>
            Validates that the provided string parameter is not null, empty, or whitespace-only.
            </summary>
            <param name="value">
            The string value to validate for null, empty, or whitespace-only content.
            Should contain actual meaningful content beyond just whitespace characters.
            Common examples include file names, user input, search terms, and configuration values.
            </param>
            <param name="parameterName">
            The name of the parameter being validated for error reporting and logging purposes.
            Used in diagnostic logging and error reporting to identify which parameter failed validation.
            Should match the actual parameter name for consistency and debugging support.
            </param>
            <returns>
            true if the string contains meaningful content (not null, empty, or whitespace-only);
            false if the string is null, empty, or contains only whitespace characters.
            Return value can be used directly in conditional logic for validation flow control.
            </returns>
            <remarks>
            This method validates string parameters for various common scenarios:
            
            String Validation Scenarios:
            - Required text input validation (user names, descriptions, comments)
            - File name validation for document upload operations
            - Search query validation for non-empty search terms
            - Configuration parameter validation for system settings
            - User input sanitization for security and data quality
            
            Validation Logic:
            - Detects null string references
            - Identifies empty strings (zero length)
            - Recognizes whitespace-only strings (spaces, tabs, newlines)
            - Uses String.IsNullOrWhiteSpace() semantics for comprehensive checking
            - Provides consistent validation behavior across all string parameters
            
            Integration with Logging:
            - Logs validation failures with parameter context for debugging
            - Provides diagnostic information for troubleshooting validation issues
            - Integrates with structured logging frameworks for monitoring
            - Supports operational monitoring and alerting for validation patterns
            
            Common Usage Patterns:
            - Pre-validation of user input before business logic processing
            - Required field validation in data entry scenarios
            - Configuration validation during application startup
            - API parameter validation for non-optional string parameters
            - Security validation to prevent injection attacks through empty parameters
            
            Performance Characteristics:
            - Efficient validation with minimal memory allocation
            - Fast execution suitable for high-frequency validation scenarios
            - Thread-safe operation for concurrent validation usage
            - No external dependencies or database access required
            
            The method helps prevent:
            - Null reference exceptions in downstream processing
            - Business logic errors from empty or meaningless input
            - Security vulnerabilities from malformed string parameters
            - Data quality issues from whitespace-only content
            </remarks>
            <example>
            <code>
            public async Task&lt;IActionResult&gt; SearchDocuments(string searchTerm, string category)
            {
                // Validate required string parameters
                if (!_validationService.ValidateStringNotEmpty(searchTerm, nameof(searchTerm)))
                {
                    return BadRequest("Search term is required and cannot be empty");
                }
                
                if (!_validationService.ValidateStringNotEmpty(category, nameof(category)))
                {
                    return BadRequest("Category is required and cannot be empty");
                }
                
                // Parameters are valid - perform search
                var results = await _searchService.SearchAsync(searchTerm, category);
                return Ok(results);
            }
            
            // Configuration validation example
            public void ValidateConfiguration(AppConfiguration config)
            {
                var errors = new List&lt;string&gt;();
                
                if (!_validationService.ValidateStringNotEmpty(config.DatabaseConnectionString, nameof(config.DatabaseConnectionString)))
                    errors.Add("Database connection string is required");
                    
                if (!_validationService.ValidateStringNotEmpty(config.ApiKey, nameof(config.ApiKey)))
                    errors.Add("API key is required");
                
                if (errors.Any())
                    throw new InvalidOperationException($"Configuration validation failed: {string.Join(", ", errors)}");
            }
            </code>
            </example>
        </member>
        <member name="M:ADMS.API.Services.IValidationService.ValidateNotNull(System.Object,System.String)">
            <summary>
            Validates that the provided object parameter is not null and returns appropriate error responses.
            </summary>
            <param name="obj">
            The object instance to validate for null reference.
            Can be any reference type including DTOs, entities, collections, or custom objects.
            Null values will trigger validation failure with appropriate error responses.
            </param>
            <param name="parameterName">
            The name of the parameter being validated for error reporting and diagnostic purposes.
            Used in error messages and logging to identify which parameter failed null validation.
            Should match the actual parameter name for consistency and debugging support.
            </param>
            <returns>
            A BadRequestObjectResult with Problem Details if the object is null;
            null if the object reference is valid and not null.
            The error response includes parameter context and descriptive error messaging.
            </returns>
            <remarks>
            This method provides comprehensive null validation for various object types:
            
            Null Validation Scenarios:
            - DTO parameter validation in API controller actions
            - Entity validation before database persistence operations
            - Service method parameter validation for required objects
            - Collection validation before enumeration or processing operations
            - Configuration object validation during application initialization
            
            Error Response Characteristics:
            - Uses Problem Details format following RFC 7807 specification
            - HTTP 400 Bad Request status code for null parameter errors
            - Parameter name included in error context for debugging support
            - Descriptive error messages suitable for client-side error handling
            - Consistent formatting with other validation error responses
            
            Integration Benefits:
            - Seamless integration with ASP.NET Core controller validation patterns
            - Consistent error response format across all validation scenarios
            - Support for automatic model binding validation workflows
            - Integration with logging infrastructure for diagnostic capabilities
            - Thread-safe operation suitable for concurrent validation scenarios
            
            Common Usage Patterns:
            - API request body validation before processing
            - Service method parameter validation for defensive programming
            - Entity validation before persistence operations
            - Configuration object validation during dependency injection
            - Collection validation before LINQ operations or enumeration
            
            The method helps prevent:
            - Null reference exceptions in downstream processing logic
            - Unexpected behavior from null parameters in business logic
            - Security vulnerabilities from malformed or missing request data
            - Data integrity issues from null entity references
            - Runtime errors in collection processing and enumeration scenarios
            
            Performance and Reliability:
            - Fast validation with minimal computational overhead
            - No external dependencies or database access required
            - Early validation failure to prevent unnecessary processing
            - Consistent behavior across all object types and scenarios
            </remarks>
            <example>
            <code>
            [HttpPost]
            public async Task&lt;IActionResult&gt; CreateDocument([FromBody] DocumentForCreationDto document)
            {
                // Validate request body is not null
                var nullValidation = _validationService.ValidateNotNull(document, nameof(document));
                if (nullValidation != null)
                {
                    // Returns BadRequestObjectResult with Problem Details
                    return nullValidation;
                }
                
                // Object is not null - continue with additional validation
                var objectValidation = _validationService.ValidateObject(document);
                if (objectValidation != null) return objectValidation;
                
                // All validation passed - process the request
                var result = await _documentService.CreateAsync(document);
                return CreatedAtRoute("GetDocument", new { id = result.Id }, result);
            }
            
            // Service method parameter validation
            public async Task&lt;ProcessingResult&gt; ProcessCollection(IEnumerable&lt;Item&gt; items)
            {
                var validation = _validationService.ValidateNotNull(items, nameof(items));
                if (validation != null)
                {
                    throw new ArgumentException("Items collection cannot be null", nameof(items));
                }
                
                // Collection is not null - safe to enumerate
                return await ProcessItemsAsync(items);
            }
            </code>
            </example>
        </member>
        <member name="M:ADMS.API.Services.IValidationService.ValidateMatterExistsAsync(System.Guid)">
            <summary>
            Validates asynchronously whether the specified matter exists in the database.
            </summary>
            <param name="matterId">
            The unique identifier of the matter to validate for existence.
            Must be a valid GUID that corresponds to an existing matter record in the database.
            Used as the primary key for matter lookup operations.
            </param>
            <returns>
            A Task that represents the asynchronous validation operation.
            Task result is null if the matter exists in the database;
            NotFoundObjectResult with Problem Details if the matter does not exist or cannot be accessed.
            </returns>
            <remarks>
            This method provides comprehensive matter existence validation including:
            
            Database Validation Process:
            - Executes asynchronous database query to verify matter existence
            - Uses efficient existence checking to minimize database overhead
            - Handles database connectivity issues and timeout scenarios gracefully
            - Provides detailed error information for troubleshooting database issues
            - Integrates with database connection pooling and resource management
            
            Error Response Characteristics:
            - HTTP 404 Not Found status code for non-existent matters
            - Problem Details format following RFC 7807 specification for consistency
            - Matter ID included in error context for debugging and logging
            - Descriptive error messages suitable for client-side error handling
            - Structured logging for audit trails and operational monitoring
            
            Performance Considerations:
            - Asynchronous operation to prevent blocking of calling threads
            - Optimized database queries for fast existence checking
            - Connection pooling support for high-concurrency scenarios
            - Minimal resource usage with efficient query execution
            - Caching integration where appropriate for frequently accessed matters
            
            Security and Authorization:
            - Validates matter accessibility based on current security context
            - Prevents information disclosure about non-existent entities
            - Integrates with authorization policies and access control
            - Audit logging for matter access attempts and validation results
            - Support for tenant isolation and multi-tenancy scenarios
            
            Integration Scenarios:
            - Route parameter validation in matter-scoped API endpoints
            - Foreign key validation before document creation operations
            - Authorization prerequisite checking for matter-related operations
            - Data integrity validation in business logic workflows
            - Cascade validation for dependent entity operations
            
            The method is essential for:
            - RESTful API parameter validation (e.g., /api/matters/{matterId}/documents)
            - Business rule enforcement for matter-scoped operations
            - Data integrity validation before related entity operations
            - Security validation for matter access control
            - Audit trail creation for matter access and validation activities
            </remarks>
            <example>
            <code>
            [HttpGet("{matterId}/documents")]
            public async Task&lt;IActionResult&gt; GetDocuments(Guid matterId)
            {
                // Validate matter exists before retrieving documents
                var matterValidation = await _validationService.ValidateMatterExistsAsync(matterId);
                if (matterValidation != null)
                {
                    // Matter not found - return 404 with Problem Details
                    return matterValidation;
                }
                
                // Matter exists - retrieve documents
                var documents = await _documentService.GetDocumentsByMatterAsync(matterId);
                return Ok(documents);
            }
            
            // Business logic validation example
            public async Task&lt;ValidationResult&gt; ValidateDocumentCreation(Guid matterId, DocumentForCreationDto document)
            {
                // Ensure matter exists before creating document
                var matterExists = await _validationService.ValidateMatterExistsAsync(matterId);
                if (matterExists != null)
                {
                    return ValidationResult.Failed("Cannot create document for non-existent matter");
                }
                
                // Continue with document-specific validation
                return await ValidateDocumentBusinessRules(matterId, document);
            }
            </code>
            </example>
        </member>
        <member name="M:ADMS.API.Services.IValidationService.ValidateDocumentExistsAsync(System.Guid)">
            <summary>
            Validates asynchronously whether the specified document exists in the database.
            </summary>
            <param name="documentId">
            The unique identifier of the document to validate for existence.
            Must be a valid GUID that corresponds to an existing document record in the database.
            Used as the primary key for document lookup operations.
            </param>
            <returns>
            A Task that represents the asynchronous validation operation.
            Task result is null if the document exists in the database;
            NotFoundObjectResult with Problem Details if the document does not exist or cannot be accessed.
            </returns>
            <remarks>
            This method provides comprehensive document existence validation including:
            
            Database Validation Features:
            - Asynchronous database query execution for document existence checking
            - Efficient query optimization to minimize database resource usage
            - Integration with Entity Framework Core for robust data access
            - Connection pooling and resource management for scalability
            - Transaction support where required for data consistency
            
            Error Response Management:
            - HTTP 404 Not Found status code for missing documents
            - Problem Details format compliance with RFC 7807 specification
            - Document ID context included in error responses for debugging
            - Structured error information suitable for client-side error handling
            - Comprehensive logging for audit trails and troubleshooting
            
            Performance Optimization:
            - Asynchronous operations to maintain application responsiveness
            - Optimized existence queries without unnecessary data retrieval
            - Database connection efficiency and connection pooling support
            - Minimal memory allocation during validation operations
            - Integration with caching strategies for frequently accessed documents
            
            Security and Access Control:
            - Document accessibility validation based on security context
            - Authorization integration for document access permissions
            - Tenant isolation support for multi-tenant applications
            - Audit logging for document access validation activities
            - Prevention of information disclosure through existence checking
            
            Common Usage Scenarios:
            - Document-scoped API endpoint parameter validation
            - Prerequisite checking before document update or deletion operations
            - Revision creation validation to ensure parent document exists
            - File operation validation to verify document context
            - Business rule enforcement for document-dependent operations
            
            Integration Benefits:
            - Seamless integration with document management workflows
            - Support for complex document hierarchy and relationship validation
            - Integration with document lifecycle management processes
            - Compatibility with document versioning and revision control
            - Support for document metadata and classification validation
            </remarks>
            <example>
            <code>
            [HttpPut("{matterId}/documents/{documentId}")]
            public async Task&lt;IActionResult&gt; UpdateDocument(
                Guid matterId, 
                Guid documentId, 
                [FromBody] DocumentForUpdateDto document)
            {
                // Validate document exists before updating
                var documentValidation = await _validationService.ValidateDocumentExistsAsync(documentId);
                if (documentValidation != null)
                {
                    return documentValidation; // Returns 404 NotFound with Problem Details
                }
                
                // Document exists - continue with update operation
                var result = await _documentService.UpdateAsync(documentId, document);
                return Ok(result);
            }
            
            // Cascade validation example
            public async Task&lt;IActionResult&gt; CreateRevision(
                Guid matterId, 
                Guid documentId, 
                RevisionForCreationDto revision)
            {
                // Validate parent document exists before creating revision
                var documentExists = await _validationService.ValidateDocumentExistsAsync(documentId);
                if (documentExists != null) return documentExists;
                
                // Create revision for existing document
                var result = await _revisionService.CreateAsync(documentId, revision);
                return CreatedAtRoute("GetRevision", new { matterId, documentId, revisionId = result.Id }, result);
            }
            </code>
            </example>
        </member>
        <member name="M:ADMS.API.Services.IValidationService.ValidateRevisionExistsAsync(System.Guid)">
            <summary>
            Validates asynchronously whether the specified revision exists in the database.
            </summary>
            <param name="revisionId">
            The unique identifier of the revision to validate for existence.
            Must be a valid GUID that corresponds to an existing revision record in the database.
            Used as the primary key for revision lookup operations in document version control.
            </param>
            <returns>
            A Task that represents the asynchronous validation operation.
            Task result is null if the revision exists in the database;
            NotFoundObjectResult with Problem Details if the revision does not exist or cannot be accessed.
            </returns>
            <remarks>
            This method provides comprehensive revision existence validation including:
            
            Revision-Specific Validation:
            - Asynchronous database query for revision existence verification
            - Integration with document version control and revision management systems
            - Support for revision history and audit trail validation
            - Efficient query execution optimized for revision table structure
            - Integration with document hierarchy and relationship validation
            
            Version Control Integration:
            - Validates revision existence within document version control context
            - Supports document revision history and branching scenarios
            - Integration with document lifecycle and approval workflows
            - Validation of revision accessibility and permissions
            - Support for revision-specific metadata and classification
            
            Database Performance:
            - Optimized queries for revision table structure and indexing
            - Efficient existence checking without unnecessary data retrieval
            - Connection pooling and resource management for scalability
            - Transaction support where required for consistency
            - Integration with caching strategies for active revisions
            
            Error Handling and Responses:
            - HTTP 404 Not Found for non-existent revisions
            - Problem Details format with revision context information
            - Structured error responses for client-side error handling
            - Comprehensive logging for revision access validation
            - Integration with audit trail and compliance reporting
            
            Security and Access Control:
            - Revision accessibility validation based on security context
            - Integration with document-level access control policies
            - Support for revision-specific permissions and authorization
            - Audit logging for revision access and validation activities
            - Prevention of unauthorized revision access through validation
            
            Common Usage Scenarios:
            - Revision-specific API endpoint parameter validation
            - File download validation for specific document revisions
            - Revision update and deletion prerequisite checking
            - Audit trail and history access validation
            - Business rule enforcement for revision-dependent operations
            
            The method is crucial for:
            - Document version control and revision management operations
            - File access control and download authorization
            - Revision history and audit trail functionality
            - Integration with document approval and workflow systems
            - Compliance and regulatory reporting for document changes
            </remarks>
            <example>
            <code>
            [HttpGet("{matterId}/documents/{documentId}/revisions/{revisionId}")]
            public async Task&lt;IActionResult&gt; GetRevision(
                Guid matterId, 
                Guid documentId, 
                Guid revisionId)
            {
                // Validate revision exists before retrieval
                var revisionValidation = await _validationService.ValidateRevisionExistsAsync(revisionId);
                if (revisionValidation != null)
                {
                    return revisionValidation; // Returns 404 NotFound with Problem Details
                }
                
                // Revision exists - retrieve and return
                var revision = await _revisionService.GetAsync(revisionId);
                return Ok(revision);
            }
            
            // File download validation example
            [HttpGet("{matterId}/documents/{documentId}/revisions/{revisionId}/download")]
            public async Task&lt;IActionResult&gt; DownloadRevisionFile(
                Guid matterId, 
                Guid documentId, 
                Guid revisionId)
            {
                // Validate revision exists before file download
                var revisionExists = await _validationService.ValidateRevisionExistsAsync(revisionId);
                if (revisionExists != null) return revisionExists;
                
                // Revision exists - proceed with file download
                var fileStream = await _fileService.GetRevisionFileAsync(revisionId);
                var fileName = await _revisionService.GetFileNameAsync(revisionId);
                
                return File(fileStream, "application/octet-stream", fileName);
            }
            </code>
            </example>
        </member>
        <member name="M:ADMS.API.Services.IValidationService.ValidateDocumentForCreationAsync(System.Guid,ADMS.API.Models.DocumentForCreationDto)">
            <summary>
            Validates a document for creation operations with comprehensive business rule checking and security validation.
            </summary>
            <param name="matterId">
            The unique identifier of the matter where the document will be created.
            Must be a valid GUID corresponding to an existing matter in the database.
            Used for matter-specific business rule validation and document placement.
            </param>
            <param name="document">
            The document creation data transfer object containing all information needed to create a new document.
            Cannot be null and must contain valid document metadata including file information.
            Will be validated against business rules, security policies, and data integrity requirements.
            </param>
            <returns>
            A Task that represents the asynchronous validation operation.
            Task result contains an enumerable collection of ValidationResult objects.
            An empty collection indicates successful validation; non-empty collection contains validation errors.
            Each ValidationResult includes error messages and affected property names for client-side handling.
            </returns>
            <remarks>
            This method performs comprehensive document creation validation including:
            
            File and Content Validation:
            - File name presence, format, and length validation within system limits
            - File extension validation against allowed types and security policies
            - MIME type validation and consistency checking with file extension
            - File size validation within acceptable limits and storage constraints
            - Checksum validation for data integrity and file verification
            - Content validation to prevent malicious file uploads and security threats
            
            Business Rule Validation:
            - Duplicate file name detection within matter scope to prevent conflicts
            - File type restrictions based on matter type and security policies
            - Storage quota validation and capacity management
            - Document classification and metadata requirements
            - Workflow integration and approval process requirements
            - Compliance validation for regulatory and legal requirements
            
            Security Validation:
            - File extension allow-list enforcement for security protection
            - MIME type validation against known safe types and attack vectors
            - File name sanitization and security checking for injection prevention
            - Content-based file type verification and malicious content detection
            - Virus scanning integration where required for file security
            - Access control validation for document creation permissions
            
            Data Integrity Validation:
            - Required field validation for essential document metadata
            - Data format validation for structured information
            - Referential integrity checking for related entities
            - Consistency validation across multiple document properties
            - Business rule enforcement for document lifecycle management
            - Audit trail and compliance information validation
            
            Performance Considerations:
            - Asynchronous validation for database operations and external service calls
            - Efficient validation sequencing to minimize resource usage
            - Early validation failure to prevent unnecessary processing overhead
            - Integration with caching strategies for validation rule lookup
            - Optimized database queries for business rule verification
            
            The validation process follows a comprehensive approach:
            1. Parameter validation (matter ID, document DTO null checking)
            2. Basic format validation (file name, extension, MIME type)
            3. Security validation (file type restrictions, content scanning)
            4. Business rule validation (duplicates, quotas, workflows)
            5. Data integrity validation (consistency, referential integrity)
            6. Compliance validation (regulatory requirements, policies)
            
            Integration with validation infrastructure:
            - Uses ValidationResult objects for structured error reporting
            - Integrates with logging infrastructure for audit and debugging
            - Supports localization for multi-language error messages
            - Compatible with client-side validation frameworks
            - Integration with monitoring and alerting for validation patterns
            </remarks>
            <example>
            <code>
            [HttpPost("{matterId}/documents")]
            public async Task&lt;IActionResult&gt; CreateDocument(
                Guid matterId, 
                [FromBody] DocumentForCreationDto document)
            {
                // Comprehensive document creation validation
                var validationResults = await _validationService.ValidateDocumentForCreationAsync(matterId, document);
                var errors = validationResults.ToList();
                
                if (errors.Any())
                {
                    // Create structured error response
                    var problemDetails = new ValidationProblemDetails();
                    
                    foreach (var error in errors)
                    {
                        var propertyName = error.MemberNames.FirstOrDefault() ?? "General";
                        if (!problemDetails.Errors.ContainsKey(propertyName))
                            problemDetails.Errors[propertyName] = new string[0];
                            
                        problemDetails.Errors[propertyName] = problemDetails.Errors[propertyName]
                            .Concat(new[] { error.ErrorMessage }).ToArray();
                    }
                    
                    return BadRequest(problemDetails);
                }
                
                // Validation passed - create document
                var createdDocument = await _documentService.CreateAsync(matterId, document);
                return CreatedAtRoute("GetDocument", 
                    new { matterId, documentId = createdDocument.Id }, 
                    createdDocument);
            }
            
            // Business service integration example
            public async Task&lt;BusinessResult&gt; ProcessDocumentUpload(
                Guid matterId, 
                DocumentForCreationDto document, 
                Stream fileContent)
            {
                // Validate document before processing file upload
                var validationResults = await _validationService.ValidateDocumentForCreationAsync(matterId, document);
                
                if (validationResults.Any())
                {
                    return BusinessResult.ValidationFailed(validationResults);
                }
                
                // Validation passed - proceed with secure file processing
                return await ProcessSecureFileUpload(matterId, document, fileContent);
            }
            </code>
            </example>
        </member>
        <member name="M:ADMS.API.Services.IValidationService.ValidateDocumentForUpdate(ADMS.API.Models.DocumentForUpdateDto)">
            <summary>
            Validates a document for update operations with comprehensive business rule checking and state validation.
            </summary>
            <param name="document">
            The document update data transfer object containing the updated document information to validate.
            Cannot be null and must contain all required fields for document update operations.
            Will be validated against business rules, data consistency requirements, and state transition rules.
            </param>
            <returns>
            An enumerable collection of ValidationResult objects containing any validation errors found.
            An empty collection indicates successful validation and the document can be safely updated.
            Each ValidationResult includes detailed error messages and affected property names for error handling.
            </returns>
            <remarks>
            This method performs comprehensive document update validation including:
            
            Content and Format Validation:
            - File name presence, format requirements, and length constraints
            - File extension format validation and security checking
            - MIME type format validation and consistency verification
            - File size validation within acceptable ranges and system limits
            - Checksum integrity validation for data consistency verification
            - Content format validation for structured document information
            
            Business Rule Validation:
            - Document state consistency checking (deleted vs checked out scenarios)
            - Update permission validation based on current document state
            - File content consistency validation and version control integration
            - Workflow state validation for document approval processes
            - Retention policy validation and compliance requirements
            - Document classification and metadata consistency checking
            
            State Transition Validation:
            - Prevents documents from being both deleted and checked out simultaneously
            - Validates state transitions for document lifecycle management
            - Ensures consistent document status across all operations
            - Validates user permissions for specific state changes
            - Integration with approval workflows and business process validation
            - Compliance validation for document state change requirements
            
            Data Integrity Validation:
            - Required field validation for essential document metadata
            - Cross-field validation for interdependent properties
            - Referential integrity checking for related entities and relationships
            - Consistency validation across document versions and revisions
            - Business rule enforcement for document management policies
            - Audit trail and compliance information validation
            
            Security and Permission Validation:
            - Update permission validation based on security context
            - Document access control and authorization checking
            - Content modification validation for sensitive documents
            - Classification level validation for security requirements
            - Compliance validation for regulatory and legal constraints
            - Integration with audit logging for security monitoring
            
            Performance and Efficiency:
            - Efficient validation logic optimized for frequent update operations
            - Early validation failure to prevent unnecessary processing
            - Minimal database access for validation rule verification
            - Integration with caching for frequently validated business rules
            - Optimized error collection and reporting for user experience
            
            The validation ensures:
            - Data integrity during document update operations
            - Business rule compliance for document management workflows
            - Security validation for file content and metadata changes
            - Consistent document state management across the system
            - Compliance with regulatory and organizational policies
            
            This method is critical for maintaining:
            - Document integrity and consistency in the management system
            - Business rule enforcement during document lifecycle operations
            - Security compliance for document modification and access control
            - Data quality and consistency across document management workflows
            - Integration with enterprise document management and compliance systems
            </remarks>
            <example>
            <code>
            [HttpPut("{matterId}/documents/{documentId}")]
            public async Task&lt;IActionResult&gt; UpdateDocument(
                Guid matterId, 
                Guid documentId, 
                [FromBody] DocumentForUpdateDto document)
            {
                // Comprehensive document update validation
                var validationResults = _validationService.ValidateDocumentForUpdate(document);
                var errors = validationResults.ToList();
                
                if (errors.Any())
                {
                    // Create detailed validation error response
                    var errorResponse = new ValidationProblemDetails();
                    
                    foreach (var error in errors)
                    {
                        var propertyName = error.MemberNames.FirstOrDefault() ?? "General";
                        
                        if (!errorResponse.Errors.ContainsKey(propertyName))
                            errorResponse.Errors[propertyName] = new List&lt;string&gt;();
                            
                        ((List&lt;string&gt;)errorResponse.Errors[propertyName]).Add(error.ErrorMessage ?? "Validation error");
                    }
                    
                    _logger.LogWarning("Document update validation failed for document {DocumentId}: {ErrorCount} errors",
                        documentId, errors.Count);
                        
                    return BadRequest(errorResponse);
                }
                
                // Validation passed - proceed with document update
                var updatedDocument = await _documentService.UpdateAsync(documentId, document);
                
                _logger.LogInformation("Document {DocumentId} updated successfully", documentId);
                return Ok(updatedDocument);
            }
            
            // Batch update validation example
            public async Task&lt;BatchOperationResult&gt; UpdateMultipleDocuments(
                Dictionary&lt;Guid, DocumentForUpdateDto&gt; documentUpdates)
            {
                var results = new BatchOperationResult();
                
                foreach (var kvp in documentUpdates)
                {
                    var documentId = kvp.Key;
                    var document = kvp.Value;
                    
                    // Validate each document update
                    var validationResults = _validationService.ValidateDocumentForUpdate(document);
                    var errors = validationResults.ToList();
                    
                    if (errors.Any())
                    {
                        results.AddFailure(documentId, "Validation failed", errors);
                    }
                    else
                    {
                        // Validation passed - add to successful updates
                        results.AddSuccess(documentId);
                    }
                }
                
                return results;
            }
            </code>
            </example>
        </member>
        <member name="M:ADMS.API.Services.IValidationService.ValidateEmail(System.String,System.String)">
            <summary>
            Validates whether the provided string represents a valid email address format.
            </summary>
            <param name="email">
            The email address string to validate for proper format and structure.
            Should conform to standard email address format (local-part@domain.tld).
            Can be null or empty - implementations should handle these cases appropriately.
            </param>
            <param name="parameterName">
            The name of the parameter being validated for error reporting and logging purposes.
            Used in diagnostic logging and error reporting to identify which parameter failed validation.
            Should match the actual parameter name for consistency and debugging support.
            </param>
            <returns>
            true if the email address format is valid according to standard email validation rules;
            false if the email format is invalid, null, empty, or fails validation checks.
            </returns>
            <remarks>
            This method provides comprehensive email validation including:
            
            Email Format Validation:
            - Basic RFC 822 format compliance checking for standard email structure
            - Local part validation (portion before @) for acceptable characters and length
            - Domain part validation (portion after @) for proper domain format
            - Top-level domain (TLD) validation for acceptable domain extensions
            - Special character handling and escape sequence validation where applicable
            
            Security Validation Features:
            - Prevention of email header injection attacks through format validation
            - Validation against malicious email format strings and attack patterns
            - Protection against SMTP injection attempts through input sanitization
            - Ensures proper email format for system notifications and communications
            - Integration with anti-spam and email security best practices
            
            Format Support and Compatibility:
            - Support for international domain names and Unicode characters
            - Validation of common email address formats used in business scenarios
            - Handling of plus addressing and sub-addressing formats where appropriate
            - Compatibility with modern email systems and address formats
            - Support for quoted local parts and special character scenarios
            
            Performance and Efficiency:
            - Efficient regex-based validation for fast email format checking
            - Compiled regular expressions for optimal performance in high-frequency scenarios
            - Minimal memory allocation during validation operations
            - Thread-safe validation suitable for concurrent email validation
            - Integration with caching strategies for frequently validated patterns
            
            Error Handling and Logging:
            - Comprehensive logging of email validation failures for debugging
            - Parameter context information for troubleshooting validation issues
            - Integration with structured logging frameworks for monitoring
            - Diagnostic information for email format validation patterns
            - Support for validation metrics collection and analysis
            
            The validation covers common scenarios including:
            - Standard business email addresses (user@company.com)
            - Personal email addresses with various providers
            - Educational and government email formats
            - International email addresses with Unicode domains
            - Subaddressing and alias formats where supported
            
            Note: While comprehensive, this validation focuses on format correctness
            rather than email deliverability or existence verification. For production
            email validation, consider additional verification steps such as:
            - SMTP verification for email deliverability
            - Domain MX record validation for mail server existence
            - Email verification services for comprehensive validation
            - Integration with email reputation and blacklist services
            </remarks>
            <example>
            <code>
            // Basic email validation in user registration
            public async Task&lt;IActionResult&gt; RegisterUser(UserRegistrationDto registration)
            {
                if (!_validationService.ValidateEmail(registration.Email, nameof(registration.Email)))
                {
                    return BadRequest("Please provide a valid email address");
                }
                
                // Email format is valid - continue with registration
                var user = await _userService.CreateAsync(registration);
                return Ok(user);
            }
            
            // Bulk email validation for mailing list
            public ValidationResult ValidateEmailList(List&lt;string&gt; emailAddresses)
            {
                var invalidEmails = new List&lt;string&gt;();
                
                foreach (var email in emailAddresses)
                {
                    if (!_validationService.ValidateEmail(email, "EmailAddress"))
                    {
                        invalidEmails.Add(email);
                    }
                }
                
                if (invalidEmails.Any())
                {
                    return ValidationResult.Failed(
                        $"Invalid email addresses: {string.Join(", ", invalidEmails)}");
                }
                
                return ValidationResult.Success();
            }
            </code>
            </example>
        </member>
        <member name="M:ADMS.API.Services.IValidationService.ValidateFileExtension(System.String,System.String)">
            <summary>
            Validates whether the provided string represents a valid file extension format.
            </summary>
            <param name="extension">
            The file extension string to validate for proper format and security compliance.
            Should be a standard file extension format (with or without leading dot).
            Common examples include "txt", ".pdf", "docx", ".jpg", etc.
            </param>
            <param name="parameterName">
            The name of the parameter being validated for error reporting and logging purposes.
            Used in diagnostic logging and error reporting to identify which parameter failed validation.
            Should match the actual parameter name for consistency and debugging support.
            </param>
            <returns>
            true if the file extension format is valid and meets security requirements;
            false if the extension format is invalid, potentially unsafe, or fails validation checks.
            </returns>
            <remarks>
            This method validates file extensions for multiple important purposes:
            
            Security Validation:
            - Prevention of malicious file uploads through extension validation
            - Blocking of executable file extensions that could pose security risks
            - Validation against known dangerous file types and attack vectors
            - Protection against file type spoofing and masquerading attacks
            - Integration with file type allow-lists and security policies
            
            Format Consistency:
            - Ensures consistent file extension format across the application
            - Validates extension length within reasonable limits (typically 2-5 characters)
            - Supports both dotted (.txt) and non-dotted (txt) extension formats
            - Alphanumeric character validation for standard file extensions
            - Prevention of special characters that could cause file system issues
            
            File Type Management:
            - Supports file type identification and handling based on extension
            - Integration with MIME type validation and content type detection
            - Database storage requirements and field length constraints
            - File processing pipeline integration for type-specific handling
            - Content delivery and download functionality support
            
            Business Rule Integration:
            - Validation against organization-specific file type policies
            - Integration with document management classification systems
            - Support for workflow-specific file type requirements
            - Compliance validation for regulatory file type restrictions
            - Integration with storage and archival policies based on file types
            
            Performance Features:
            - Efficient regex-based validation for fast extension checking
            - Compiled regular expressions for optimal performance
            - Thread-safe validation suitable for concurrent file processing
            - Minimal memory allocation during validation operations
            - Integration with caching strategies for validation rule lookup
            
            The validation supports common file extension scenarios:
            - Standard document formats (.pdf, .docx, .xlsx, .pptx)
            - Image formats (.jpg, .png, .gif, .bmp, .tiff)
            - Text formats (.txt, .rtf, .csv, .xml, .json)
            - Archive formats (.zip, .rar, .7z, .tar, .gz)
            - Multimedia formats (.mp3, .mp4, .avi, .wav)
            
            Security considerations include:
            - Blocking of executable extensions (.exe, .bat, .cmd, .scr)
            - Prevention of script file uploads (.js, .vbs, .ps1, .sh)
            - Protection against double extensions and file system attacks
            - Integration with antivirus and malware scanning systems
            - Compliance with organizational security policies
            
            The method provides robust file extension validation while maintaining
            flexibility for legitimate business file types and use cases.
            </remarks>
            <example>
            <code>
            // File upload validation with extension checking
            [HttpPost("upload")]
            public async Task&lt;IActionResult&gt; UploadFile(IFormFile file)
            {
                var extension = Path.GetExtension(file.FileName);
                
                if (!_validationService.ValidateFileExtension(extension, nameof(extension)))
                {
                    return BadRequest($"File extension '{extension}' is not allowed or invalid format");
                }
                
                // Extension is valid - proceed with file processing
                var result = await _fileService.ProcessUploadAsync(file);
                return Ok(result);
            }
            
            // Document creation with extension validation
            public async Task&lt;ValidationResult&gt; ValidateDocumentCreation(DocumentForCreationDto document)
            {
                var errors = new List&lt;string&gt;();
                
                // Validate file extension format and security
                if (!_validationService.ValidateFileExtension(document.Extension, nameof(document.Extension)))
                {
                    errors.Add($"File extension '{document.Extension}' is invalid or not allowed");
                }
                
                // Additional business rule validation...
                return errors.Any() ? ValidationResult.Failed(errors) : ValidationResult.Success();
            }
            </code>
            </example>
        </member>
        <member name="M:ADMS.API.Services.IValidationService.ValidateMimeType(System.String,System.String)">
            <summary>
            Validates whether the provided string represents a valid MIME type format.
            </summary>
            <param name="mimeType">
            The MIME type string to validate for proper format and structure.
            Should conform to standard MIME type format (type/subtype).
            Common examples include "text/plain", "application/pdf", "image/jpeg", etc.
            </param>
            <param name="parameterName">
            The name of the parameter being validated for error reporting and logging purposes.
            Used in diagnostic logging and error reporting to identify which parameter failed validation.
            Should match the actual parameter name for consistency and debugging support.
            </param>
            <returns>
            true if the MIME type format is valid and conforms to standard specifications;
            false if the MIME type format is invalid, malformed, or fails validation checks.
            </returns>
            <remarks>
            This method validates MIME types for comprehensive content type management:
            
            MIME Type Format Validation:
            - Standard type/subtype format validation (e.g., "text/plain", "application/json")
            - Support for vendor-specific MIME types (e.g., "application/vnd.ms-excel")
            - Parameter validation for parameterized MIME types (e.g., "text/html; charset=utf-8")
            - Special character validation for acceptable MIME type characters
            - Length validation within reasonable limits for storage and processing
            
            Security and Content Type Management:
            - Prevention of MIME type spoofing attacks through format validation
            - Validation against malicious content type headers and injection attempts
            - Ensures proper MIME type format for secure content negotiation
            - Protection against content type confusion attacks
            - Integration with file upload security and content validation
            
            Format Support and Standards Compliance:
            - RFC-compliant MIME type format validation
            - Support for standard MIME types (text, application, image, audio, video)
            - Vendor-specific and experimental MIME type format support
            - Multi-part MIME type validation for complex content scenarios
            - Integration with HTTP content negotiation and API response formatting
            
            Integration Features:
            - HTTP content type header validation for API requests and responses
            - File upload security validation to ensure content type consistency
            - Content negotiation support for RESTful API operations
            - Database storage format consistency and validation
            - Integration with content delivery and caching systems
            
            Performance and Efficiency:
            - Efficient regex-based validation for fast MIME type format checking
            - Compiled regular expressions for optimal performance in high-frequency scenarios
            - Minimal memory allocation during validation operations
            - Thread-safe validation suitable for concurrent content processing
            - Integration with caching strategies for frequently validated MIME types
            
            Common MIME Type Categories Supported:
            - Text types: text/plain, text/html, text/css, text/javascript
            - Application types: application/json, application/pdf, application/zip
            - Image types: image/jpeg, image/png, image/gif, image/svg+xml
            - Audio types: audio/mpeg, audio/wav, audio/ogg, audio/mp4
            - Video types: video/mp4, video/mpeg, video/quicktime, video/webm
            - Multipart types: multipart/form-data, multipart/mixed
            
            Security Considerations:
            - Validation against known malicious MIME types and attack patterns
            - Prevention of MIME type confusion and content type spoofing
            - Integration with content security policies and file upload restrictions
            - Compliance with web security standards and best practices
            - Support for content type validation in security-sensitive applications
            
            The method provides robust MIME type validation suitable for:
            - Web API content negotiation and response formatting
            - File upload validation and security checking
            - Content management system type validation
            - Email attachment processing and validation
            - Media processing and content delivery systems
            </remarks>
            <example>
            <code>
            // API content type validation
            [HttpPost]
            [Consumes("application/json", "application/xml")]
            public async Task&lt;IActionResult&gt; ProcessContent([FromBody] object content)
            {
                var contentType = Request.ContentType;
                
                if (!_validationService.ValidateMimeType(contentType, nameof(contentType)))
                {
                    return BadRequest($"Invalid or unsupported content type: {contentType}");
                }
                
                // MIME type is valid - continue processing
                var result = await _contentService.ProcessAsync(content);
                return Ok(result);
            }
            
            // File upload MIME type validation
            public async Task&lt;ValidationResult&gt; ValidateFileUpload(IFormFile file)
            {
                var errors = new List&lt;string&gt;();
                
                // Validate MIME type format and security
                if (!_validationService.ValidateMimeType(file.ContentType, "ContentType"))
                {
                    errors.Add($"Invalid MIME type format: {file.ContentType}");
                }
                
                // Additional file validation logic...
                return errors.Any() ? ValidationResult.Failed(errors) : ValidationResult.Success();
            }
            
            // Document metadata validation
            public IEnumerable&lt;ValidationResult&gt; ValidateDocumentMetadata(DocumentForCreationDto document)
            {
                var results = new List&lt;ValidationResult&gt;();
                
                if (!_validationService.ValidateMimeType(document.MimeType, nameof(document.MimeType)))
                {
                    results.Add(new ValidationResult(
                        "Document MIME type format is invalid",
                        new[] { nameof(document.MimeType) }));
                }
                
                return results;
            }
            </code>
            </example>
        </member>
        <member name="M:ADMS.API.Services.IValidationService.ValidateChecksum(System.String,System.String)">
            <summary>
            Validates whether the provided string represents a valid checksum format for data integrity verification.
            </summary>
            <param name="checksum">
            The checksum string to validate for proper format and structure.
            Should be a hexadecimal string representing a hash value (typically SHA256).
            Common formats include 64-character SHA256 hashes or 32-character MD5 hashes.
            </param>
            <param name="parameterName">
            The name of the parameter being validated for error reporting and logging purposes.
            Used in diagnostic logging and error reporting to identify which parameter failed validation.
            Should match the actual parameter name for consistency and debugging support.
            </param>
            <returns>
            true if the checksum format is valid and represents a proper hash value;
            false if the checksum format is invalid, malformed, or fails validation checks.
            </returns>
            <remarks>
            This method validates checksums for comprehensive data integrity management:
            
            Checksum Format Validation:
            - SHA256 hash validation (64-character hexadecimal strings)
            - MD5 hash validation (32-character hexadecimal strings) where supported
            - Hexadecimal character validation (0-9, A-F, a-f) for proper hash format
            - Length validation for specific hash algorithm requirements
            - Case-insensitive validation supporting both uppercase and lowercase hex
            
            Security and Data Integrity:
            - Ensures checksum integrity for file verification and data validation
            - Validates against checksum manipulation attacks and tampering
            - Provides data integrity validation for secure file operations
            - Supports secure file verification workflows and audit trails
            - Integration with cryptographic hash validation and verification systems
            
            The method specifically validates checksums used throughout the ADMS system
            for file integrity verification and ensures consistent checksum format
            across all document management operations.
            </remarks>
            <example>
            <code>
            // File integrity validation
            public async Task&lt;ValidationResult&gt; ValidateFileIntegrity(DocumentForCreationDto document)
            {
                if (!_validationService.ValidateChecksum(document.Checksum, nameof(document.Checksum)))
                {
                    return ValidationResult.Failed("Invalid checksum format for file integrity verification");
                }
                
                return ValidationResult.Success();
            }
            </code>
            </example>
        </member>
        <member name="T:ADMS.API.Services.IVirusScanner">
            <summary>
            Defines the contract for enterprise-grade virus scanning services with comprehensive malware detection capabilities.
            </summary>
            <remarks>
            This interface provides a comprehensive contract for virus scanning implementations including:
            
            Core Functionality:
            - Asynchronous virus detection for file streams with cancellation support
            - Comprehensive malware scanning including viruses, trojans, malware, and suspicious content
            - High-performance scanning operations optimized for large file processing
            - Detailed scan results with comprehensive threat information and metadata
            - Support for multiple scanning engines and threat detection technologies
            
            Security Features:
            - Real-time threat detection with up-to-date virus definitions
            - Multi-layered scanning approach with signature and behavioral analysis
            - Quarantine and threat mitigation recommendations
            - Integration with threat intelligence feeds for emerging threats
            - Compliance support for security standards and regulations
            
            Performance Characteristics:
            - Asynchronous operations for non-blocking file processing
            - Cancellation token support for responsive user experience
            - Stream-based processing for memory-efficient large file handling
            - Configurable timeout and resource management
            - Optimized scanning algorithms for high-throughput scenarios
            
            Integration Features:
            - Compatible with cloud-based and on-premises scanning solutions
            - Support for multiple antivirus engines and detection technologies
            - Integration with file upload pipelines and document management systems
            - Extensible architecture for custom threat detection logic
            - Comprehensive logging and monitoring capabilities
            
            Implementation Considerations:
            - Implementations should handle various file formats and encoding types
            - Proper resource management and cleanup of temporary scanning files
            - Thread-safe operations for concurrent scanning scenarios
            - Graceful handling of scanning service unavailability or errors
            - Configuration support for scanning sensitivity and detection rules
            
            Security Best Practices:
            - Regular updates of virus definitions and threat signatures
            - Secure handling of potentially infected file content during scanning
            - Proper disposal of file streams and temporary resources
            - Audit logging of all scanning activities for compliance
            - Integration with incident response procedures for threat detection
            
            Common Use Cases:
            - File upload validation in web applications and APIs
            - Document management system security screening
            - Email attachment scanning and filtering
            - Cloud storage security validation
            - Automated malware detection in file processing pipelines
            
            Supported Scenarios:
            - Real-time file scanning during upload operations
            - Batch processing of multiple files for security validation
            - Scheduled scanning of stored files and documents
            - Integration with content delivery networks for security
            - API-based scanning services for distributed applications
            
            The interface is designed to be:
            - Extensible: Easy to implement with various scanning technologies
            - Performant: Asynchronous operations with cancellation support
            - Secure: Comprehensive threat detection with proper resource handling
            - Observable: Rich result information for monitoring and compliance
            - Reliable: Robust error handling and graceful degradation capabilities
            </remarks>
            <example>
            <code>
            // Basic virus scanning implementation
            public class MyVirusScannerService : IVirusScanner
            {
                public async Task&lt;VirusScanResult&gt; ScanFileForVirusesAsync(
                    Stream fileStream, 
                    CancellationToken cancellationToken = default)
                {
                    // Implementation details...
                    return new VirusScanResult 
                    { 
                        IsClean = true, 
                        ScanDuration = TimeSpan.FromSeconds(1.5),
                        ThreatDetails = null 
                    };
                }
            }
            
            // Usage in file upload controller
            [HttpPost("upload")]
            public async Task&lt;IActionResult&gt; UploadFile(
                IFormFile file, 
                CancellationToken cancellationToken)
            {
                using var stream = file.OpenReadStream();
                var scanResult = await _virusScanner.ScanFileForVirusesAsync(stream, cancellationToken);
                
                if (!scanResult.IsClean)
                {
                    _logger.LogWarning("Virus detected: {ThreatInfo}", scanResult.ThreatDetails?.ThreatName);
                    return BadRequest("File contains malicious content and cannot be processed");
                }
                
                // Continue with file processing...
                return Ok("File uploaded successfully");
            }
            </code>
            </example>
        </member>
        <member name="M:ADMS.API.Services.IVirusScanner.ScanFileForVirusesAsync(System.IO.Stream,System.Threading.CancellationToken)">
            <summary>
            Performs comprehensive virus scanning of the provided file stream with detailed result information.
            </summary>
            <param name="fileStream">
            The file stream to scan for viruses and malicious content.
            Must be a readable stream containing the file data to be analyzed.
            The stream position will be reset to the beginning before scanning.
            Stream must remain open during the entire scanning operation.
            </param>
            <param name="cancellationToken">
            Optional cancellation token to allow cancellation of long-running scan operations.
            Implementations should respect cancellation requests to provide responsive user experience.
            Default value allows the operation to run to completion without cancellation.
            </param>
            <returns>
            A task that represents the asynchronous scanning operation.
            The task result contains a VirusScanResult with comprehensive information about:
            - Whether the file is clean or contains malicious content
            - Detailed threat information including threat names and types
            - Scanning metadata including duration and scanner information
            - Recommended actions for threat mitigation if applicable
            - Additional context for logging and compliance reporting
            </returns>
            <remarks>
            This method provides comprehensive virus scanning including:
            
            Scanning Capabilities:
            - Real-time virus detection using up-to-date threat definitions
            - Multi-layered analysis including signature-based and behavioral detection
            - Support for various file formats and content types
            - Detection of viruses, trojans, malware, spyware, and suspicious content
            - Integration with cloud-based threat intelligence for emerging threats
            
            Performance Characteristics:
            - Asynchronous operation for non-blocking execution
            - Memory-efficient stream processing for large files
            - Configurable timeout and resource management
            - Cancellation token support for responsive cancellation
            - Optimized scanning algorithms for high-throughput scenarios
            
            Security Features:
            - Secure handling of potentially malicious content during scanning
            - Proper isolation of scanning processes from system resources
            - Comprehensive threat classification and severity assessment
            - Integration with quarantine and mitigation procedures
            - Audit logging of all scanning activities for compliance
            
            Error Handling:
            - Graceful handling of corrupted or unreadable file content
            - Proper exception handling for scanning service failures
            - Fallback mechanisms for scanner unavailability
            - Detailed error information for troubleshooting and monitoring
            - Recovery procedures for transient scanning failures
            
            Resource Management:
            - Proper cleanup of temporary files and resources
            - Memory-efficient processing of large file streams
            - Thread-safe operations for concurrent scanning scenarios
            - Configurable resource limits and timeout handling
            - Integration with system resource monitoring
            
            Implementation Requirements:
            - Must reset stream position to beginning before scanning
            - Should not dispose the provided file stream
            - Must handle various file formats and encoding types
            - Should provide detailed scan results for all scenarios
            - Must implement proper cancellation token handling
            
            Common Usage Patterns:
            - File upload validation in web applications
            - Document management system security screening
            - Automated scanning in file processing pipelines
            - Real-time content filtering and validation
            - Batch processing security validation
            
            The method is designed to be:
            - Reliable: Consistent results with proper error handling
            - Performant: Efficient processing with cancellation support
            - Secure: Safe handling of potentially malicious content
            - Observable: Rich result information for monitoring
            - Compliant: Audit trail support for security requirements
            </remarks>
            <exception cref="T:System.ArgumentNullException">
            Thrown when fileStream parameter is null.
            Implementations must validate input parameters and provide appropriate error handling.
            </exception>
            <exception cref="T:System.ArgumentException">
            Thrown when fileStream is not readable or is in an invalid state.
            Implementations should validate stream accessibility before processing.
            </exception>
            <exception cref="T:System.OperationCanceledException">
            Thrown when the operation is canceled via the cancellation token.
            Implementations should properly handle cancellation requests during scanning.
            </exception>
            <exception cref="T:System.InvalidOperationException">
            Thrown when the virus scanner is not properly configured or available.
            Implementations should validate scanner readiness before processing.
            </exception>
            <exception cref="T:System.TimeoutException">
            Thrown when the scanning operation exceeds configured timeout limits.
            Implementations should enforce reasonable timeout policies for responsiveness.
            </exception>
            <example>
            <code>
            // Example implementation with comprehensive error handling
            public async Task&lt;VirusScanResult&gt; ScanFileForVirusesAsync(
                Stream fileStream, 
                CancellationToken cancellationToken = default)
            {
                ArgumentNullException.ThrowIfNull(fileStream);
                
                if (!fileStream.CanRead)
                    throw new ArgumentException("Stream must be readable", nameof(fileStream));
                
                try
                {
                    // Reset stream position for scanning
                    if (fileStream.CanSeek)
                        fileStream.Position = 0;
                    
                    var startTime = DateTime.UtcNow;
                    
                    // Perform virus scanning (implementation specific)
                    var scanResult = await PerformVirusScan(fileStream, cancellationToken);
                    
                    var endTime = DateTime.UtcNow;
                    
                    return new VirusScanResult
                    {
                        IsClean = scanResult.IsClean,
                        ThreatDetails = scanResult.ThreatInfo,
                        ScanDuration = endTime - startTime,
                        ScannerVersion = GetScannerVersion(),
                        ScanTimestamp = endTime
                    };
                }
                catch (OperationCanceledException)
                {
                    _logger.LogInformation("Virus scan operation was canceled");
                    throw;
                }
                catch (Exception ex)
                {
                    _logger.LogError(ex, "Error during virus scanning operation");
                    
                    // Return inconclusive result for safety
                    return VirusScanResult.CreateErrorResult(
                        "Scanning failed - treating as potentially unsafe",
                        ex.Message);
                }
            }
            
            // Usage in file processing pipeline
            public async Task&lt;ProcessingResult&gt; ProcessUploadedFile(
                Stream fileStream,
                CancellationToken cancellationToken = default)
            {
                // Step 1: Virus scanning
                var scanResult = await _virusScanner.ScanFileForVirusesAsync(fileStream, cancellationToken);
                
                if (!scanResult.IsClean)
                {
                    // Log security event
                    _securityLogger.LogSecurityEvent("VirusDetected", new 
                    {
                        ThreatName = scanResult.ThreatDetails?.ThreatName,
                        ThreatType = scanResult.ThreatDetails?.ThreatType,
                        ScanDuration = scanResult.ScanDuration,
                        Timestamp = scanResult.ScanTimestamp
                    });
                    
                    // Trigger security response
                    await _securityService.HandleThreatDetection(scanResult.ThreatDetails);
                    
                    return ProcessingResult.SecurityRejected(scanResult.ThreatDetails?.ThreatName);
                }
                
                // Continue with file processing...
                return await ProcessCleanFile(fileStream, cancellationToken);
            }
            </code>
            </example>
        </member>
        <member name="M:ADMS.API.Services.IVirusScanner.CheckHealthAsync(System.Threading.CancellationToken)">
            <summary>
            Validates whether the virus scanner is properly configured and operational.
            </summary>
            <param name="cancellationToken">Optional cancellation token for the health check operation.</param>
            <returns>
            A task that represents the asynchronous health check operation.
            The task result contains a ScannerHealthResult with information about:
            - Scanner availability and operational status
            - Virus definition version and last update timestamp
            - Performance metrics and operational statistics
            - Configuration validation and system requirements
            - Recommendations for optimization or maintenance
            </returns>
            <remarks>
            This method provides comprehensive health checking including:
            
            Health Check Capabilities:
            - Verification of scanner service availability and responsiveness
            - Validation of virus definition currency and update status
            - Assessment of system resources and performance metrics
            - Configuration validation and compatibility checking
            - Integration testing with dependent services and components
            
            Operational Monitoring:
            - Real-time status of scanning engines and detection capabilities
            - Performance metrics including scan speed and resource usage
            - Queue status and processing capacity for high-volume scenarios
            - Error rates and failure patterns for reliability assessment
            - Maintenance schedules and update requirements
            
            The health check is designed to be:
            - Fast: Quick response time for operational monitoring
            - Comprehensive: Complete assessment of scanner capabilities
            - Non-invasive: Minimal impact on scanning performance
            - Informative: Detailed status information for troubleshooting
            - Actionable: Clear recommendations for issue resolution
            
            Common usage scenarios:
            - Application startup validation and readiness checks
            - Periodic health monitoring and alerting systems
            - Load balancer health probe endpoints
            - Diagnostic troubleshooting and maintenance procedures
            - Compliance reporting and audit requirements
            </remarks>
            <example>
            <code>
            // Health check implementation
            public async Task&lt;ScannerHealthResult&gt; CheckHealthAsync(CancellationToken cancellationToken = default)
            {
                var healthResult = new ScannerHealthResult();
                
                try
                {
                    // Check scanner service connectivity
                    var serviceAvailable = await PingServiceAsync(cancellationToken);
                    healthResult.IsAvailable = serviceAvailable;
                    
                    if (serviceAvailable)
                    {
                        // Check virus definitions
                        var definitionInfo = await GetDefinitionInfoAsync(cancellationToken);
                        healthResult.DefinitionVersion = definitionInfo.Version;
                        healthResult.LastDefinitionUpdate = definitionInfo.LastUpdate;
                        healthResult.DefinitionsAreCurrent = definitionInfo.IsCurrent;
                        
                        // Performance metrics
                        var performanceMetrics = await GetPerformanceMetricsAsync(cancellationToken);
                        healthResult.AverageScanTime = performanceMetrics.AverageScanTime;
                        healthResult.SuccessRate = performanceMetrics.SuccessRate;
                    }
                    
                    healthResult.OverallHealth = DetermineOverallHealth(healthResult);
                    return healthResult;
                }
                catch (Exception ex)
                {
                    return ScannerHealthResult.CreateErrorResult(ex.Message);
                }
            }
            
            // Usage in health check endpoint
            [HttpGet("health")]
            public async Task&lt;IActionResult&gt; HealthCheck()
            {
                var healthResult = await _virusScanner.CheckHealthAsync();
                
                if (healthResult.OverallHealth == HealthStatus.Healthy)
                {
                    return Ok(healthResult);
                }
                else
                {
                    return StatusCode(503, healthResult); // Service Unavailable
                }
            }
            </code>
            </example>
        </member>
        <member name="M:ADMS.API.Services.IVirusScanner.GetScannerInfo">
            <summary>
            Retrieves comprehensive information about the virus scanner configuration and capabilities.
            </summary>
            <returns>
            A ScannerInfo object containing detailed information about:
            - Scanner name, version, and vendor information
            - Supported file formats and detection capabilities
            - Configuration settings and operational parameters
            - Performance characteristics and resource requirements
            - Integration details and compatibility information
            </returns>
            <remarks>
            This method provides static information about the scanner implementation including:
            
            Scanner Identification:
            - Product name, version, and build information
            - Vendor details and support contact information
            - License information and usage limitations
            - Installation details and system requirements
            
            Capability Information:
            - Supported file formats and content types
            - Detection technologies and scanning methods
            - Performance characteristics and throughput limits
            - Integration features and API compatibility
            
            The information is useful for:
            - System documentation and compliance reporting
            - Integration planning and compatibility assessment
            - Performance tuning and capacity planning
            - Troubleshooting and support scenarios
            - Audit trails and security assessments
            </remarks>
            <example>
            <code>
            // Get scanner information for documentation
            var scannerInfo = _virusScanner.GetScannerInfo();
            
            _logger.LogInformation("Using virus scanner: {ScannerName} v{Version}",
                scannerInfo.ProductName, scannerInfo.Version);
            
            // Use for compatibility checking
            if (scannerInfo.SupportedFormats.Contains("application/pdf"))
            {
                // Safe to scan PDF files
                await _virusScanner.ScanFileForVirusesAsync(pdfStream);
            }
            </code>
            </example>
        </member>
        <member name="T:ADMS.API.Services.VirusScanResult">
            <summary>
            Represents the result of a virus scanning operation with comprehensive threat and metadata information.
            </summary>
            <remarks>
            This class provides complete information about virus scanning results including:
            - Clean/infected status with confidence levels
            - Detailed threat information for detected malware
            - Scanning metadata including performance metrics
            - Recommendations for threat handling and mitigation
            - Compliance and audit information for security reporting
            </remarks>
        </member>
        <member name="P:ADMS.API.Services.VirusScanResult.IsClean">
            <summary>
            Gets or sets a value indicating whether the scanned file is free from malicious content.
            </summary>
            <remarks>
            - true: File is clean and safe for processing
            - false: File contains malicious content and should be rejected
            
            This property represents the primary scan result and should be used
            for security decisions regarding file processing and storage.
            </remarks>
        </member>
        <member name="P:ADMS.API.Services.VirusScanResult.ThreatDetails">
            <summary>
            Gets or sets detailed information about detected threats, if any.
            </summary>
            <remarks>
            Contains comprehensive threat information including:
            - Threat name and classification
            - Severity level and risk assessment
            - Detection method and confidence level
            - Recommended mitigation actions
            
            This property is null when IsClean is true.
            </remarks>
        </member>
        <member name="P:ADMS.API.Services.VirusScanResult.ScanDuration">
            <summary>
            Gets or sets the duration of the scanning operation.
            </summary>
            <remarks>
            Provides performance metrics for:
            - Monitoring scanning performance
            - Capacity planning and optimization
            - SLA compliance and reporting
            - Performance troubleshooting
            </remarks>
        </member>
        <member name="P:ADMS.API.Services.VirusScanResult.ScanTimestamp">
            <summary>
            Gets or sets the timestamp when the scan was completed.
            </summary>
            <remarks>
            Used for:
            - Audit logging and compliance reporting
            - Result freshness validation
            - Performance monitoring and analysis
            - Debugging and troubleshooting
            </remarks>
        </member>
        <member name="P:ADMS.API.Services.VirusScanResult.ScannerName">
            <summary>
            Gets or sets the name of the scanner that performed the scan.
            </summary>
            <remarks>
            Identifies the specific scanner implementation that performed the scan.
            Important for audit trails and compatibility tracking.
            </remarks>
        </member>
        <member name="P:ADMS.API.Services.VirusScanResult.ScannerVersion">
            <summary>
            Gets or sets the version information of the scanner that performed the scan.
            </summary>
            <remarks>
            Includes information about:
            - Scanner engine version
            - Virus definition version
            - Detection capability version
            - Configuration identifier
            
            Important for audit trails and result validation.
            </remarks>
        </member>
        <member name="P:ADMS.API.Services.VirusScanResult.Metadata">
            <summary>
            Gets or sets additional metadata about the scanning operation.
            </summary>
            <remarks>
            May include:
            - File size and type information
            - Scanning method details
            - Performance metrics
            - Configuration parameters used
            - Integration context information
            </remarks>
        </member>
        <member name="M:ADMS.API.Services.VirusScanResult.CreateCleanResult(System.TimeSpan,System.String,System.String)">
            <summary>
            Creates a VirusScanResult indicating a clean file.
            </summary>
            <param name="scanDuration">The duration of the scan operation.</param>
            <param name="scannerName">Optional scanner name information.</param>
            <param name="scannerVersion">Optional scanner version information.</param>
            <returns>A VirusScanResult indicating the file is clean.</returns>
        </member>
        <member name="M:ADMS.API.Services.VirusScanResult.CreateThreatDetectedResult(ADMS.API.Services.ThreatDetails,System.TimeSpan,System.String,System.String)">
            <summary>
            Creates a VirusScanResult indicating a threat was detected.
            </summary>
            <param name="threatDetails">Details about the detected threat.</param>
            <param name="scanDuration">The duration of the scan operation.</param>
            <param name="scannerName">Optional scanner name information.</param>
            <param name="scannerVersion">Optional scanner version information.</param>
            <returns>A VirusScanResult indicating a threat was detected.</returns>
        </member>
        <member name="M:ADMS.API.Services.VirusScanResult.CreateErrorResult(System.String,System.String)">
            <summary>
            Creates a VirusScanResult indicating a scanning error occurred.
            </summary>
            <param name="errorMessage">The error message describing the scanning failure.</param>
            <param name="errorDetails">Additional error details.</param>
            <returns>A VirusScanResult indicating a scanning error (treated as unsafe).</returns>
        </member>
        <member name="T:ADMS.API.Services.ThreatDetails">
            <summary>
            Provides detailed information about detected threats.
            </summary>
        </member>
        <member name="P:ADMS.API.Services.ThreatDetails.ThreatName">
            <summary>
            Gets or sets the name or signature of the detected threat.
            </summary>
        </member>
        <member name="P:ADMS.API.Services.ThreatDetails.ThreatType">
            <summary>
            Gets or sets the classification type of the threat.
            </summary>
        </member>
        <member name="P:ADMS.API.Services.ThreatDetails.Severity">
            <summary>
            Gets or sets the severity level of the threat.
            </summary>
        </member>
        <member name="P:ADMS.API.Services.ThreatDetails.Description">
            <summary>
            Gets or sets a detailed description of the threat.
            </summary>
        </member>
        <member name="P:ADMS.API.Services.ThreatDetails.DetectionMethod">
            <summary>
            Gets or sets the method used to detect this threat.
            </summary>
            <remarks>
            Examples include:
            - "Signature-based detection"
            - "Heuristic analysis"
            - "Behavioral analysis"
            - "Machine learning detection"
            </remarks>
        </member>
        <member name="P:ADMS.API.Services.ThreatDetails.ConfidenceLevel">
            <summary>
            Gets or sets the confidence level of the threat detection.
            </summary>
            <remarks>
            Range: 0.0 to 1.0 where 1.0 indicates highest confidence.
            </remarks>
        </member>
        <member name="P:ADMS.API.Services.ThreatDetails.RecommendedAction">
            <summary>
            Gets or sets the recommended action for handling this threat.
            </summary>
        </member>
        <member name="P:ADMS.API.Services.ThreatDetails.AdditionalInfo">
            <summary>
            Gets or sets additional metadata about the threat.
            </summary>
        </member>
        <member name="T:ADMS.API.Services.ThreatType">
            <summary>
            Specifies the type of threat detected during virus scanning.
            </summary>
        </member>
        <member name="F:ADMS.API.Services.ThreatType.Unknown">
            <summary>Unknown or unclassified threat.</summary>
        </member>
        <member name="F:ADMS.API.Services.ThreatType.Virus">
            <summary>Computer virus.</summary>
        </member>
        <member name="F:ADMS.API.Services.ThreatType.Trojan">
            <summary>Trojan horse malware.</summary>
        </member>
        <member name="F:ADMS.API.Services.ThreatType.Worm">
            <summary>Worm malware.</summary>
        </member>
        <member name="F:ADMS.API.Services.ThreatType.Spyware">
            <summary>Spyware or privacy threat.</summary>
        </member>
        <member name="F:ADMS.API.Services.ThreatType.Adware">
            <summary>Adware or unwanted advertising software.</summary>
        </member>
        <member name="F:ADMS.API.Services.ThreatType.Rootkit">
            <summary>Rootkit or system-level threat.</summary>
        </member>
        <member name="F:ADMS.API.Services.ThreatType.Ransomware">
            <summary>Ransomware threat.</summary>
        </member>
        <member name="F:ADMS.API.Services.ThreatType.PotentiallyUnwanted">
            <summary>Potentially unwanted program (PUP).</summary>
        </member>
        <member name="F:ADMS.API.Services.ThreatType.Suspicious">
            <summary>Suspicious or potentially malicious content.</summary>
        </member>
        <member name="F:ADMS.API.Services.ThreatType.ScanningError">
            <summary>Error occurred during scanning.</summary>
        </member>
        <member name="T:ADMS.API.Services.ThreatSeverity">
            <summary>
            Specifies the severity level of detected threats.
            </summary>
        </member>
        <member name="F:ADMS.API.Services.ThreatSeverity.Low">
            <summary>Low severity threat with minimal risk.</summary>
        </member>
        <member name="F:ADMS.API.Services.ThreatSeverity.Medium">
            <summary>Medium severity threat with moderate risk.</summary>
        </member>
        <member name="F:ADMS.API.Services.ThreatSeverity.High">
            <summary>High severity threat requiring immediate attention.</summary>
        </member>
        <member name="F:ADMS.API.Services.ThreatSeverity.Critical">
            <summary>Critical threat requiring urgent action.</summary>
        </member>
        <member name="T:ADMS.API.Services.ScannerHealthResult">
            <summary>
            Represents the health status and operational information of the virus scanner service.
            This class provides comprehensive health monitoring capabilities with support for
            real-time status updates and detailed diagnostic information.
            </summary>
            <remarks>
            This class supports both initialization-time setup and runtime updates to accommodate
            different health checking scenarios and implementation patterns.
            </remarks>
        </member>
        <member name="P:ADMS.API.Services.ScannerHealthResult.IsAvailable">
            <summary>
            Gets or sets a value indicating whether the scanner service is available.
            </summary>
            <remarks>
            This property indicates basic service availability and can be updated during
            health check operations to reflect current connectivity status.
            </remarks>
        </member>
        <member name="P:ADMS.API.Services.ScannerHealthResult.OverallHealth">
            <summary>
            Gets or sets the overall health status of the scanner.
            </summary>
            <remarks>
            This property provides a comprehensive assessment of scanner health and can be
            updated based on the results of multiple health check components.
            </remarks>
        </member>
        <member name="P:ADMS.API.Services.ScannerHealthResult.ScannerName">
            <summary>
            Gets or sets the name of the scanner being monitored.
            </summary>
            <remarks>
            Identifies the specific scanner implementation being health checked.
            Important for monitoring systems that track multiple scanner types.
            </remarks>
        </member>
        <member name="P:ADMS.API.Services.ScannerHealthResult.CheckTimestamp">
            <summary>
            Gets or sets the timestamp when the health check was performed.
            </summary>
            <remarks>
            Provides temporal context for health check results and enables
            freshness validation of health status information.
            </remarks>
        </member>
        <member name="P:ADMS.API.Services.ScannerHealthResult.DefinitionVersion">
            <summary>
            Gets or sets the current virus definition version.
            </summary>
            <remarks>
            Tracks the version of virus definitions currently in use by the scanner.
            Important for ensuring adequate protection against current threats.
            </remarks>
        </member>
        <member name="P:ADMS.API.Services.ScannerHealthResult.LastDefinitionUpdate">
            <summary>
            Gets or sets the timestamp of the last virus definition update.
            </summary>
            <remarks>
            Tracks when virus definitions were last refreshed, which is critical
            for maintaining effective threat detection capabilities.
            </remarks>
        </member>
        <member name="P:ADMS.API.Services.ScannerHealthResult.DefinitionsAreCurrent">
            <summary>
            Gets or sets a value indicating whether virus definitions are current.
            </summary>
            <remarks>
            Indicates whether the virus definitions meet currency requirements
            for effective threat detection. Can be updated during health checks.
            </remarks>
        </member>
        <member name="P:ADMS.API.Services.ScannerHealthResult.ScanningFunctional">
            <summary>
            Gets or sets a value indicating whether scanning functionality is operational.
            </summary>
            <remarks>
            Indicates whether the core scanning functionality is working properly.
            Typically tested using standard test signatures like EICAR.
            </remarks>
        </member>
        <member name="P:ADMS.API.Services.ScannerHealthResult.ResponseTimeMs">
            <summary>
            Gets or sets the response time in milliseconds for scanner operations.
            </summary>
            <remarks>
            Measures the responsiveness of the scanner service for performance monitoring.
            Can be updated with real-time performance measurements.
            </remarks>
        </member>
        <member name="P:ADMS.API.Services.ScannerHealthResult.HealthCheckDuration">
            <summary>
            Gets or sets the duration of the health check operation.
            </summary>
            <remarks>
            Tracks how long the health check itself took to complete.
            Useful for monitoring the overhead of health checking operations.
            </remarks>
        </member>
        <member name="P:ADMS.API.Services.ScannerHealthResult.AverageScanTime">
            <summary>
            Gets or sets the average scan time for performance monitoring.
            </summary>
            <remarks>
            Provides performance metrics for capacity planning and optimization.
            Can be updated with current performance measurements.
            </remarks>
        </member>
        <member name="P:ADMS.API.Services.ScannerHealthResult.SuccessRate">
            <summary>
            Gets or sets the success rate of scanning operations.
            </summary>
            <remarks>
            Range: 0.0 to 1.0 where 1.0 indicates 100% success rate.
            Can be updated with current operational statistics.
            </remarks>
        </member>
        <member name="P:ADMS.API.Services.ScannerHealthResult.ErrorMessage">
            <summary>
            Gets or sets any error messages or diagnostic information.
            </summary>
            <remarks>
            Provides detailed error information when health checks fail.
            Can be updated with current error conditions.
            </remarks>
        </member>
        <member name="P:ADMS.API.Services.ScannerHealthResult.Issues">
            <summary>
            Gets or sets a collection of issues identified during health checking.
            </summary>
            <remarks>
            Provides a comprehensive list of all issues found during health evaluation.
            Can be updated to add new issues as they are discovered.
            </remarks>
        </member>
        <member name="P:ADMS.API.Services.ScannerHealthResult.AdditionalInfo">
            <summary>
            Gets or sets additional health information and metrics.
            </summary>
            <remarks>
            Provides extensible storage for implementation-specific health metrics.
            Can be updated with runtime diagnostic information.
            </remarks>
        </member>
        <member name="M:ADMS.API.Services.ScannerHealthResult.CreateHealthyResult(System.String)">
            <summary>
            Creates a healthy scanner health result with optimal settings.
            </summary>
            <param name="scannerName">Optional name of the scanner.</param>
            <returns>A ScannerHealthResult indicating healthy status.</returns>
            <remarks>
            This factory method creates a health result representing an optimal,
            fully functional scanner with current definitions and good performance.
            </remarks>
        </member>
        <member name="M:ADMS.API.Services.ScannerHealthResult.CreateErrorResult(System.String,System.String,System.TimeSpan)">
            <summary>
            Creates an error health result indicating scanner problems.
            </summary>
            <param name="scannerName">Name of the scanner that failed health check.</param>
            <param name="errorMessage">Description of the health check failure.</param>
            <param name="healthCheckDuration">Duration of the failed health check.</param>
            <returns>A ScannerHealthResult indicating unhealthy status.</returns>
            <remarks>
            This factory method creates a health result representing a scanner
            in an unhealthy state with comprehensive error information.
            </remarks>
        </member>
        <member name="M:ADMS.API.Services.ScannerHealthResult.CreateErrorResult(System.String)">
            <summary>
            Creates an error health result with minimal information for simple error scenarios.
            </summary>
            <param name="errorMessage">Description of the health check failure.</param>
            <returns>A ScannerHealthResult indicating unhealthy status.</returns>
            <remarks>
            This overload provides a simplified way to create error results when
            detailed scanner information is not available.
            </remarks>
        </member>
        <member name="T:ADMS.API.Services.HealthStatus">
            <summary>
            Specifies the health status of the scanner service.
            </summary>
        </member>
        <member name="F:ADMS.API.Services.HealthStatus.Healthy">
            <summary>Scanner is healthy and fully operational.</summary>
        </member>
        <member name="F:ADMS.API.Services.HealthStatus.Warning">
            <summary>Scanner is operational but with some issues or warnings.</summary>
        </member>
        <member name="F:ADMS.API.Services.HealthStatus.Degraded">
            <summary>Scanner is operational but with degraded performance.</summary>
        </member>
        <member name="F:ADMS.API.Services.HealthStatus.Unhealthy">
            <summary>Scanner is not operational.</summary>
        </member>
        <member name="T:ADMS.API.Services.ScannerInfo">
            <summary>
            Provides comprehensive information about the virus scanner implementation.
            </summary>
        </member>
        <member name="P:ADMS.API.Services.ScannerInfo.ProductName">
            <summary>
            Gets or sets the product name of the virus scanner.
            </summary>
        </member>
        <member name="P:ADMS.API.Services.ScannerInfo.ProductVersion">
            <summary>
            Gets or sets the version of the virus scanner.
            </summary>
        </member>
        <member name="P:ADMS.API.Services.ScannerInfo.VendorName">
            <summary>
            Gets or sets the vendor/manufacturer of the scanner.
            </summary>
        </member>
        <member name="P:ADMS.API.Services.ScannerInfo.ScannerType">
            <summary>
            Gets or sets the type or category of the scanner technology.
            </summary>
            <remarks>
            Examples include:
            - "Signature-based Antivirus"
            - "Cloud-based Scanner"
            - "Behavioral Analysis Engine"
            - "Machine Learning Scanner"
            </remarks>
        </member>
        <member name="P:ADMS.API.Services.ScannerInfo.SupportedFormats">
            <summary>
            Gets or sets the supported file formats and MIME types.
            </summary>
        </member>
        <member name="P:ADMS.API.Services.ScannerInfo.DetectionCapabilities">
            <summary>
            Gets or sets the detection capabilities of the scanner.
            </summary>
        </member>
        <member name="P:ADMS.API.Services.ScannerInfo.MaxFileSizeMB">
            <summary>
            Gets or sets the maximum file size in MB that can be scanned.
            </summary>
            <remarks>
            Indicates the upper limit for file sizes that the scanner can process.
            Important for validation and user guidance.
            </remarks>
        </member>
        <member name="P:ADMS.API.Services.ScannerInfo.SupportsConcurrentScanning">
            <summary>
            Gets or sets a value indicating whether the scanner supports concurrent scanning.
            </summary>
            <remarks>
            Indicates whether multiple files can be scanned simultaneously.
            Important for performance planning and resource allocation.
            </remarks>
        </member>
        <member name="P:ADMS.API.Services.ScannerInfo.SupportsStreamScanning">
            <summary>
            Gets or sets a value indicating whether the scanner supports stream-based scanning.
            </summary>
            <remarks>
            Indicates whether the scanner can process file streams directly
            without requiring file system storage.
            </remarks>
        </member>
        <member name="P:ADMS.API.Services.ScannerInfo.ConfigurationDetails">
            <summary>
            Gets or sets detailed configuration information about the scanner.
            </summary>
            <remarks>
            Contains implementation-specific configuration details that may be
            useful for monitoring, troubleshooting, and integration planning.
            </remarks>
        </member>
        <member name="T:ADMS.API.Services.PaginationMetadata">
            <summary>
                Pagination Metadata class
            </summary>
        </member>
        <member name="M:ADMS.API.Services.PaginationMetadata.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>
                Pagination Metadata class
            </summary>
        </member>
        <member name="P:ADMS.API.Services.PaginationMetadata.TotalItemCount">
            <summary>
                Total Item Count
            </summary>
        </member>
        <member name="P:ADMS.API.Services.PaginationMetadata.TotalPageCount">
            <summary>
                Total Page Count
            </summary>
        </member>
        <member name="P:ADMS.API.Services.PaginationMetadata.PageSize">
            <summary>
                Page Size
            </summary>
        </member>
        <member name="P:ADMS.API.Services.PaginationMetadata.CurrentPage">
            <summary>
                Current Page Number
            </summary>
        </member>
        <member name="T:ADMS.API.Services.PropertyCheckerService">
            <summary>
            Advanced property validation service providing comprehensive type and property existence verification.
            </summary>
            <remarks>
            This service provides enterprise-grade property validation functionality including:
            
            Core Functionality:
            - Type-safe property existence validation using reflection
            - High-performance property checking with intelligent caching
            - Case-insensitive property name matching for flexible API usage
            - Comprehensive error handling and detailed logging capabilities
            - Thread-safe operations optimized for concurrent access scenarios
            
            Property Validation Features:
            - Support for simple property names (e.g., "Name", "Email", "CreatedDate")
            - Complex nested property validation with dot notation (e.g., "Address.Street", "User.Profile.DisplayName")
            - Comma-separated field list validation for batch property checking
            - Whitespace-tolerant input parsing for robust API parameter handling
            - Generic type parameter support for compile-time type safety
            
            Performance Optimizations:
            - Intelligent caching of reflection-based property information
            - Concurrent dictionary implementation for thread-safe caching
            - Optimized property lookup operations with O(1) average complexity
            - Lazy evaluation of complex property paths for improved performance
            - Memory-efficient storage of property metadata using immutable collections
            
            Integration Features:
            - Seamless integration with API parameter validation pipelines
            - Support for data shaping operations with property existence verification
            - Compatibility with Entity Framework Core entity validation
            - Integration with model binding validation for comprehensive input checking
            - Support for custom validation scenarios with extensible architecture
            
            Thread Safety and Concurrency:
            - All property validation operations are thread-safe for concurrent access
            - Concurrent caching implementation prevents race conditions
            - No shared mutable state that could cause threading issues
            - Optimized for high-concurrency web application scenarios
            - Lock-free operations for maximum performance under load
            
            Error Handling and Logging:
            - Comprehensive logging of property validation operations
            - Detailed error reporting for troubleshooting validation failures
            - Integration with structured logging frameworks for monitoring
            - Performance metrics collection for optimization insights
            - Graceful handling of reflection errors and edge cases
            
            The service is designed to be:
            - High-performance: Optimized for frequent property validation operations
            - Reliable: Comprehensive error handling and validation throughout
            - Thread-safe: Safe for use in multi-threaded web application environments
            - Extensible: Easy to extend with additional validation capabilities
            - Maintainable: Clear separation of concerns with comprehensive documentation
            
            Common Use Cases:
            - API parameter validation for data shaping operations
            - Dynamic property existence checking for flexible query building
            - Model binding validation for complex object structures
            - Entity Framework projection validation for database queries
            - Generic property validation in data transformation pipelines
            
            Example scenarios include:
            - Validating API "fields" parameters for selective data retrieval
            - Checking property existence before building LINQ expressions
            - Validating data shaping requests in RESTful APIs
            - Supporting dynamic object serialization with property filtering
            - Ensuring type safety in generic property manipulation scenarios
            </remarks>
        </member>
        <member name="P:ADMS.API.Services.PropertyCheckerService.CachedTypeInformation">
            <summary>
            Gets the collection of cached type information for performance monitoring and diagnostics.
            </summary>
            <remarks>
            This property provides:
            - Read-only access to cached type information for diagnostic purposes
            - Performance monitoring capabilities for cache effectiveness analysis
            - Memory usage insights for optimization and capacity planning
            - Debugging support for property validation troubleshooting
            
            The cached information includes:
            - Type names and their associated property collections
            - Property metadata for fast lookup operations
            - Reflection information cached for performance optimization
            - Validation results for frequently accessed property combinations
            
            Use cases:
            - Performance monitoring and optimization analysis
            - Memory usage tracking for long-running applications
            - Debugging property validation issues and cache effectiveness
            - Service health monitoring and diagnostic reporting
            </remarks>
            <value>
            An immutable collection of cached type information entries.
            The collection is thread-safe and represents the current cache state.
            </value>
        </member>
        <member name="P:ADMS.API.Services.PropertyCheckerService.CachedValidationCount">
            <summary>
            Gets the count of cached validation results for performance monitoring.
            </summary>
            <remarks>
            This property provides:
            - Quick access to cache utilization metrics
            - Performance monitoring for cache effectiveness
            - Memory usage insights for optimization purposes
            - Service health indicators for diagnostic scenarios
            
            The cache count reflects:
            - Number of unique type-field combinations validated
            - Cache effectiveness and hit rates over time
            - Memory utilization patterns for capacity planning
            - Service usage patterns for optimization insights
            </remarks>
            <value>
            The total number of cached validation results.
            Always non-negative and reflects current cache utilization.
            </value>
        </member>
        <member name="M:ADMS.API.Services.PropertyCheckerService.#ctor(Microsoft.Extensions.Logging.ILogger{ADMS.API.Services.PropertyCheckerService})">
            <summary>
            Initializes a new instance of the PropertyCheckerService with comprehensive caching and logging support.
            </summary>
            <param name="logger">
            The logger instance for recording property validation operations, performance metrics, and diagnostic information.
            Used for debugging validation issues, monitoring service performance, and tracking cache effectiveness.
            </param>
            <remarks>
            The initialization process includes:
            
            1. Service Infrastructure Setup:
               - Initializes thread-safe concurrent dictionaries for property and validation caching
               - Configures logging infrastructure for comprehensive operation tracking
               - Sets up performance monitoring and diagnostic capabilities
               - Establishes error handling and recovery mechanisms
            
            2. Cache Initialization:
               - Creates high-performance concurrent cache for property information
               - Initializes validation result cache for frequently accessed combinations
               - Configures cache eviction policies for memory management
               - Sets up cache warming for commonly used types (optional)
            
            3. Performance Optimization:
               - Optimizes reflection operations for repeated property lookups
               - Configures concurrent access patterns for high-throughput scenarios
               - Implements lazy loading for complex property resolution
               - Sets up performance metrics collection for monitoring
            
            4. Error Handling Configuration:
               - Establishes comprehensive error handling for reflection operations
               - Configures graceful degradation for edge cases and failures
               - Sets up detailed error reporting and diagnostic logging
               - Implements recovery mechanisms for transient failures
            
            The service is designed to be:
            - Fail-safe: Graceful handling of reflection errors and edge cases
            - High-performance: Optimized for frequent property validation operations
            - Thread-safe: Safe for concurrent use in multi-threaded applications
            - Observable: Comprehensive logging and monitoring capabilities
            
            Performance characteristics:
            - O(1) average case property lookup after initial caching
            - Minimal memory overhead with efficient caching strategies
            - Thread-safe operations without lock contention
            - Optimized reflection operations with cached metadata
            </remarks>
            <exception cref="T:System.ArgumentNullException">
            Thrown when the logger parameter is null.
            </exception>
            <example>
            <code>
            // Service registration in dependency injection container
            services.AddScoped&lt;IPropertyCheckerService, PropertyCheckerService&gt;();
            
            // Direct instantiation for testing scenarios
            var logger = serviceProvider.GetRequiredService&lt;ILogger&lt;PropertyCheckerService&gt;&gt;();
            var propertyChecker = new PropertyCheckerService(logger);
            
            // Example usage
            bool hasValidProperties = propertyChecker.TypeHasProperties&lt;DocumentDto&gt;("FileName,FileSize,CreatedDate");
            </code>
            </example>
        </member>
        <member name="M:ADMS.API.Services.PropertyCheckerService.TypeHasProperties``1(System.String)">
            <summary>
            Validates that all specified properties exist on the given type with comprehensive error handling and caching.
            </summary>
            <typeparam name="T">
            The type to validate properties against. Must be a reference type or value type with public properties.
            Common examples include DTO classes, entity classes, or any .NET type with public properties.
            </typeparam>
            <param name="fields">
            A comma-separated string of property names to validate against the specified type.
            Supports simple property names (e.g., "Name,Email") and nested property paths (e.g., "Address.Street,User.Profile.Name").
            Null, empty, or whitespace-only values are considered valid (returns true) as no validation is required.
            Property names are matched case-insensitively for flexible API usage.
            </param>
            <returns>
            true if all specified properties exist on the type T and are accessible;
            false if any property does not exist, is not accessible, or if validation fails due to reflection errors.
            Returns true for null, empty, or whitespace-only field parameters as no validation is required.
            </returns>
            <remarks>
            This method provides comprehensive property validation including:
            
            Input Processing:
            - Handles null, empty, and whitespace-only field parameters gracefully
            - Parses comma-separated field lists with robust whitespace handling
            - Trims individual field names to handle formatting variations
            - Supports flexible input formats common in API parameter usage
            
            Property Resolution:
            - Uses reflection to discover public instance properties on the target type
            - Supports case-insensitive property name matching for API flexibility
            - Handles nested property paths with dot notation (e.g., "Address.Street")
            - Validates property accessibility and visibility requirements
            
            Caching and Performance:
            - Implements intelligent caching of reflection-based property information
            - Uses concurrent dictionaries for thread-safe cache operations
            - Provides O(1) average case lookup time for cached property information
            - Optimizes memory usage with efficient caching strategies
            
            Error Handling:
            - Gracefully handles reflection errors and type resolution failures
            - Provides detailed logging for debugging and troubleshooting
            - Returns false for validation failures rather than throwing exceptions
            - Maintains service stability even with invalid or problematic input
            
            Thread Safety:
            - All operations are thread-safe for concurrent access scenarios
            - Uses concurrent collections to prevent race conditions
            - No shared mutable state that could cause threading issues
            - Optimized for high-concurrency web application usage
            
            Logging and Monitoring:
            - Comprehensive logging of validation operations and results
            - Performance metrics for cache effectiveness and optimization
            - Detailed error reporting for troubleshooting validation issues
            - Integration with structured logging frameworks for monitoring
            
            The method supports various field specification formats:
            - Simple property names: "Name,Email,CreatedDate"
            - Nested property paths: "Address.Street,User.Profile.DisplayName"
            - Mixed formats: "Name,Address.Street,Email"
            - Whitespace variations: " Name , Email , CreatedDate "
            
            Common use cases include:
            - API parameter validation for data shaping operations
            - Dynamic property existence checking before LINQ expression building
            - Model binding validation for complex object structures
            - Entity Framework projection validation for database queries
            - Generic property validation in data transformation pipelines
            </remarks>
            <exception cref="T:System.ArgumentException">
            This method does not throw exceptions for validation failures. Instead, it returns false
            and logs appropriate error information. This design ensures service stability and
            provides predictable behavior for API validation scenarios.
            </exception>
            <example>
            <code>
            var propertyChecker = serviceProvider.GetRequiredService&lt;IPropertyCheckerService&gt;();
            
            // Validate simple property names
            bool hasBasicProperties = propertyChecker.TypeHasProperties&lt;DocumentDto&gt;("FileName,FileSize");
            
            // Validate nested property paths
            bool hasNestedProperties = propertyChecker.TypeHasProperties&lt;UserDto&gt;("Profile.DisplayName,Address.Street");
            
            // Handle null/empty fields (returns true)
            bool emptyIsValid = propertyChecker.TypeHasProperties&lt;DocumentDto&gt;(null);        // Returns true
            bool whitespaceIsValid = propertyChecker.TypeHasProperties&lt;DocumentDto&gt;("  ");  // Returns true
            
            // Use in API parameter validation
            [HttpGet]
            public IActionResult GetDocuments([FromQuery] string? fields)
            {
                if (!_propertyChecker.TypeHasProperties&lt;DocumentDto&gt;(fields))
                {
                    return BadRequest("One or more specified fields do not exist on the Document type");
                }
                
                // Continue with data shaping using validated fields
                var documents = _repository.GetDocuments();
                return Ok(documents.ShapeData(fields));
            }
            
            // Use for dynamic query building
            public IQueryable&lt;T&gt; BuildDynamicQuery&lt;T&gt;(IQueryable&lt;T&gt; query, string? selectFields)
            {
                if (string.IsNullOrWhiteSpace(selectFields)) return query;
                
                if (!_propertyChecker.TypeHasProperties&lt;T&gt;(selectFields))
                {
                    throw new ArgumentException("Invalid fields specified for selection");
                }
                
                // Safe to build LINQ expression with validated fields
                return query.Select(BuildSelectExpression&lt;T&gt;(selectFields));
            }
            </code>
            </example>
        </member>
        <member name="M:ADMS.API.Services.PropertyCheckerService.HasProperty``1(System.String)">
            <summary>
            Validates that a specific property exists on the given type with detailed validation.
            </summary>
            <typeparam name="T">The type to validate the property against.</typeparam>
            <param name="propertyName">The name of the property to validate (case-insensitive).</param>
            <returns>true if the property exists and is accessible; otherwise, false.</returns>
            <remarks>
            This method provides:
            - Single property validation for specific use cases
            - Case-insensitive property name matching for flexibility
            - Support for nested property paths with dot notation
            - Caching for improved performance on repeated calls
            
            The method is optimized for scenarios where:
            - Only a single property needs validation
            - Performance is critical and batch validation is not needed
            - Integration with existing validation pipelines is required
            - Detailed per-property validation results are needed
            </remarks>
            <example>
            <code>
            // Validate single property
            bool hasFileName = propertyChecker.HasProperty&lt;DocumentDto&gt;("FileName");
            
            // Validate nested property
            bool hasStreet = propertyChecker.HasProperty&lt;UserDto&gt;("Address.Street");
            
            // Use in conditional logic
            if (propertyChecker.HasProperty&lt;DocumentDto&gt;("LastModifiedDate"))
            {
                // Safe to use LastModifiedDate property
                query = query.OrderBy(d => d.LastModifiedDate);
            }
            </code>
            </example>
        </member>
        <member name="M:ADMS.API.Services.PropertyCheckerService.GetAvailableProperties``1">
            <summary>
            Gets all public properties available on the specified type for validation and enumeration purposes.
            </summary>
            <typeparam name="T">The type to retrieve properties for.</typeparam>
            <returns>
            An enumerable collection of property names available on the specified type.
            The collection includes all public instance properties that can be accessed.
            </returns>
            <remarks>
            This method provides:
            - Complete enumeration of available properties for validation
            - Cached property information for optimal performance
            - Integration support for dynamic property discovery
            - Debugging and diagnostic capabilities for type inspection
            
            The returned properties include:
            - All public instance properties with get accessors
            - Properties inherited from base classes
            - Properties defined by implemented interfaces
            - Auto-implemented properties and traditional properties
            
            Use cases include:
            - Generating documentation for available data shaping fields
            - Creating dynamic user interfaces for property selection
            - Validating comprehensive property coverage in tests
            - Debugging type structure and property availability
            </remarks>
            <example>
            <code>
            // Get all available properties
            var availableProperties = propertyChecker.GetAvailableProperties&lt;DocumentDto&gt;().ToList();
            
            // Use for documentation
            var helpText = $"Available fields: {string.Join(", ", availableProperties)}";
            
            // Use for validation
            var invalidFields = requestedFields.Except(availableProperties).ToList();
            if (invalidFields.Any())
            {
                return BadRequest($"Invalid fields: {string.Join(", ", invalidFields)}");
            }
            </code>
            </example>
        </member>
        <member name="M:ADMS.API.Services.PropertyCheckerService.GetDiagnosticInfo">
            <summary>
            Gets diagnostic information about the property checker service for monitoring and debugging.
            </summary>
            <returns>
            A dictionary containing diagnostic information about service performance and cache utilization.
            </returns>
            <remarks>
            This method provides comprehensive diagnostic information including:
            - Cache utilization statistics for performance monitoring
            - Memory usage information for optimization purposes
            - Service health indicators for operational monitoring
            - Performance metrics for cache effectiveness analysis
            
            The diagnostic information is useful for:
            - Performance optimization and capacity planning
            - Memory usage monitoring in long-running applications
            - Service health checking and alerting systems
            - Debugging cache effectiveness and hit rates
            </remarks>
            <example>
            <code>
            var diagnostics = propertyChecker.GetDiagnosticInfo();
            
            Console.WriteLine($"Property Cache Entries: {diagnostics["PropertyCacheCount"]}");
            Console.WriteLine($"Validation Cache Entries: {diagnostics["ValidationCacheCount"]}");
            Console.WriteLine($"Service Status: {diagnostics["ServiceStatus"]}");
            
            // Use for monitoring
            var logger = serviceProvider.GetRequiredService&lt;ILogger&gt;();
            logger.LogInformation("PropertyChecker diagnostics: {@Diagnostics}", diagnostics);
            </code>
            </example>
        </member>
        <member name="M:ADMS.API.Services.PropertyCheckerService.ClearCache">
            <summary>
            Clears all cached property information and validation results to free memory.
            </summary>
            <remarks>
            This method is useful for:
            - Memory optimization in long-running applications
            - Testing scenarios where fresh property resolution is required
            - Dynamic type scenarios where cached information may become stale
            - Performance testing and benchmarking scenarios
            
            Note: Clearing the cache will cause temporary performance impact as
            property information is re-resolved on subsequent validation requests.
            </remarks>
            <example>
            <code>
            // Clear cache for memory optimization
            propertyChecker.ClearCache();
            
            // Use in testing for fresh state
            [Test]
            public void TestPropertyValidation()
            {
                propertyChecker.ClearCache(); // Ensure fresh state
                var result = propertyChecker.TypeHasProperties&lt;TestDto&gt;("TestProperty");
                Assert.IsTrue(result);
            }
            </code>
            </example>
        </member>
        <member name="M:ADMS.API.Services.PropertyCheckerService.GetCachedProperties``1">
            <summary>
            Gets cached property information for the specified type with thread-safe caching.
            </summary>
            <typeparam name="T">The type to get property information for.</typeparam>
            <returns>An array of PropertyInfo objects for the specified type.</returns>
        </member>
        <member name="M:ADMS.API.Services.PropertyCheckerService.ValidatePropertyExists(System.Reflection.PropertyInfo[],System.String)">
            <summary>
            Validates that a specific property exists within the provided property collection.
            </summary>
            <param name="properties">The array of PropertyInfo objects to search within.</param>
            <param name="propertyName">The name of the property to validate (supports dot notation for nested properties).</param>
            <returns>true if the property exists; otherwise, false.</returns>
        </member>
        <member name="T:ADMS.API.Services.PropertyMapping`2">
            <summary>
            Represents a strongly-typed property mapping configuration for transforming between source and destination types.
            </summary>
            <typeparam name="TSource">The source type (typically a DTO) containing the properties to be mapped from.</typeparam>
            <typeparam name="TDestination">The destination type (typically an entity) containing the properties to be mapped to.</typeparam>
            <remarks>
            This class provides enterprise-grade property mapping functionality including:
            
            Core Functionality:
            - Type-safe property mapping between source DTOs and destination entities
            - Immutable mapping configurations for thread safety and consistency
            - Comprehensive validation and error handling for mapping operations
            - High-performance property transformation with optimized lookup operations
            
            Property Mapping Features:
            - Support for simple one-to-one property mappings (DTO.Name -> Entity.Name)
            - Complex one-to-many property mappings (DTO.FullName -> Entity.FirstName, Entity.LastName)
            - Bidirectional property mappings with revert support for inverse operations
            - Case-insensitive property name matching for flexible mapping scenarios
            - Comprehensive property validation against target type schemas
            
            Performance Characteristics:
            - Immutable dictionary storage for thread-safe concurrent access
            - Optimized property lookup operations with O(1) average complexity
            - Memory-efficient storage using optimized collection types
            - Lazy evaluation of complex mapping operations where appropriate
            - Cached property information for improved repeated access patterns
            
            Integration Features:
            - Seamless integration with Entity Framework Core for database operations
            - Support for LINQ expression building for dynamic sorting and filtering
            - Compatibility with mapping frameworks like AutoMapper for complex scenarios
            - Integration with dependency injection containers for service lifetime management
            - Support for API versioning with evolving mapping requirements
            
            Thread Safety and Concurrency:
            - All mapping operations are thread-safe for concurrent access scenarios
            - Immutable mapping configurations prevent accidental modification
            - No shared mutable state that could cause race conditions
            - Safe for use in multi-threaded web application environments
            - Concurrent dictionary implementation for high-performance scenarios
            
            Validation and Error Handling:
            - Comprehensive validation of mapping configurations during initialization
            - Type-safe property mapping validation at compile time where possible
            - Runtime validation of property mappings against target schemas
            - Detailed error messages for troubleshooting mapping configuration issues
            - Integration with logging infrastructure for debugging and monitoring
            
            The mapping configuration is designed to be:
            - Immutable: Cannot be modified after construction to ensure consistency
            - Type-safe: Compile-time type checking for source and destination types
            - High-performance: Optimized for frequent property mapping operations
            - Thread-safe: Safe for use in concurrent scenarios without synchronization
            - Extensible: Easy to extend with additional mapping capabilities as needed
            
            Common Use Cases:
            - API request/response transformation between DTOs and domain entities
            - Database query result mapping from entities to presentation models
            - Dynamic sorting and filtering operations with property name translation
            - Data validation and transformation pipelines with type safety
            - Cross-layer data transformation in layered architecture patterns
            
            Example scenarios include:
            - Mapping DocumentDto to Document entity for database persistence
            - Transforming RevisionDto to Revision entity for version control operations
            - Converting MatterDto to Matter entity for legal document management
            - Supporting API evolution with backward-compatible property mappings
            </remarks>
            <example>
            <code>
            // Create a property mapping for DocumentDto to Document entity
            var mappingDictionary = new Dictionary&lt;string, PropertyMappingValue&gt;
            {
                ["FileName"] = new PropertyMappingValue(new[] { "FileName" }),
                ["FileSize"] = new PropertyMappingValue(new[] { "FileSize" }),
                ["CreatedDate"] = new PropertyMappingValue(new[] { "CreationDate" }),
                ["FullName"] = new PropertyMappingValue(new[] { "FirstName", "LastName" })
            };
            
            var propertyMapping = new PropertyMapping&lt;DocumentDto, Document&gt;(mappingDictionary);
            
            // Use the mapping for property lookups and validations
            bool canMapFileName = propertyMapping.HasMapping("FileName");
            var fileNameMapping = propertyMapping.GetMapping("FileName");
            string destinationProperty = fileNameMapping.GetPrimaryProperty();
            </code>
            </example>
        </member>
        <member name="P:ADMS.API.Services.PropertyMapping`2.MappingDictionary">
            <summary>
            Gets the immutable dictionary containing the property mapping configuration.
            </summary>
            <remarks>
            This property provides:
            - Read-only access to the complete property mapping configuration
            - Thread-safe enumeration and lookup of property mappings
            - Integration support for external mapping frameworks and tools
            - Debugging capabilities for troubleshooting mapping issues
            
            Dictionary Characteristics:
            - Case-insensitive string keys for flexible property name matching
            - Immutable after construction to prevent accidental modification
            - Optimized for frequent lookup operations with O(1) average complexity
            - Memory-efficient storage using dictionary optimization techniques
            
            Key-Value Structure:
            - Keys: Source property names from the TSource type (case-insensitive)
            - Values: PropertyMappingValue instances containing destination property information
            - Supports one-to-one and one-to-many property mapping scenarios
            - Enables complex property transformations and bidirectional mappings
            
            Usage Patterns:
            - Direct property lookup: mappingDictionary["PropertyName"]
            - Enumeration of all mappings: foreach(var kvp in mappingDictionary)
            - Existence checking: mappingDictionary.ContainsKey("PropertyName")
            - Integration with LINQ: mappingDictionary.Where(kvp => condition)
            
            The dictionary is used extensively by:
            - Property mapping services for dynamic property transformation
            - LINQ expression builders for database query generation
            - Validation services for mapping configuration verification
            - Sorting and filtering operations for property name translation
            </remarks>
            <value>
            An immutable dictionary mapping source property names to PropertyMappingValue instances.
            The dictionary uses case-insensitive string comparison for robust property matching.
            </value>
        </member>
        <member name="P:ADMS.API.Services.PropertyMapping`2.SourceType">
            <summary>
            Gets the source type information for this property mapping configuration.
            </summary>
            <remarks>
            This property provides:
            - Runtime type information for the source type (typically a DTO)
            - Reflection capabilities for dynamic property discovery and validation
            - Type safety validation for mapping operations
            - Integration support for generic mapping frameworks
            
            The source type information is used for:
            - Validation of mapping configurations against source type schema
            - Dynamic property discovery during mapping generation
            - Type compatibility checking for mapping operations
            - Error reporting with specific type context information
            </remarks>
            <value>The Type information for the source type TSource.</value>
        </member>
        <member name="P:ADMS.API.Services.PropertyMapping`2.DestinationType">
            <summary>
            Gets the destination type information for this property mapping configuration.
            </summary>
            <remarks>
            This property provides:
            - Runtime type information for the destination type (typically an entity)
            - Reflection capabilities for property existence validation
            - Type safety enforcement for mapping operations
            - Support for complex type transformation scenarios
            
            The destination type information is used for:
            - Validation of destination property names in mapping configurations
            - Type compatibility verification during mapping operations
            - Dynamic property discovery for automatic mapping generation
            - Error reporting with destination type context information
            </remarks>
            <value>The Type information for the destination type TDestination.</value>
        </member>
        <member name="P:ADMS.API.Services.PropertyMapping`2.PropertyMappingCount">
            <summary>
            Gets the count of property mappings defined in this configuration.
            </summary>
            <remarks>
            This convenience property provides:
            - Quick access to the number of mapped properties
            - Performance metrics for mapping complexity analysis
            - Validation support for mapping completeness checking
            - Debugging information for mapping configuration inspection
            
            The property count is useful for:
            - Performance optimization based on mapping complexity
            - Validation that required properties are mapped
            - Logging and monitoring of mapping configuration size
            - Unit testing verification of mapping completeness
            </remarks>
            <value>
            The total number of property mappings in the mapping dictionary.
            Always non-negative and reflects the current mapping configuration size.
            </value>
        </member>
        <member name="P:ADMS.API.Services.PropertyMapping`2.IsEmpty">
            <summary>
            Gets a value indicating whether this mapping configuration is empty.
            </summary>
            <remarks>
            This convenience property identifies:
            - Mapping configurations that contain no property mappings
            - Potential configuration errors or incomplete setup
            - Edge cases that require special handling in mapping operations
            - Validation scenarios for mapping completeness checking
            
            Empty mappings might indicate:
            - Incomplete mapping configuration during development
            - Types with no compatible properties for automatic mapping
            - Configuration errors that need to be addressed
            - Special cases where no property transformation is needed
            </remarks>
            <value>
            true if the mapping configuration contains no property mappings;
            false if one or more property mappings are defined.
            </value>
        </member>
        <member name="M:ADMS.API.Services.PropertyMapping`2.#ctor(System.Collections.Generic.Dictionary{System.String,ADMS.API.Services.PropertyMappingValue})">
            <summary>
            Initializes a new instance of the PropertyMapping class with comprehensive validation.
            </summary>
            <param name="mappingDictionary">
            The dictionary containing property mapping configurations from source property names to PropertyMappingValue instances.
            Must not be null and should contain valid property mappings for the source and destination types.
            Dictionary keys should correspond to valid properties on the source type (TSource).
            Dictionary values should contain valid destination property names from the destination type (TDestination).
            </param>
            <remarks>
            The initialization process includes:
            
            1. Parameter Validation:
               - Validates that mappingDictionary parameter is not null
               - Ensures all dictionary keys are valid non-empty strings
               - Verifies all dictionary values are valid PropertyMappingValue instances
               - Checks for duplicate property mappings and conflicting configurations
            
            2. Type Safety Validation:
               - Validates source property names against the TSource type schema
               - Verifies destination property names against the TDestination type schema
               - Ensures type compatibility between mapped properties where applicable
               - Logs validation warnings for potential mapping issues
            
            3. Immutable Configuration Creation:
               - Creates an immutable dictionary from the provided mapping configuration
               - Uses case-insensitive string comparison for robust property name matching
               - Optimizes the dictionary structure for frequent lookup operations
               - Ensures thread safety for concurrent access scenarios
            
            4. Performance Optimization:
               - Pre-validates all property mappings to avoid runtime validation overhead
               - Optimizes dictionary structure for O(1) lookup performance
               - Caches frequently accessed mapping information where appropriate
               - Minimizes memory overhead while maintaining mapping functionality
            
            The constructor is designed to be fail-fast, catching configuration errors
            early in the application lifecycle rather than during runtime operations.
            This ensures that mapping issues are discovered during development and
            testing phases rather than in production environments.
            
            Performance characteristics:
            - O(n) initialization time where n is the number of property mappings
            - O(1) average lookup time for property mappings after initialization
            - Minimal memory overhead with efficient immutable storage
            - Thread-safe operations without synchronization overhead
            </remarks>
            <exception cref="T:System.ArgumentNullException">
            Thrown when the mappingDictionary parameter is null.
            </exception>
            <exception cref="T:System.ArgumentException">
            Thrown when the mappingDictionary contains invalid keys, null values, or configuration errors.
            </exception>
            <exception cref="T:System.InvalidOperationException">
            Thrown when property validation fails due to type compatibility issues or missing properties.
            </exception>
            <example>
            <code>
            // Create a comprehensive property mapping configuration
            var mappingDictionary = new Dictionary&lt;string, PropertyMappingValue&gt;(StringComparer.OrdinalIgnoreCase)
            {
                // Simple one-to-one property mapping
                ["FileName"] = new PropertyMappingValue(new[] { "FileName" }),
                
                // Property mapping with different destination name
                ["CreatedDate"] = new PropertyMappingValue(new[] { "CreationTimestamp" }),
                
                // One-to-many property mapping for complex transformations
                ["FullName"] = new PropertyMappingValue(new[] { "FirstName", "LastName" }),
                
                // Bidirectional property mapping with revert support
                ["SortOrder"] = new PropertyMappingValue(new[] { "DisplayOrder" }, revert: true)
            };
            
            // Initialize the property mapping with validation
            var propertyMapping = new PropertyMapping&lt;DocumentDto, Document&gt;(mappingDictionary);
            
            // The mapping is now ready for use in property transformation operations
            bool hasFileNameMapping = propertyMapping.HasMapping("FileName");
            var mapping = propertyMapping.GetMapping("CreatedDate");
            </code>
            </example>
        </member>
        <member name="M:ADMS.API.Services.PropertyMapping`2.HasMapping(System.String)">
            <summary>
            Determines whether a property mapping exists for the specified source property name.
            </summary>
            <param name="sourcePropertyName">The name of the source property to check for mapping existence.</param>
            <returns>
            true if a property mapping exists for the specified source property name;
            false if no mapping is found or if the property name is invalid.
            </returns>
            <remarks>
            This method provides:
            - Case-insensitive property name matching for robust lookup operations
            - Fast O(1) lookup performance using optimized dictionary operations
            - Null-safe parameter handling with graceful error responses
            - Integration support for dynamic property mapping validation
            
            The method is commonly used for:
            - Validating that requested sort/filter properties have valid mappings
            - Pre-flight checks before performing property transformation operations
            - Dynamic API parameter validation in controller methods
            - Conditional logic based on property mapping availability
            
            Performance characteristics:
            - O(1) average case lookup time using hash-based dictionary operations
            - Minimal memory allocation for lookup operations
            - Thread-safe operation suitable for concurrent access scenarios
            - Consistent performance regardless of mapping dictionary size
            </remarks>
            <exception cref="T:System.ArgumentException">
            Thrown when sourcePropertyName is null, empty, or contains only whitespace.
            </exception>
            <example>
            <code>
            var propertyMapping = new PropertyMapping&lt;DocumentDto, Document&gt;(mappingDictionary);
            
            // Check if specific properties can be mapped
            bool canMapFileName = propertyMapping.HasMapping("FileName");        // Returns true if mapping exists
            bool canMapFileSize = propertyMapping.HasMapping("FileSize");        // Returns true if mapping exists
            bool canMapInvalid = propertyMapping.HasMapping("NonExistent");      // Returns false
            
            // Use in conditional logic
            if (propertyMapping.HasMapping("CreatedDate"))
            {
                // Safe to use CreatedDate in sorting/filtering operations
                var mapping = propertyMapping.GetMapping("CreatedDate");
                // Process the mapping...
            }
            </code>
            </example>
        </member>
        <member name="M:ADMS.API.Services.PropertyMapping`2.GetMapping(System.String)">
            <summary>
            Retrieves the property mapping configuration for the specified source property name.
            </summary>
            <param name="sourcePropertyName">The name of the source property to retrieve mapping information for.</param>
            <returns>
            The PropertyMappingValue instance containing the mapping configuration for the specified property.
            </returns>
            <remarks>
            This method provides:
            - Fast O(1) lookup of property mapping configurations
            - Case-insensitive property name matching for flexible usage
            - Complete mapping information including destination properties and configuration
            - Integration support for LINQ expression building and property transformation
            
            The returned PropertyMappingValue contains:
            - Destination property names for the mapping operation
            - Bidirectional mapping configuration (revert flag)
            - Validation information for mapping verification
            - Additional metadata for complex mapping scenarios
            
            Common usage patterns:
            - Building LINQ expressions for database queries with property translation
            - Validating property mapping configurations during development
            - Constructing sort and filter expressions for paginated operations
            - Dynamic property transformation in data access layers
            
            The method is optimized for frequent access scenarios and provides
            consistent performance regardless of the mapping dictionary size.
            </remarks>
            <exception cref="T:System.ArgumentException">
            Thrown when sourcePropertyName is null, empty, or contains only whitespace.
            </exception>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">
            Thrown when no property mapping exists for the specified source property name.
            Use HasMapping method to check for mapping existence before calling this method.
            </exception>
            <example>
            <code>
            var propertyMapping = new PropertyMapping&lt;DocumentDto, Document&gt;(mappingDictionary);
            
            try
            {
                // Retrieve specific property mapping
                var fileNameMapping = propertyMapping.GetMapping("FileName");
                string destinationProperty = fileNameMapping.GetPrimaryProperty();
                
                // Use mapping for LINQ expression building
                var createdDateMapping = propertyMapping.GetMapping("CreatedDate");
                bool shouldReverse = createdDateMapping.Revert;
                var destinationProperties = createdDateMapping.DestinationProperties;
            }
            catch (KeyNotFoundException)
            {
                // Handle missing mapping gracefully
                // Consider using HasMapping() method for pre-validation
            }
            
            // Safe usage with pre-validation
            if (propertyMapping.HasMapping("FileSize"))
            {
                var fileSizeMapping = propertyMapping.GetMapping("FileSize");
                // Guaranteed to succeed since HasMapping returned true
            }
            </code>
            </example>
        </member>
        <member name="M:ADMS.API.Services.PropertyMapping`2.TryGetMapping(System.String,ADMS.API.Services.PropertyMappingValue@)">
            <summary>
            Attempts to retrieve the property mapping configuration for the specified source property name.
            </summary>
            <param name="sourcePropertyName">The name of the source property to retrieve mapping information for.</param>
            <param name="mappingValue">
            When this method returns, contains the PropertyMappingValue associated with the specified property name,
            if the mapping is found; otherwise, null. This parameter is passed uninitialized.
            </param>
            <returns>
            true if the property mapping configuration contains a mapping for the specified property name;
            otherwise, false.
            </returns>
            <remarks>
            This method provides:
            - Safe property mapping retrieval without exception throwing
            - Case-insensitive property name matching for flexible usage
            - Fast O(1) lookup performance using optimized dictionary operations
            - Null-safe parameter handling with defensive programming practices
            
            This method is preferred over GetMapping when:
            - Property mapping existence is uncertain
            - Exception handling overhead should be avoided
            - Performance-critical code paths require optimal efficiency
            - Graceful handling of missing mappings is required
            
            The method follows the standard .NET TryGet pattern for consistency
            with other framework APIs and provides predictable behavior for
            developers familiar with similar methods in the base class libraries.
            </remarks>
            <exception cref="T:System.ArgumentException">
            Thrown when sourcePropertyName is null, empty, or contains only whitespace.
            </exception>
            <example>
            <code>
            var propertyMapping = new PropertyMapping&lt;DocumentDto, Document&gt;(mappingDictionary);
            
            // Safe retrieval without exception handling
            if (propertyMapping.TryGetMapping("FileName", out var fileNameMapping))
            {
                // Mapping found - safe to use fileNameMapping
                string destinationProperty = fileNameMapping.GetPrimaryProperty();
                bool shouldReverse = fileNameMapping.Revert;
            }
            else
            {
                // Mapping not found - handle gracefully
                // Could log warning, use default behavior, or skip processing
            }
            
            // Performance-optimized usage in loops
            foreach (string propertyName in requestedProperties)
            {
                if (propertyMapping.TryGetMapping(propertyName, out var mapping))
                {
                    // Process the mapping without exception overhead
                    ProcessPropertyMapping(propertyName, mapping);
                }
            }
            </code>
            </example>
        </member>
        <member name="M:ADMS.API.Services.PropertyMapping`2.GetMappableProperties">
            <summary>
            Gets all source property names that have mappings defined in this configuration.
            </summary>
            <returns>
            An enumerable collection of source property names that can be mapped using this configuration.
            The collection is immutable and thread-safe for concurrent enumeration.
            </returns>
            <remarks>
            This method provides:
            - Complete enumeration of all mappable source properties
            - Thread-safe iteration over property names
            - Integration support for dynamic property discovery
            - Debugging capabilities for mapping configuration inspection
            
            The returned collection characteristics:
            - Immutable: Cannot be modified after retrieval
            - Thread-safe: Safe for concurrent enumeration operations
            - Efficient: Minimal memory allocation and optimal performance
            - Consistent: Preserves original property name casing and order
            
            Common usage scenarios:
            - Validating API parameters against available property mappings
            - Generating documentation for supported sort/filter properties
            - Dynamic user interface generation for property selection
            - Testing and debugging mapping configuration completeness
            
            The method is optimized for frequent access and provides consistent
            performance characteristics regardless of mapping dictionary size.
            </remarks>
            <example>
            <code>
            var propertyMapping = new PropertyMapping&lt;DocumentDto, Document&gt;(mappingDictionary);
            
            // Get all mappable property names
            var mappableProperties = propertyMapping.GetMappableProperties().ToList();
            
            // Use for validation
            foreach (string requestedProperty in apiParameters.SortFields)
            {
                if (!mappableProperties.Contains(requestedProperty))
                {
                    throw new ArgumentException($"Property '{requestedProperty}' cannot be used for sorting");
                }
            }
            
            // Use for documentation or UI generation
            var supportedSortFields = string.Join(", ", mappableProperties);
            var helpText = $"Supported sort fields: {supportedSortFields}";
            
            // Use for debugging and logging
            var logger = serviceProvider.GetRequiredService&lt;ILogger&gt;();
            logger.LogDebug("Property mapping supports {Count} properties: {Properties}",
                mappableProperties.Count, string.Join(", ", mappableProperties));
            </code>
            </example>
        </member>
        <member name="M:ADMS.API.Services.PropertyMapping`2.ValidateConfiguration">
            <summary>
            Validates the entire property mapping configuration against the source and destination type schemas.
            </summary>
            <returns>
            An enumerable collection of validation results describing any configuration issues found.
            An empty collection indicates that the mapping configuration is valid.
            </returns>
            <remarks>
            This method provides comprehensive validation including:
            
            Source Type Validation:
            - Verifies that all mapped source properties exist on the TSource type
            - Validates property accessibility and visibility requirements
            - Checks for deprecated or obsolete property usage
            - Ensures property name spelling and casing consistency
            
            Destination Type Validation:
            - Confirms that all destination properties exist on the TDestination type
            - Validates property write accessibility for mapping operations
            - Checks type compatibility between source and destination properties
            - Ensures complex property paths are valid (e.g., "Address.Street")
            
            Mapping Configuration Validation:
            - Identifies duplicate property mappings and conflicting configurations
            - Validates bidirectional mapping configurations for consistency
            - Checks for circular references in complex property mappings
            - Ensures mapping completeness for critical properties
            
            Business Rule Validation:
            - Applies domain-specific validation rules where applicable
            - Validates against known property mapping anti-patterns
            - Checks for performance implications of complex mappings
            - Ensures security considerations are addressed
            
            The validation results include:
            - Detailed error descriptions for each validation failure
            - Property names and context information for troubleshooting
            - Severity levels (errors, warnings, informational messages)
            - Recommended actions for resolving configuration issues
            
            This method is particularly useful for:
            - Unit testing of property mapping configurations
            - Development-time validation of mapping completeness
            - Configuration validation during application startup
            - Debugging complex property mapping scenarios
            </remarks>
            <example>
            <code>
            var propertyMapping = new PropertyMapping&lt;DocumentDto, Document&gt;(mappingDictionary);
            
            // Validate the mapping configuration
            var validationResults = propertyMapping.ValidateConfiguration().ToList();
            
            if (validationResults.Any())
            {
                // Handle validation errors
                foreach (var result in validationResults)
                {
                    logger.LogWarning("Property mapping validation issue: {Message}", result.ErrorMessage);
                    
                    if (result.MemberNames.Any())
                    {
                        logger.LogWarning("Affected properties: {Properties}", 
                            string.Join(", ", result.MemberNames));
                    }
                }
                
                // Consider throwing exception for critical errors
                var criticalErrors = validationResults.Where(r => IsCriticalError(r));
                if (criticalErrors.Any())
                {
                    throw new InvalidOperationException("Critical property mapping configuration errors detected");
                }
            }
            else
            {
                logger.LogInformation("Property mapping configuration validation successful");
            }
            </code>
            </example>
        </member>
        <member name="M:ADMS.API.Services.PropertyMapping`2.ToString">
            <summary>
            Returns a string representation of the property mapping configuration.
            </summary>
            <returns>
            A string containing summary information about the property mapping configuration
            in a human-readable format suitable for debugging and logging.
            </returns>
            <remarks>
            The string representation includes:
            - Source and destination type names for context identification
            - Total count of property mappings for configuration overview
            - Summary of mapping characteristics (simple, complex, bidirectional)
            - Memory and performance characteristics for optimization insights
            
            The formatted output provides:
            - Consistent formatting for logging and monitoring scenarios
            - Sufficient detail for debugging configuration issues
            - Concise summary suitable for diagnostic displays
            - Integration with standard .NET logging frameworks
            
            Example output format:
            "PropertyMapping&lt;DocumentDto, Document&gt;: 8 mappings (6 simple, 2 complex)"
            
            This method is particularly useful for:
            - Debugging property mapping configuration issues
            - Logging mapping information for audit and monitoring
            - Displaying configuration summaries in diagnostic tools
            - Unit testing verification of mapping characteristics
            </remarks>
            <example>
            <code>
            var propertyMapping = new PropertyMapping&lt;DocumentDto, Document&gt;(mappingDictionary);
            
            // Use for logging and debugging
            var logger = serviceProvider.GetRequiredService&lt;ILogger&gt;();
            logger.LogInformation("Initialized property mapping: {PropertyMapping}", propertyMapping);
            
            // Use for diagnostic display
            Console.WriteLine($"Configuration: {propertyMapping}");
            
            // Use in exception messages
            throw new InvalidOperationException($"Mapping error in {propertyMapping}");
            </code>
            </example>
        </member>
        <member name="M:ADMS.API.Services.PropertyMapping`2.ValidateMappingDictionary(System.Collections.Generic.Dictionary{System.String,ADMS.API.Services.PropertyMappingValue})">
            <summary>
            Validates the mapping dictionary parameter for consistency and correctness.
            </summary>
            <param name="mappingDictionary">The mapping dictionary to validate.</param>
            <exception cref="T:System.ArgumentException">Thrown when the dictionary contains invalid entries.</exception>
        </member>
        <member name="M:ADMS.API.Services.PropertyMapping`2.ValidateMappingConfiguration">
            <summary>
            Validates the complete mapping configuration after construction.
            </summary>
            <exception cref="T:System.InvalidOperationException">Thrown when validation fails.</exception>
        </member>
        <member name="M:ADMS.API.Services.PropertyMapping`2.ValidateSourceTypeProperties">
            <summary>
            Validates source type properties against the mapping configuration.
            </summary>
            <returns>A collection of validation results for source type validation.</returns>
        </member>
        <member name="M:ADMS.API.Services.PropertyMapping`2.ValidateDestinationTypeProperties">
            <summary>
            Validates destination type properties against the mapping configuration.
            </summary>
            <returns>A collection of validation results for destination type validation.</returns>
        </member>
        <member name="M:ADMS.API.Services.PropertyMapping`2.ValidateMappingConsistency">
            <summary>
            Validates mapping consistency and configuration integrity.
            </summary>
            <returns>A collection of validation results for mapping consistency validation.</returns>
        </member>
        <member name="T:ADMS.API.Services.PropertyMappingService">
            <summary>
            Advanced property mapping service providing comprehensive mapping between DTO and Entity properties.
            </summary>
            <remarks>
            This service provides enterprise-grade property mapping functionality including:
            - Automated reflection-based property mapping for matching property names
            - Custom property mapping overrides for complex transformation scenarios
            - Thread-safe mapping operations with concurrent access support
            - Performance-optimized mapping with caching and lazy initialization
            - Comprehensive validation and error handling for mapping operations
            - Support for complex property mappings including nested properties and collections
            
            The service implements several advanced features:
            
            Automated Property Mapping:
            - Reflection-based discovery of matching properties between source and destination types
            - Case-insensitive property name matching for flexible mapping scenarios
            - Automatic type compatibility validation during mapping generation
            - Support for ignoring specific properties during automatic mapping generation
            - Intelligent handling of inheritance hierarchies and interface implementations
            
            Performance Optimizations:
            - Concurrent dictionary caching for frequently accessed mappings
            - Lazy initialization of mapping configurations to reduce startup time
            - Optimized reflection operations with cached property information
            - Thread-safe operations supporting high-concurrency scenarios
            - Memory-efficient storage of mapping configurations using immutable collections
            
            Validation and Error Handling:
            - Comprehensive validation of mapping configurations during registration
            - Runtime validation of field mappings for sorting and filtering operations
            - Detailed error messages for troubleshooting mapping issues
            - Graceful handling of missing or invalid property mappings
            - Integration with logging infrastructure for debugging and monitoring
            
            Supported Mapping Scenarios:
            - Simple one-to-one property mappings (DTO.Name -> Entity.Name)
            - Complex one-to-many property mappings (DTO.FullName -> Entity.FirstName, Entity.LastName)
            - Bidirectional property mappings with revert support for inverse operations
            - Nested property mappings with dot notation (DTO.Address -> Entity.Address.Street)
            - Collection property mappings for list and enumerable transformations
            
            Integration Features:
            - Seamless integration with Entity Framework Core for database operations
            - Support for LINQ expression building for dynamic sorting and filtering
            - Compatibility with AutoMapper and other mapping frameworks
            - Integration with API versioning for evolving mapping requirements
            - Support for dependency injection and service lifetime management
            
            Thread Safety and Concurrency:
            - All mapping operations are thread-safe for concurrent access
            - Immutable mapping configurations prevent accidental modification
            - Concurrent dictionary implementation for high-performance caching
            - No shared mutable state that could cause race conditions
            - Safe for use in multi-threaded web application scenarios
            
            The service is designed to be:
            - High-performance: Optimized for frequent mapping operations
            - Maintainable: Clear separation of concerns with comprehensive documentation
            - Extensible: Easy to add new mapping types and custom transformation logic
            - Reliable: Comprehensive error handling and validation throughout
            - Scalable: Efficient memory usage and performance under load
            </remarks>
        </member>
        <member name="P:ADMS.API.Services.PropertyMappingService.RegisteredMappings">
            <summary>
            Gets the collection of registered property mappings in an immutable format.
            </summary>
            <remarks>
            This property provides:
            - Read-only access to all registered property mappings
            - Thread-safe enumeration of mapping configurations
            - Integration support for mapping validation and diagnostics
            - Debugging capabilities for troubleshooting mapping issues
            
            The collection includes:
            - All automatically generated property mappings
            - Custom property mapping overrides and configurations
            - Bidirectional mappings for reverse transformation scenarios
            - Complex mappings with multiple destination properties
            
            Use cases:
            - Configuration validation during application startup
            - Diagnostic and monitoring tools for mapping analysis
            - Unit testing scenarios for mapping configuration verification
            - Runtime introspection of available mapping capabilities
            </remarks>
            <value>
            An immutable collection of property mapping configurations.
            The collection is thread-safe and cannot be modified after service initialization.
            </value>
        </member>
        <member name="M:ADMS.API.Services.PropertyMappingService.#ctor(Microsoft.Extensions.Logging.ILogger{ADMS.API.Services.PropertyMappingService})">
            <summary>
            Initializes a new instance of the PropertyMappingService with comprehensive mapping registration.
            </summary>
            <param name="logger">
            The logger instance for recording mapping operations, errors, and diagnostic information.
            Used for debugging mapping issues and monitoring service performance.
            </param>
            <remarks>
            The initialization process includes:
            
            1. Service Infrastructure Setup:
               - Initializes thread-safe concurrent collections for mappings and caching
               - Configures logging infrastructure for comprehensive operation tracking
               - Sets up performance monitoring and diagnostic capabilities
            
            2. Automatic Property Mapping Registration:
               - Generates mappings for DocumentDto to Document entity transformations
               - Creates mappings for DocumentWithoutRevisionsDto to Document scenarios
               - Establishes RevisionDto to Revision entity mapping configurations
               - Configures MatterDto to Matter entity transformation mappings
               - Processes additional DTO-Entity pairs as discovered through reflection
            
            3. Mapping Validation and Optimization:
               - Validates all generated mappings for consistency and correctness
               - Optimizes mapping configurations for performance and memory efficiency
               - Caches frequently accessed mappings for improved response times
               - Logs mapping registration results for monitoring and debugging
            
            4. Error Handling and Recovery:
               - Implements graceful handling of mapping registration failures
               - Provides detailed error messages for troubleshooting mapping issues
               - Maintains service stability even with partial mapping failures
               - Logs all registration errors for investigation and resolution
            
            The service is designed to be fail-fast during initialization to catch
            mapping configuration issues early in the application lifecycle, while
            maintaining resilience during runtime operations.
            
            Performance characteristics:
            - Lazy initialization of complex mappings to reduce startup time
            - Concurrent mapping registration for improved initialization performance
            - Memory-efficient storage using immutable collections where appropriate
            - Optimized reflection operations with caching for frequently accessed types
            </remarks>
            <exception cref="T:System.ArgumentNullException">
            Thrown when the logger parameter is null.
            </exception>
            <exception cref="T:System.InvalidOperationException">
            Thrown when critical mapping registrations fail during service initialization.
            </exception>
            <example>
            <code>
            // Service registration in dependency injection container
            services.AddScoped&lt;IPropertyMappingService, PropertyMappingService&gt;();
            
            // Direct instantiation for testing scenarios
            var logger = serviceProvider.GetRequiredService&lt;ILogger&lt;PropertyMappingService&gt;&gt;();
            var mappingService = new PropertyMappingService(logger);
            </code>
            </example>
        </member>
        <member name="M:ADMS.API.Services.PropertyMappingService.RegisterStandardMappings">
            <summary>
            Registers all standard property mappings between DTOs and entities used throughout the ADMS system.
            </summary>
            <remarks>
            This method establishes the core property mappings required for:
            - Document management operations with comprehensive DTO-Entity transformations
            - Revision tracking and management with proper property translation
            - Matter management with full property mapping support
            - User and activity tracking with appropriate property mappings
            
            Each mapping registration includes:
            - Automatic property discovery using reflection for matching property names
            - Custom overrides for properties requiring special transformation logic
            - Validation of mapping completeness and correctness
            - Performance optimization for frequently accessed property mappings
            
            The registration process is designed to be:
            - Comprehensive: Covers all major DTO-Entity pairs in the system
            - Extensible: Easy to add new mappings as the system evolves
            - Maintainable: Clear organization and documentation of mapping configurations
            - Performant: Optimized registration process with minimal overhead
            </remarks>
        </member>
        <member name="M:ADMS.API.Services.PropertyMappingService.RegisterMapping``2(System.String,System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.Dictionary{System.String,ADMS.API.Services.PropertyMappingValue})">
            <summary>
            Registers a property mapping for the specified source and destination types with comprehensive validation.
            </summary>
            <typeparam name="TSource">The source DTO type for the mapping.</typeparam>
            <typeparam name="TDestination">The destination entity type for the mapping.</typeparam>
            <param name="mappingKey">A unique identifier for the mapping configuration.</param>
            <param name="ignoreProperties">Optional collection of property names to exclude from automatic mapping.</param>
            <param name="customMappings">Optional custom property mappings that override automatic mappings.</param>
            <remarks>
            This method provides comprehensive mapping registration including:
            
            Automatic Mapping Generation:
            - Reflection-based discovery of matching properties between source and destination
            - Case-insensitive property name matching for flexible configuration
            - Type compatibility validation to ensure safe property transformations
            - Intelligent handling of nullable and non-nullable property mismatches
            
            Custom Mapping Support:
            - Override automatic mappings with custom transformation logic
            - Support for complex property mappings with multiple destination properties
            - Bidirectional mapping support for reverse transformation scenarios
            - Integration with PropertyMappingValue for advanced mapping configurations
            
            Validation and Error Handling:
            - Comprehensive validation of mapping configurations during registration
            - Detailed error messages for troubleshooting mapping issues
            - Graceful handling of registration failures without affecting other mappings
            - Integration with logging for debugging and monitoring mapping registration
            
            Performance Optimizations:
            - Efficient reflection operations with minimal performance impact
            - Caching of generated mappings for improved runtime performance
            - Optimized storage using immutable collections where appropriate
            - Thread-safe registration supporting concurrent initialization scenarios
            </remarks>
            <exception cref="T:System.ArgumentException">
            Thrown when mappingKey is null, empty, or already exists in the mapping collection.
            </exception>
            <exception cref="T:System.InvalidOperationException">
            Thrown when mapping generation fails due to incompatible types or reflection errors.
            </exception>
        </member>
        <member name="M:ADMS.API.Services.PropertyMappingService.GenerateAutoMapping``2(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Generates automatic property mappings between source and destination types using reflection.
            </summary>
            <typeparam name="TSource">The source DTO type for automatic mapping generation.</typeparam>
            <typeparam name="TDestination">The destination entity type for automatic mapping generation.</typeparam>
            <param name="ignoreProperties">Optional collection of property names to exclude from mapping generation.</param>
            <returns>
            A dictionary containing property mappings from source property names to PropertyMappingValue instances.
            The dictionary uses case-insensitive string comparison for robust property name matching.
            </returns>
            <remarks>
            This method implements intelligent automatic mapping generation including:
            
            Property Discovery Process:
            1. Reflection-based enumeration of public properties on both source and destination types
            2. Case-insensitive name matching between source and destination properties
            3. Type compatibility validation for safe property transformations
            4. Automatic exclusion of properties specified in the ignore list
            5. Intelligent handling of inheritance hierarchies and interface implementations
            
            Mapping Generation Features:
            - Supports simple one-to-one property mappings for matching property names
            - Handles nullable and non-nullable property type mismatches appropriately
            - Provides consistent case-insensitive property name matching behavior
            - Generates PropertyMappingValue instances with appropriate configuration
            - Excludes system properties and properties marked for ignoring
            
            Type Compatibility Handling:
            - Validates type compatibility between source and destination properties
            - Handles value types, reference types, and nullable type combinations
            - Provides appropriate mapping configurations for different type scenarios
            - Logs type compatibility issues for debugging and troubleshooting
            
            Performance Considerations:
            - Efficient reflection operations with minimal performance impact
            - Caching of type information for improved performance on repeated calls
            - Optimized collection operations for large property sets
            - Memory-efficient storage of generated mapping configurations
            
            The generated mappings serve as the foundation for:
            - Dynamic sorting operations in paginated queries
            - Property name translation for database operations
            - Filter expression building for search functionality
            - Data transformation between API layers
            </remarks>
            <exception cref="T:System.InvalidOperationException">
            Thrown when reflection operations fail or type compatibility issues are detected.
            </exception>
            <example>
            <code>
            // Generate automatic mapping between DocumentDto and Document
            var mapping = GenerateAutoMapping&lt;DocumentDto, Document&gt;();
            
            // Generate mapping with ignored properties
            var mappingWithIgnores = GenerateAutoMapping&lt;DocumentDto, Document&gt;(
                new[] { "CreatedDate", "ModifiedDate" });
            
            // The resulting dictionary contains mappings like:
            // "FileName" -> PropertyMappingValue(["FileName"])
            // "FileSize" -> PropertyMappingValue(["FileSize"])
            // etc.
            </code>
            </example>
        </member>
        <member name="M:ADMS.API.Services.PropertyMappingService.GetPropertyMapping``2">
            <summary>
            Retrieves the property mapping dictionary for the specified source and destination types.
            </summary>
            <typeparam name="TSource">The source DTO type for the mapping lookup.</typeparam>
            <typeparam name="TDestination">The destination entity type for the mapping lookup.</typeparam>
            <returns>
            A dictionary mapping source property names to PropertyMappingValue instances.
            The dictionary provides the complete mapping configuration for transforming between the specified types.
            </returns>
            <remarks>
            This method provides high-performance property mapping retrieval with:
            
            Caching and Performance:
            - Implements intelligent caching to avoid repeated lookup operations
            - Uses concurrent dictionary for thread-safe caching in multi-threaded scenarios
            - Optimizes frequently accessed mappings for improved response times
            - Provides consistent performance characteristics under varying loads
            
            Mapping Resolution Process:
            1. Generates a unique cache key based on source and destination type information
            2. Checks the mapping cache for previously resolved mapping configurations
            3. If cached mapping exists, returns the cached result for optimal performance
            4. If no cached mapping exists, performs mapping resolution from registered mappings
            5. Caches the resolved mapping for future requests to improve performance
            
            Error Handling and Validation:
            - Validates that exactly one matching mapping exists for the specified types
            - Provides detailed error messages when mappings are missing or ambiguous
            - Handles edge cases where multiple mappings might match the same type pair
            - Logs mapping resolution activities for debugging and monitoring purposes
            
            Thread Safety:
            - All mapping resolution operations are thread-safe for concurrent access
            - Uses concurrent collections to prevent race conditions during caching
            - Supports high-concurrency scenarios without performance degradation
            - No shared mutable state that could cause threading issues
            
            The returned mapping dictionary is used for:
            - Building dynamic LINQ expressions for database queries
            - Translating API parameter names to entity property names
            - Constructing sort and filter expressions for paginated operations
            - Validating that requested sort/filter fields have valid mappings
            </remarks>
            <exception cref="T:System.InvalidOperationException">
            Thrown when no mapping is found, multiple ambiguous mappings exist, 
            or mapping resolution fails due to configuration errors.
            </exception>
            <example>
            <code>
            // Get mapping for DocumentDto to Document entity transformation
            var mapping = mappingService.GetPropertyMapping&lt;DocumentDto, Document&gt;();
            
            // Use mapping for sorting parameter validation
            bool canSortByFileName = mapping.ContainsKey("FileName");
            
            // Get destination property for transformation
            if (mapping.TryGetValue("FileName", out var mappingValue))
            {
                string destinationProperty = mappingValue.GetPrimaryProperty();
                // Use destinationProperty in LINQ expression building
            }
            </code>
            </example>
        </member>
        <!-- Badly formed XML comment ignored for member "M:ADMS.API.Services.PropertyMappingService.ValidMappingExistsFor``2(System.String)" -->
        <member name="M:ADMS.API.Services.PropertyMappingService.ExtractFieldNameFromSortExpression(System.String)">
            <summary>
            Extracts the field name from a sort expression by removing direction indicators.
            </summary>
            <param name="sortExpression">The sort expression that may contain direction indicators (asc, desc).</param>
            <returns>The clean field name without direction indicators.</returns>
            <remarks>
            This method handles various sort expression formats:
            - "fieldName asc" -> "fieldName"
            - "fieldName desc" -> "fieldName" 
            - "fieldName ASC" -> "fieldName" (case-insensitive)
            - "fieldName" -> "fieldName" (no direction)
            - "fieldName ascending" -> "fieldName" (full word)
            - "fieldName descending" -> "fieldName" (full word)
            
            The method is designed to be robust and handle various user input formats
            while extracting the core field name for mapping validation.
            </remarks>
            <example>
            <code>
            string field1 = ExtractFieldNameFromSortExpression("name asc");        // Returns "name"
            string field2 = ExtractFieldNameFromSortExpression("createdDate");     // Returns "createdDate"
            string field3 = ExtractFieldNameFromSortExpression("email DESC");      // Returns "email"
            </code>
            </example>
        </member>
        <member name="M:ADMS.API.Services.PropertyMappingService.GetDiagnosticInfo">
            <summary>
            Gets diagnostic information about the property mapping service configuration.
            </summary>
            <returns>
            A dictionary containing diagnostic information about registered mappings and service status.
            </returns>
            <remarks>
            This method provides comprehensive diagnostic information including:
            - Count of registered property mappings
            - Cache statistics for performance monitoring
            - Memory usage information for optimization
            - Configuration validation results
            
            The diagnostic information is useful for:
            - Service health monitoring and alerting
            - Performance optimization and troubleshooting
            - Configuration validation and verification
            - Development and debugging scenarios
            </remarks>
            <example>
            <code>
            var diagnostics = mappingService.GetDiagnosticInfo();
            
            Console.WriteLine($"Registered Mappings: {diagnostics["RegisteredMappingCount"]}");
            Console.WriteLine($"Cached Mappings: {diagnostics["CachedMappingCount"]}");
            Console.WriteLine($"Service Status: {diagnostics["ServiceStatus"]}");
            </code>
            </example>
        </member>
        <member name="M:ADMS.API.Services.PropertyMappingService.ClearMappingCache">
            <summary>
            Clears all cached property mappings to free memory and force re-resolution.
            </summary>
            <remarks>
            This method is useful for:
            - Memory optimization in long-running applications
            - Testing scenarios where fresh mappings are required
            - Dynamic mapping scenarios where mappings may change
            - Performance testing and benchmarking
            
            Note: This only clears the cache, not the registered mappings themselves.
            Subsequent calls to GetPropertyMapping will rebuild the cache as needed.
            </remarks>
        </member>
        <member name="T:ADMS.API.Services.PropertyMappingValue">
            <summary>
            Represents a property mapping configuration for translating between source and destination object properties.
            </summary>
            <remarks>
            This class is a core component of the property mapping system that enables:
            - Dynamic property mapping between different object types (DTOs to Entities)
            - Flexible sorting and filtering operations with property name translation
            - Support for complex property mappings with multiple destination properties
            - Bidirectional property mapping with optional revert functionality
            - Immutable property mapping configurations for thread safety
            
            The PropertyMappingValue is used extensively in:
            - Data transformation operations between API layers
            - Dynamic sorting operations in paginated queries
            - Property name translation for database queries
            - Filter expression building for search operations
            - Data shaping operations for API responses
            
            Key Features:
            - Immutable property collections for thread safety and consistency
            - Support for one-to-many property mappings (single source to multiple destinations)
            - Revert functionality for bidirectional mapping operations
            - Comprehensive validation of property mapping configurations
            - Performance-optimized property access with cached collections
            
            Usage Examples:
            - Mapping DTO property "Name" to Entity properties "FirstName" and "LastName"
            - Mapping API sort parameter "createdDate" to database column "CreationTimestamp"
            - Mapping filter property "isActive" to database expression "Status = 'Active'"
            - Supporting reverse mappings for data retrieval operations
            
            Thread Safety:
            - All properties are immutable after construction
            - DestinationProperties collection is converted to ImmutableList for thread safety
            - No mutable state that could cause threading issues
            - Safe for use in concurrent scenarios and dependency injection
            
            Performance Considerations:
            - Destination properties are cached as immutable collections
            - Property validation occurs once during construction
            - No runtime property modification overhead
            - Optimized for frequent read operations in mapping scenarios
            </remarks>
            <param name="destinationProperties">
            The collection of destination property names that the source property maps to.
            Must not be null and should contain at least one valid property name.
            Property names should correspond to valid properties on the destination object type.
            </param>
            <param name="revert">
            Optional flag indicating whether the mapping should be reversed for bidirectional operations.
            When true, the property mapping supports reverse translation from destination to source.
            Default value is false for standard one-way mapping operations.
            </param>
            <exception cref="T:System.ArgumentNullException">
            Thrown when destinationProperties parameter is null.
            </exception>
            <exception cref="T:System.ArgumentException">
            Thrown when destinationProperties collection is empty or contains null/whitespace property names.
            </exception>
            <example>
            <code>
            // Simple one-to-one property mapping
            var nameMapping = new PropertyMappingValue(new[] { "FullName" });
            
            // One-to-many property mapping with multiple destinations
            var addressMapping = new PropertyMappingValue(
                new[] { "Street", "City", "PostalCode" });
            
            // Bidirectional property mapping with revert support
            var bidirectionalMapping = new PropertyMappingValue(
                new[] { "DatabaseColumnName" }, 
                revert: true);
            
            // Complex mapping for sorting operations
            var sortMapping = new PropertyMappingValue(
                new[] { "LastName", "FirstName" }, 
                revert: false);
            </code>
            </example>
        </member>
        <member name="P:ADMS.API.Services.PropertyMappingValue.DestinationProperties">
            <summary>
            Gets the immutable collection of destination property names that the source property maps to.
            </summary>
            <remarks>
            This property provides:
            - Thread-safe access to destination property names
            - Immutable collection that cannot be modified after construction
            - Guaranteed to contain at least one valid property name
            - Property names correspond to valid properties on destination objects
            
            The destination properties are used for:
            - Building database query expressions with proper column names
            - Constructing LINQ expressions for entity property access
            - Validating property mappings against target object schemas
            - Generating sort and filter clauses for data operations
            
            Collection Characteristics:
            - Immutable after construction (ImmutableList implementation)
            - Thread-safe for concurrent access scenarios
            - Preserves original property name ordering for consistent operations
            - Validated to ensure no null or empty property names
            
            Common Usage Patterns:
            - Single property mapping: ["EntityPropertyName"]
            - Composite property mapping: ["LastName", "FirstName"]
            - Complex expression mapping: ["Address.Street", "Address.City"]
            </remarks>
            <value>
            An immutable collection of destination property names. 
            The collection is guaranteed to contain at least one non-null, non-empty property name.
            </value>
        </member>
        <member name="P:ADMS.API.Services.PropertyMappingValue.Revert">
            <summary>
            Gets a value indicating whether the property mapping supports bidirectional operations.
            </summary>
            <remarks>
            This property controls:
            - Direction of property mapping operations (one-way vs bidirectional)
            - Sort order behavior for database queries (ascending vs descending)
            - Filter expression construction for reverse mapping scenarios
            - Data transformation direction for complex mapping operations
            
            When Revert is true:
            - Property mappings can be applied in reverse direction
            - Sort operations may use descending order by default
            - Filter expressions support reverse property name resolution
            - Data transformation supports bidirectional conversion
            
            When Revert is false (default):
            - Property mappings are applied in forward direction only
            - Sort operations use ascending order by default
            - Filter expressions use standard property name resolution
            - Data transformation is unidirectional (source to destination)
            
            Usage Scenarios:
            - API sorting parameters that should reverse database sort order
            - Filter mappings that require inverse logic application
            - Data synchronization scenarios requiring bidirectional mapping
            - Complex property transformations with multiple mapping directions
            </remarks>
            <value>
            true if the property mapping supports bidirectional operations; 
            false for standard one-way mapping operations.
            </value>
        </member>
        <member name="P:ADMS.API.Services.PropertyMappingValue.PropertyCount">
            <summary>
            Gets the count of destination properties in the mapping configuration.
            </summary>
            <remarks>
            This convenience property provides:
            - Quick access to the number of destination properties without enumerating the collection
            - Performance optimization for scenarios that only need the count
            - Validation support for mapping configuration analysis
            - Debugging and monitoring capabilities for mapping complexity
            
            Common usage patterns:
            - Count = 1: Simple one-to-one property mapping
            - Count > 1: Complex one-to-many property mapping
            - Count validation in mapping configuration validation
            - Performance analysis of mapping complexity
            </remarks>
            <value>
            The number of destination properties in the mapping configuration.
            Always greater than zero due to constructor validation.
            </value>
        </member>
        <member name="P:ADMS.API.Services.PropertyMappingValue.IsSimpleMapping">
            <summary>
            Gets a value indicating whether this is a simple one-to-one property mapping.
            </summary>
            <remarks>
            This convenience property identifies:
            - Simple mappings with exactly one destination property
            - Optimized processing paths for common mapping scenarios
            - Validation scenarios for simple property transformations
            - Performance optimization opportunities for single property access
            
            Simple mappings (IsSimpleMapping = true) enable:
            - Direct property access without collection enumeration
            - Optimized LINQ expression generation
            - Faster validation and transformation operations
            - Simplified debugging and logging scenarios
            </remarks>
            <value>
            true if the mapping contains exactly one destination property; 
            false for complex mappings with multiple destination properties.
            </value>
        </member>
        <member name="M:ADMS.API.Services.PropertyMappingValue.#ctor(System.Collections.Generic.IEnumerable{System.String},System.Boolean)">
            <summary>
            Initializes a new instance of the PropertyMappingValue class with comprehensive validation.
            </summary>
            <param name="destinationProperties">
            The collection of destination property names that the source property maps to.
            Must not be null and should contain at least one valid property name.
            Property names should correspond to valid properties on the destination object type.
            </param>
            <param name="revert">
            Optional flag indicating whether the mapping should be reversed for bidirectional operations.
            When true, the property mapping supports reverse translation from destination to source.
            Default value is false for standard one-way mapping operations.
            </param>
            <exception cref="T:System.ArgumentNullException">
            Thrown when destinationProperties parameter is null.
            </exception>
            <exception cref="T:System.ArgumentException">
            Thrown when destinationProperties collection is empty or contains null/whitespace property names.
            </exception>
        </member>
        <member name="M:ADMS.API.Services.PropertyMappingValue.GetPrimaryProperty">
            <summary>
            Gets the first destination property name for simple mapping scenarios.
            </summary>
            <remarks>
            This convenience method provides:
            - Direct access to the primary destination property for simple mappings
            - Performance optimization for common single-property mapping scenarios
            - Simplified API for scenarios that only need the first property
            - Backward compatibility with code expecting single property names
            
            Usage considerations:
            - Best used with simple mappings (IsSimpleMapping = true)
            - For complex mappings, consider using DestinationProperties collection
            - Returns the first property in order-dependent mapping scenarios
            - Provides consistent behavior regardless of mapping complexity
            </remarks>
            <returns>
            The first destination property name in the mapping configuration.
            Guaranteed to be a non-null, non-empty string.
            </returns>
            <example>
            <code>
            var mapping = new PropertyMappingValue(new[] { "EntityPropertyName" });
            string primaryProperty = mapping.GetPrimaryProperty(); // Returns "EntityPropertyName"
            
            var complexMapping = new PropertyMappingValue(new[] { "LastName", "FirstName" });
            string firstProperty = complexMapping.GetPrimaryProperty(); // Returns "LastName"
            </code>
            </example>
        </member>
        <member name="M:ADMS.API.Services.PropertyMappingValue.ContainsProperty(System.String)">
            <summary>
            Determines whether the mapping contains the specified destination property name.
            </summary>
            <param name="propertyName">The property name to search for in the destination properties.</param>
            <returns>
            true if the specified property name is found in the destination properties; 
            otherwise, false.
            </returns>
            <remarks>
            This method provides:
            - Case-insensitive property name matching for robust property lookup
            - Validation support for mapping configuration verification
            - Dynamic property mapping validation during runtime operations
            - Integration support for property mapping validation frameworks
            
            The search is performed using:
            - Case-insensitive string comparison (OrdinalIgnoreCase)
            - Null-safe comparison handling
            - Performance-optimized collection search
            - Consistent behavior across different property name formats
            </remarks>
            <exception cref="T:System.ArgumentException">
            Thrown when propertyName is null, empty, or contains only whitespace.
            </exception>
            <example>
            <code>
            var mapping = new PropertyMappingValue(new[] { "FirstName", "LastName" });
            
            bool hasFirstName = mapping.ContainsProperty("FirstName");     // Returns true
            bool hasLastName = mapping.ContainsProperty("lastname");       // Returns true (case-insensitive)
            bool hasMiddleName = mapping.ContainsProperty("MiddleName");   // Returns false
            </code>
            </example>
        </member>
        <member name="M:ADMS.API.Services.PropertyMappingValue.WithReversedDirection">
            <summary>
            Creates a new PropertyMappingValue instance with the revert flag toggled.
            </summary>
            <returns>
            A new PropertyMappingValue instance with the same destination properties 
            but with the revert flag set to the opposite of the current value.
            </returns>
            <remarks>
            This method provides:
            - Immutable object pattern for creating modified mapping instances
            - Support for dynamic mapping direction changes during runtime
            - Functional programming approach to mapping configuration modification
            - Thread-safe mapping transformation without modifying original instance
            
            Use cases include:
            - Dynamic sort direction changes in user interface operations
            - Bidirectional data synchronization scenarios
            - API parameter processing with direction-specific mapping requirements
            - Configuration-driven mapping direction control
            
            The returned instance:
            - Shares the same destination properties collection (immutable)
            - Has the opposite revert flag value
            - Is completely independent of the original instance
            - Maintains all validation guarantees of the original mapping
            </remarks>
            <example>
            <code>
            var originalMapping = new PropertyMappingValue(new[] { "Name" }, revert: false);
            var reversedMapping = originalMapping.WithReversedDirection();
            
            Console.WriteLine(originalMapping.Revert);  // Output: False
            Console.WriteLine(reversedMapping.Revert);  // Output: True
            </code>
            </example>
        </member>
        <member name="M:ADMS.API.Services.PropertyMappingValue.ToString">
            <summary>
            Returns a string representation of the property mapping configuration.
            </summary>
            <returns>
            A string containing the destination properties and revert flag information
            in a human-readable format suitable for debugging and logging.
            </returns>
            <remarks>
            The string representation includes:
            - All destination property names in a comma-separated list
            - Revert flag status for bidirectional mapping indication
            - Formatted output suitable for debugging and diagnostic purposes
            - Consistent formatting for logging and monitoring scenarios
            
            Output format examples:
            - Simple mapping: "Properties: [Name], Revert: False"
            - Complex mapping: "Properties: [LastName, FirstName], Revert: True"
            - Single property with revert: "Properties: [CreatedDate], Revert: True"
            
            This method is particularly useful for:
            - Debugging property mapping configurations
            - Logging mapping operations for audit trails
            - Displaying mapping information in diagnostic tools
            - Troubleshooting property mapping issues
            </remarks>
            <example>
            <code>
            var mapping = new PropertyMappingValue(new[] { "FirstName", "LastName" }, revert: true);
            string description = mapping.ToString();
            // Output: "Properties: [FirstName, LastName], Revert: True"
            </code>
            </example>
        </member>
        <member name="M:ADMS.API.Services.PropertyMappingValue.Equals(System.Object)">
            <summary>
            Determines whether the specified object is equal to the current PropertyMappingValue.
            </summary>
            <param name="obj">The object to compare with the current PropertyMappingValue.</param>
            <returns>
            true if the specified object is equal to the current PropertyMappingValue; 
            otherwise, false.
            </returns>
            <remarks>
            Equality comparison includes:
            - Type compatibility checking (must be PropertyMappingValue)
            - Destination properties collection comparison (order-sensitive)
            - Revert flag value comparison
            - Case-insensitive property name comparison for robustness
            
            Two PropertyMappingValue instances are considered equal when:
            - They have the same number of destination properties
            - All destination properties match (case-insensitive, order-sensitive)
            - Both have the same revert flag value
            - Both are non-null PropertyMappingValue instances
            
            This implementation supports:
            - Dictionary and HashSet operations with PropertyMappingValue keys
            - Equality-based collection operations and comparisons
            - Unit testing scenarios with equality assertions
            - Configuration comparison and validation scenarios
            </remarks>
            <example>
            <code>
            var mapping1 = new PropertyMappingValue(new[] { "Name" }, revert: false);
            var mapping2 = new PropertyMappingValue(new[] { "Name" }, revert: false);
            var mapping3 = new PropertyMappingValue(new[] { "Name" }, revert: true);
            
            bool areEqual1 = mapping1.Equals(mapping2);  // Returns true
            bool areEqual2 = mapping1.Equals(mapping3);  // Returns false (different revert values)
            </code>
            </example>
        </member>
        <!-- Badly formed XML comment ignored for member "M:ADMS.API.Services.PropertyMappingValue.GetHashCode" -->
        <!-- Badly formed XML comment ignored for member "M:ADMS.API.Services.PropertyMappingValue.IsValidForType``1" -->
        <member name="M:ADMS.API.Services.PropertyMappingValue.ValidatePropertyPath(System.String,System.Collections.Generic.ISet{System.String})">
            <summary>
            Validates a property path against available properties, supporting nested property access.
            </summary>
            <param name="propertyPath">The property path to validate (e.g., "Address.Street").</param>
            <param name="availableProperties">The set of available property names for validation.</param>
            <returns>true if the property path is valid; otherwise, false.</returns>
        </member>
        <member name="T:ADMS.API.Services.ValidationService">
            <summary>
            Centralized validation service providing comprehensive validation logic for ADMS API operations.
            </summary>
            <remarks>
            This service implements comprehensive validation functionality for the ADMS system including:
            - Object validation using data annotations and custom validation logic
            - Entity existence validation with proper error responses
            - Parameter validation with standardized error handling
            - Business rule validation for complex scenarios
            - Specialized validation for file operations, email addresses, and data formats
            
            The service follows established patterns for:
            - Consistent error response formatting using RFC 7807 Problem Details
            - Structured logging with appropriate context and correlation
            - Centralized validation logic to eliminate code duplication
            - Standardized HTTP status code usage following REST conventions
            - Comprehensive input sanitization and validation
            
            Key Features:
            - Data annotation validation with detailed error reporting
            - Entity existence validation with database integration
            - Format validation for emails, file extensions, MIME types, and checksums
            - Business rule validation for document operations
            - Model state validation with proper error propagation
            - GUID validation with empty value checking
            - String validation with null/empty checking
            
            Security Features:
            - Input sanitization through comprehensive validation
            - SQL injection prevention through parameterized validation
            - Cross-site scripting (XSS) prevention through format validation
            - File type validation to prevent malicious uploads
            - Checksum validation for data integrity
            
            The service integrates with:
            - Entity Framework for database existence validation
            - ASP.NET Core model binding and validation infrastructure
            - Logging infrastructure for audit trails and debugging
            - Problem Details factory for consistent error responses
            </remarks>
        </member>
        <member name="M:ADMS.API.Services.ValidationService.#ctor(ADMS.API.Services.Common.IEntityExistenceValidator,Microsoft.Extensions.Logging.ILogger{ADMS.API.Services.ValidationService},Microsoft.AspNetCore.Mvc.Infrastructure.ProblemDetailsFactory)">
            <summary>
            Centralized validation service providing comprehensive validation logic for ADMS API operations.
            </summary>
            <remarks>
            This service implements comprehensive validation functionality for the ADMS system including:
            - Object validation using data annotations and custom validation logic
            - Entity existence validation with proper error responses
            - Parameter validation with standardized error handling
            - Business rule validation for complex scenarios
            - Specialized validation for file operations, email addresses, and data formats
            
            The service follows established patterns for:
            - Consistent error response formatting using RFC 7807 Problem Details
            - Structured logging with appropriate context and correlation
            - Centralized validation logic to eliminate code duplication
            - Standardized HTTP status code usage following REST conventions
            - Comprehensive input sanitization and validation
            
            Key Features:
            - Data annotation validation with detailed error reporting
            - Entity existence validation with database integration
            - Format validation for emails, file extensions, MIME types, and checksums
            - Business rule validation for document operations
            - Model state validation with proper error propagation
            - GUID validation with empty value checking
            - String validation with null/empty checking
            
            Security Features:
            - Input sanitization through comprehensive validation
            - SQL injection prevention through parameterized validation
            - Cross-site scripting (XSS) prevention through format validation
            - File type validation to prevent malicious uploads
            - Checksum validation for data integrity
            
            The service integrates with:
            - Entity Framework for database existence validation
            - ASP.NET Core model binding and validation infrastructure
            - Logging infrastructure for audit trails and debugging
            - Problem Details factory for consistent error responses
            </remarks>
        </member>
        <member name="M:ADMS.API.Services.ValidationService.ValidateObject``1(``0)">
            <summary>
            Validates the specified object against its data annotations and custom validation logic.
            </summary>
            <remarks>
            This method provides comprehensive object validation including:
            - Data annotation validation (Required, Range, MaxLength, RegularExpression, etc.)
            - Custom validation through IValidatableObject implementation
            - Recursive validation of complex object properties
            - Detailed error reporting with property-level error messages
            
            The validation process:
            1. Creates a ValidationContext for the object
            2. Performs comprehensive validation including all properties
            3. Collects all validation errors with property attribution
            4. Returns structured ValidationProblemDetails for client consumption
            5. Logs validation failures for debugging and monitoring
            
            Error Response Format:
            - Uses ValidationProblemDetails following RFC 7807
            - Groups errors by property name for client-side handling
            - Provides detailed error messages for each validation failure
            - Includes proper HTTP status codes (400 Bad Request)
            </remarks>
            <typeparam name="T">The type of the object to validate.</typeparam>
            <param name="obj">The object to validate. Cannot be null.</param>
            <returns>
            A BadRequestObjectResult containing ValidationProblemDetails if validation fails;
            otherwise, null if the object is valid.
            </returns>
            <exception cref="T:System.ArgumentNullException">Thrown when obj is null.</exception>
        </member>
        <member name="M:ADMS.API.Services.ValidationService.ValidateModelState(Microsoft.AspNetCore.Mvc.ModelBinding.ModelStateDictionary)">
            <summary>
            Validates the provided model state dictionary and returns appropriate error responses.
            </summary>
            <remarks>
            This method validates ASP.NET Core model state which captures:
            - Model binding errors (type conversion, format issues)
            - Data annotation validation errors
            - Custom validation errors added during model binding
            - Property-level and model-level validation failures
            
            The validation provides:
            - Structured error responses with property-level error grouping
            - Consistent error formatting using ValidationProblemDetails
            - Proper HTTP status codes following REST conventions
            - Detailed logging for debugging and monitoring
            
            Common scenarios handled:
            - Invalid JSON format in request body
            - Type conversion errors (e.g., string to int)
            - Missing required properties in JSON
            - Format validation failures (e.g., invalid email format)
            - Range validation failures (e.g., negative values where positive required)
            </remarks>
            <param name="modelState">The ASP.NET Core ModelStateDictionary to validate.</param>
            <returns>
            A BadRequestObjectResult containing ValidationProblemDetails if model state is invalid;
            otherwise, null if model state is valid.
            </returns>
            <exception cref="T:System.ArgumentNullException">Thrown when modelState is null.</exception>
        </member>
        <member name="M:ADMS.API.Services.ValidationService.ValidateGuid(System.Guid,System.String)">
            <summary>
            Validates that the provided GUID is not empty and returns appropriate error responses.
            </summary>
            <remarks>
            This method validates GUID parameters which are commonly used as:
            - Entity identifiers (matterId, documentId, revisionId)
            - Route parameters in RESTful APIs
            - Query parameters for resource identification
            - Foreign key references in entity relationships
            
            Validation includes:
            - Empty GUID detection (Guid.Empty or all zeros)
            - Proper error response formatting with RFC 7807 compliance
            - Structured logging with parameter context
            - Consistent error messaging across the API
            
            The method is essential for:
            - Route parameter validation in controllers
            - Entity identifier validation before database queries
            - Foreign key validation in entity relationships
            - Request parameter sanitization and security
            </remarks>
            <param name="id">The GUID value to validate.</param>
            <param name="parameterName">The name of the parameter being validated for error reporting.</param>
            <returns>
            A BadRequestObjectResult with problem details if the GUID is empty;
            otherwise, null if the GUID is valid.
            </returns>
            <exception cref="T:System.ArgumentNullException">Thrown when parameterName is null.</exception>
        </member>
        <member name="M:ADMS.API.Services.ValidationService.ValidateStringNotEmpty(System.String,System.String)">
            <summary>
            Validates that the provided string is not null, empty, or whitespace.
            </summary>
            <remarks>
            This method validates string parameters for:
            - Required text input validation
            - Non-empty string requirement enforcement
            - Whitespace-only string detection and rejection
            - Input sanitization for security purposes
            
            Common use cases include:
            - File name validation
            - User input validation
            - Required field validation
            - Configuration parameter validation
            - Search query validation
            
            The validation helps prevent:
            - Empty or null reference exceptions
            - Database constraint violations
            - Business logic errors from empty inputs
            - Security issues from malformed input
            </remarks>
            <param name="value">The string value to validate.</param>
            <param name="parameterName">The name of the parameter being validated for error reporting.</param>
            <returns>True if the string is valid (not null/empty/whitespace); otherwise, false.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown when parameterName is null.</exception>
        </member>
        <member name="M:ADMS.API.Services.ValidationService.ValidateNotNull(System.Object,System.String)">
            <summary>
            Validates that the provided object is not null and returns appropriate error responses.
            </summary>
            <remarks>
            This method provides null validation for:
            - DTO parameters in API endpoints
            - Required object properties
            - Method parameters that cannot be null
            - Entity validation before database operations
            
            The validation includes:
            - Comprehensive null checking
            - Structured error response formatting
            - Proper HTTP status codes (400 Bad Request)
            - Detailed logging for debugging and monitoring
            
            Use cases include:
            - API request body validation
            - Service method parameter validation
            - Entity validation before persistence
            - Configuration object validation
            </remarks>
            <param name="obj">The object to validate for null.</param>
            <param name="parameterName">The name of the parameter being validated for error reporting.</param>
            <returns>
            A BadRequestObjectResult with problem details if the object is null;
            otherwise, null if the object is valid.
            </returns>
            <exception cref="T:System.ArgumentNullException">Thrown when parameterName is null.</exception>
        </member>
        <member name="M:ADMS.API.Services.ValidationService.ValidateMatterExistsAsync(System.Guid)">
            <summary>
            Validates if the specified matter exists in the database.
            </summary>
            <remarks>
            This method provides matter existence validation including:
            - Database query execution through entity existence validator
            - Proper error response formatting with 404 Not Found status
            - Structured logging for audit trails and debugging
            - Consistent error messaging across matter-related operations
            
            The validation is essential for:
            - Route parameter validation in matter-scoped endpoints
            - Foreign key validation before document operations
            - Authorization and access control validation
            - Data integrity enforcement in business operations
            
            Error handling includes:
            - Specific HTTP 404 status codes for missing entities
            - Detailed error messages for client applications
            - Structured logging for monitoring and debugging
            - Consistent problem details format across the API
            </remarks>
            <param name="matterId">The unique identifier of the matter to validate.</param>
            <returns>
            A NotFoundObjectResult with problem details if the matter does not exist;
            otherwise, null if the matter exists.
            </returns>
        </member>
        <member name="M:ADMS.API.Services.ValidationService.ValidateDocumentExistsAsync(System.Guid)">
            <summary>
            Validates if the specified document exists in the database.
            </summary>
            <remarks>
            This method provides document existence validation including:
            - Database query execution for document lookup
            - Proper HTTP status code usage (404 Not Found for missing documents)
            - Comprehensive logging for audit and debugging purposes
            - Standardized error response formatting
            
            The validation supports:
            - Document-scoped operation validation
            - Entity relationship integrity checking
            - Authorization prerequisite validation
            - Data consistency enforcement
            
            Common usage scenarios:
            - Before document update or deletion operations
            - For revision creation validation
            - In document access control validation
            - For file operation prerequisite checking
            </remarks>
            <param name="documentId">The unique identifier of the document to validate.</param>
            <returns>
            A NotFoundObjectResult with problem details if the document does not exist;
            otherwise, null if the document exists.
            </returns>
        </member>
        <member name="M:ADMS.API.Services.ValidationService.ValidateRevisionExistsAsync(System.Guid)">
            <summary>
            Validates if the specified revision exists in the database.
            </summary>
            <remarks>
            This method provides revision existence validation including:
            - Database query execution for revision lookup
            - Appropriate HTTP status code handling (404 Not Found)
            - Detailed logging for operations tracking
            - Consistent error response structure
            
            Revision validation supports:
            - Revision-specific operations (update, delete, access)
            - Entity hierarchy validation (revision -> document -> matter)
            - File operation validation for specific revisions
            - Audit trail validation for revision activities
            
            The method is crucial for:
            - File download operations targeting specific revisions
            - Revision metadata operations
            - Revision history and audit operations
            - Business rule enforcement at revision level
            </remarks>
            <param name="revisionId">The unique identifier of the revision to validate.</param>
            <returns>
            A NotFoundObjectResult with problem details if the revision does not exist;
            otherwise, null if the revision exists.
            </returns>
        </member>
        <member name="M:ADMS.API.Services.ValidationService.ValidateDocumentForCreationAsync(System.Guid,ADMS.API.Models.DocumentForCreationDto)">
            <summary>
            Validates a document for creation operations with comprehensive business rule checking.
            </summary>
            <remarks>
            This method performs comprehensive document creation validation including:
            
            File and Content Validation:
            - File name presence and format validation
            - File extension validation against allowed types
            - MIME type validation and format checking
            - File size validation within acceptable limits
            - Checksum validation for data integrity
            
            Business Rule Validation:
            - Duplicate file name detection within matter scope
            - File type restrictions based on security policies
            - Content validation to prevent malicious uploads
            - Matter-specific file constraints
            
            Security Validation:
            - File extension allow-list enforcement
            - MIME type validation against known safe types
            - File name sanitization and security checking
            - Content-based file type verification
            
            The validation process:
            1. Validates required fields (file name, extension, MIME type)
            2. Performs format validation using regex patterns
            3. Checks business rules (duplicate names, file restrictions)
            4. Returns structured validation results for error handling
            5. Logs all validation failures for audit and debugging
            
            This method is essential for maintaining data integrity and security
            in document creation operations across the ADMS system.
            </remarks>
            <param name="matterId">The unique identifier of the matter where the document will be created.</param>
            <param name="document">The document creation DTO containing the document information to validate.</param>
            <returns>
            An enumerable collection of ValidationResult objects containing any validation errors found.
            An empty collection indicates successful validation.
            </returns>
        </member>
        <member name="M:ADMS.API.Services.ValidationService.ValidateDocumentForUpdate(ADMS.API.Models.DocumentForUpdateDto)">
            <summary>
            Validates a document for update operations with comprehensive business rule checking.
            </summary>
            <remarks>
            This method performs comprehensive document update validation including:
            
            Content Validation:
            - File name presence and format requirements
            - File extension format and security validation
            - MIME type format validation and consistency checking
            - File size validation within acceptable ranges
            - Checksum integrity validation
            
            Business Rule Validation:
            - Document state consistency checking (deleted vs checked out)
            - Update permission validation based on document state
            - File content consistency validation
            - Version control state validation
            
            State Validation:
            - Prevents documents from being both deleted and checked out
            - Validates state transitions for document lifecycle
            - Ensures consistent document status across operations
            - Validates user permissions for state changes
            
            The validation ensures:
            - Data integrity during update operations
            - Business rule compliance for document management
            - Security validation for file content changes
            - Consistent document state management
            
            This method is critical for maintaining document integrity and
            enforcing business rules during update operations.
            </remarks>
            <param name="document">The document update DTO containing the updated document information to validate.</param>
            <returns>
            An enumerable collection of ValidationResult objects containing any validation errors found.
            An empty collection indicates successful validation.
            </returns>
        </member>
        <member name="M:ADMS.API.Services.ValidationService.ValidateEmail(System.String,System.String)">
            <summary>
            Validates if the provided string is a valid email address format.
            </summary>
            <remarks>
            This method provides email validation including:
            - Format validation using RFC-compliant regex patterns
            - Null and empty string handling
            - Comprehensive logging for debugging and monitoring
            - Security validation to prevent email injection attacks
            
            Email Validation Features:
            - Basic RFC 822 format compliance checking
            - Prevents common email format injection attempts
            - Supports international domain names and TLDs
            - Validates local and domain parts of email addresses
            
            Security Considerations:
            - Prevents email header injection attacks
            - Validates against malicious email format strings
            - Protects against SMTP injection attempts
            - Ensures proper email format for system notifications
            
            The validation uses compiled regex for performance optimization
            and follows established patterns for email format validation.
            While not 100% RFC-compliant, it covers the vast majority of
            valid email address formats used in practice.
            </remarks>
            <param name="email">The email address string to validate.</param>
            <param name="parameterName">The name of the parameter being validated for error reporting.</param>
            <returns>True if the email format is valid; otherwise, false.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown when parameterName is null.</exception>
        </member>
        <member name="M:ADMS.API.Services.ValidationService.ValidateFileExtension(System.String,System.String)">
            <summary>
            Validates if the provided string is a valid file extension format.
            </summary>
            <remarks>
            This method validates file extensions for:
            - Security purposes (preventing malicious file uploads)
            - Format consistency across the application
            - Database storage requirements and constraints
            - File type identification and handling
            
            File Extension Validation:
            - Accepts extensions with or without leading dot
            - Validates length between 2-5 characters
            - Ensures alphanumeric characters only
            - Prevents special characters and injection attempts
            
            Security Features:
            - Prevents directory traversal attempts in extensions
            - Blocks malicious file extension combinations
            - Validates against known safe file extension patterns
            - Protects against file type masquerading attacks
            
            The validation supports common file extensions while maintaining
            security by restricting to alphanumeric characters only.
            This prevents many types of file-based attacks while supporting
            legitimate file types used in document management.
            </remarks>
            <param name="extension">The file extension string to validate.</param>
            <param name="parameterName">The name of the parameter being validated for error reporting.</param>
            <returns>True if the file extension format is valid; otherwise, false.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown when parameterName is null.</exception>
        </member>
        <member name="M:ADMS.API.Services.ValidationService.ValidateMimeType(System.String,System.String)">
            <summary>
            Validates if the provided string is a valid MIME type format.
            </summary>
            <remarks>
            This method validates MIME types for:
            - HTTP content type header validation
            - File upload security and content validation
            - Content negotiation support
            - Database storage format consistency
            
            MIME Type Validation:
            - Validates standard type/subtype format
            - Supports media type parameters
            - Handles vendor-specific MIME types
            - Validates against injection attacks
            
            Security Features:
            - Prevents MIME type spoofing attacks
            - Validates against malicious content type headers
            - Ensures proper MIME type format for security
            - Protects against content type confusion attacks
            
            Format Support:
            - Standard MIME types (text/html, application/json)
            - Vendor-specific types (application/vnd.ms-excel)
            - Media types with parameters
            - Common document and image MIME types
            
            The validation uses regex patterns that cover the vast majority
            of legitimate MIME types while preventing malicious formats.
            </remarks>
            <param name="mimeType">The MIME type string to validate.</param>
            <param name="parameterName">The name of the parameter being validated for error reporting.</param>
            <returns>True if the MIME type format is valid; otherwise, false.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown when parameterName is null.</exception>
        </member>
        <member name="M:ADMS.API.Services.ValidationService.ValidateChecksum(System.String,System.String)">
            <summary>
            Validates if the provided string is a valid checksum format.
            </summary>
            <remarks>
            This method validates checksums for:
            - File integrity verification
            - Data corruption detection
            - Security validation of file content
            - Database storage format consistency
            
            Checksum Validation:
            - Validates SHA256 64-character hexadecimal format
            - Ensures proper hex character usage (0-9, A-F, a-f)
            - Validates exact length requirements
            - Prevents malicious checksum injection
            
            Security Features:
            - Ensures checksum integrity for file verification
            - Validates against checksum manipulation attacks
            - Provides data integrity validation
            - Supports secure file verification workflows
            
            The method specifically validates SHA256 checksums which are
            64 hexadecimal characters long. This is the standard checksum
            format used throughout the ADMS system for file integrity.
            </remarks>
            <param name="checksum">The checksum string to validate.</param>
            <param name="parameterName">The name of the parameter being validated for error reporting.</param>
            <returns>True if the checksum format is valid; otherwise, false.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown when parameterName is null.</exception>
        </member>
        <member name="M:ADMS.API.Services.ValidationService.CreateProblemDetails(System.Int32,System.String,System.String)">
            <summary>
            Creates a standardized problem details object for error responses.
            </summary>
            <remarks>
            This method creates RFC 7807 compliant problem details for:
            - Consistent error response formatting across the API
            - Structured error information for client applications
            - Proper HTTP status code usage
            - Enhanced debugging and monitoring capabilities
            
            The problem details include:
            - HTTP status code with proper REST semantics
            - Detailed error message for client consumption
            - Parameter context for specific field errors
            - Type URI for error categorization
            - Instance information for debugging
            </remarks>
            <param name="statusCode">The HTTP status code for the error.</param>
            <param name="detail">The detailed error message.</param>
            <param name="parameterName">Optional parameter name for field-specific errors.</param>
            <returns>A properly formatted ProblemDetails object.</returns>
        </member>
        <member name="M:ADMS.API.Services.ValidationService.CreateInternalServerErrorResponse(System.String)">
            <summary>
            Creates a standardized internal server error response.
            </summary>
            <remarks>
            This method creates consistent 500 Internal Server Error responses
            for unexpected validation errors while protecting sensitive system
            information from being exposed to clients.
            </remarks>
            <param name="operationContext">Description of the operation that failed.</param>
            <returns>A standardized internal server error response.</returns>
        </member>
        <member name="M:ADMS.API.Services.ValidationService.EmailRegex">
            <remarks>
            Pattern:<br/>
            <code>^[^@\\s]+@[^@\\s]+\\.[^@\\s]+$</code><br/>
            Options:<br/>
            <code>RegexOptions.IgnoreCase | RegexOptions.Compiled</code><br/>
            Explanation:<br/>
            <code>
            ○ Match if at the beginning of the string.<br/>
            ○ Match a character in the set [^@\s] atomically at least once.<br/>
            ○ Match '@'.<br/>
            ○ Match a character in the set [^@\s] greedily at least once.<br/>
            ○ Match '.'.<br/>
            ○ Match a character in the set [^@\s] atomically at least once.<br/>
            ○ Match if at the end of the string or if before an ending newline.<br/>
            </code>
            </remarks>
        </member>
        <member name="M:ADMS.API.Services.ValidationService.FileExtensionRegex">
            <remarks>
            Pattern:<br/>
            <code>^\\.?[a-zA-Z0-9]{2,5}$</code><br/>
            Options:<br/>
            <code>RegexOptions.Compiled</code><br/>
            Explanation:<br/>
            <code>
            ○ Match if at the beginning of the string.<br/>
            ○ Match '.' atomically, optionally.<br/>
            ○ Match a character in the set [0-9A-Za-z] atomically at least 2 and at most 5 times.<br/>
            ○ Match if at the end of the string or if before an ending newline.<br/>
            </code>
            </remarks>
        </member>
        <member name="M:ADMS.API.Services.ValidationService.MimeTypeRegex">
            <remarks>
            Pattern:<br/>
            <code>^[\\w\\.\\-]+\\/[\\w\\.\\-\\+]+$</code><br/>
            Options:<br/>
            <code>RegexOptions.Compiled</code><br/>
            Explanation:<br/>
            <code>
            ○ Match if at the beginning of the string.<br/>
            ○ Match a character in the set [-.\w] atomically at least once.<br/>
            ○ Match '/'.<br/>
            ○ Match a character in the set [+-.\w] atomically at least once.<br/>
            ○ Match if at the end of the string or if before an ending newline.<br/>
            </code>
            </remarks>
        </member>
        <member name="M:ADMS.API.Services.ValidationService.ChecksumRegex">
            <remarks>
            Pattern:<br/>
            <code>^[A-Fa-f0-9]{64}$</code><br/>
            Options:<br/>
            <code>RegexOptions.Compiled</code><br/>
            Explanation:<br/>
            <code>
            ○ Match if at the beginning of the string.<br/>
            ○ Match a character in the set [0-9A-Fa-f] exactly 64 times.<br/>
            ○ Match if at the end of the string or if before an ending newline.<br/>
            </code>
            </remarks>
        </member>
        <member name="T:ADMS.API.Services.FileValidationConstants">
            <summary>
            Constants for file validation constraints used throughout the ADMS system.
            </summary>
        </member>
        <member name="F:ADMS.API.Services.FileValidationConstants.MaxFileNameLength">
            <summary>
            Maximum allowed length for file names (255 characters).
            </summary>
        </member>
        <member name="F:ADMS.API.Services.FileValidationConstants.MaxExtensionLength">
            <summary>
            Maximum allowed length for file extensions (10 characters).
            </summary>
        </member>
        <member name="T:ADMS.API.ResourceParameters.PagedResourceParameters">
            <summary>
            Base resource parameters for paginated API endpoints.
            </summary>
        </member>
        <member name="P:ADMS.API.ResourceParameters.PagedResourceParameters.PageNumber">
            <summary>
            Page number to retrieve.
            </summary>
        </member>
        <member name="P:ADMS.API.ResourceParameters.PagedResourceParameters.PageSize">
            <summary>
            Page size to retrieve.
            </summary>
        </member>
        <member name="P:ADMS.API.ResourceParameters.PagedResourceParameters.OrderBy">
            <summary>
            Order by field(s).
            </summary>
        </member>
        <member name="P:ADMS.API.ResourceParameters.PagedResourceParameters.Fields">
            <summary>
            Fields for data shaping.
            </summary>
        </member>
        <member name="T:ADMS.API.ResourceParameters.DocumentAuditsResourceParameters">
            <summary>
            Resource parameters for querying and paginating document audit records.
            </summary>
        </member>
        <member name="P:ADMS.API.ResourceParameters.DocumentAuditsResourceParameters.SearchQuery">
            <summary>
            Gets or sets the search query to filter document audits by relevant fields.
            </summary>
        </member>
        <member name="P:ADMS.API.ResourceParameters.DocumentAuditsResourceParameters.OrderBy">
            <summary>
            Gets or sets the order by clause for sorting document audits.
            Inherited from <see cref="T:ADMS.API.ResourceParameters.PagedResourceParameters"/>.
            </summary>
        </member>
        <member name="T:ADMS.API.ResourceParameters.DocumentsResourceParameters">
            <summary>
            Resource Parameters for Documents API
            </summary>
        </member>
        <member name="P:ADMS.API.ResourceParameters.DocumentsResourceParameters.FileName">
            <summary>
            FileName to search
            </summary>
        </member>
        <member name="P:ADMS.API.ResourceParameters.DocumentsResourceParameters.SearchQuery">
            <summary>
            Search query to run
            </summary>
        </member>
        <member name="T:ADMS.API.ResourceParameters.MattersResourceParameters">
            <summary>
            Resource Parameters for Matters API
            </summary>
        </member>
        <member name="P:ADMS.API.ResourceParameters.MattersResourceParameters.Description">
            <summary>
            Matter description.
            </summary>
        </member>
        <member name="P:ADMS.API.ResourceParameters.MattersResourceParameters.IsArchived">
            <summary>
            Is the matter archived?
            </summary>
        </member>
        <member name="P:ADMS.API.ResourceParameters.MattersResourceParameters.IsDeleted">
            <summary>
            Is the matter deleted?
            </summary>
        </member>
        <member name="M:ADMS.API.ResourceParameters.MattersResourceParameters.#ctor">
            <summary>
            MatterResourceParameters constructor.
            </summary>
        </member>
        <member name="T:ADMS.API.ResourceParameters.RevisionsResourceParameters">
            <summary>
            Resource parameters for querying and paginating revision records.
            </summary>
        </member>
        <member name="P:ADMS.API.ResourceParameters.RevisionsResourceParameters.IncludeDeleted">
            <summary>
            Gets or sets a value indicating whether to include deleted revisions in the results.
            </summary>
        </member>
        <member name="M:ADMS.API.ResourceParameters.RevisionsResourceParameters.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:ADMS.API.ResourceParameters.RevisionsResourceParameters"/> class
            with default sorting by RevisionNumber.
            </summary>
        </member>
        <member name="P:ADMS.API.ResourceParameters.RevisionsResourceParameters.OrderBy">
            <summary>
            Gets or sets the order by clause for sorting revisions.
            Inherited from <see cref="T:ADMS.API.ResourceParameters.PagedResourceParameters"/>.
            </summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.EmailRegex_0">
            <summary>Custom <see cref="T:System.Text.RegularExpressions.Regex"/>-derived type for the EmailRegex method.</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.EmailRegex_0.Instance">
            <summary>Cached, thread-safe singleton instance.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.EmailRegex_0.#ctor">
            <summary>Initializes the instance.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.EmailRegex_0.RunnerFactory">
            <summary>Provides a factory for creating <see cref="T:System.Text.RegularExpressions.RegexRunner"/> instances to be used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.EmailRegex_0.RunnerFactory.CreateInstance">
            <summary>Creates an instance of a <see cref="T:System.Text.RegularExpressions.RegexRunner"/> used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.EmailRegex_0.RunnerFactory.Runner">
            <summary>Provides the runner that contains the custom logic implementing the specified regular expression.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.EmailRegex_0.RunnerFactory.Runner.Scan(System.ReadOnlySpan{System.Char})">
            <summary>Scan the <paramref name="inputSpan"/> starting from base.runtextstart for the next match.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.EmailRegex_0.RunnerFactory.Runner.TryFindNextPossibleStartingPosition(System.ReadOnlySpan{System.Char})">
            <summary>Search <paramref name="inputSpan"/> starting from base.runtextpos for the next location a match could possibly start.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if a possible match was found; false if no more matches are possible.</returns>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.EmailRegex_0.RunnerFactory.Runner.TryMatchAtCurrentPosition(System.ReadOnlySpan{System.Char})">
            <summary>Determine whether <paramref name="inputSpan"/> at base.runtextpos is a match for the regular expression.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if the regular expression matches at the current position; otherwise, false.</returns>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.FileExtensionRegex_1">
            <summary>Custom <see cref="T:System.Text.RegularExpressions.Regex"/>-derived type for the FileExtensionRegex method.</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.FileExtensionRegex_1.Instance">
            <summary>Cached, thread-safe singleton instance.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.FileExtensionRegex_1.#ctor">
            <summary>Initializes the instance.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.FileExtensionRegex_1.RunnerFactory">
            <summary>Provides a factory for creating <see cref="T:System.Text.RegularExpressions.RegexRunner"/> instances to be used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.FileExtensionRegex_1.RunnerFactory.CreateInstance">
            <summary>Creates an instance of a <see cref="T:System.Text.RegularExpressions.RegexRunner"/> used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.FileExtensionRegex_1.RunnerFactory.Runner">
            <summary>Provides the runner that contains the custom logic implementing the specified regular expression.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.FileExtensionRegex_1.RunnerFactory.Runner.Scan(System.ReadOnlySpan{System.Char})">
            <summary>Scan the <paramref name="inputSpan"/> starting from base.runtextstart for the next match.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.FileExtensionRegex_1.RunnerFactory.Runner.TryFindNextPossibleStartingPosition(System.ReadOnlySpan{System.Char})">
            <summary>Search <paramref name="inputSpan"/> starting from base.runtextpos for the next location a match could possibly start.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if a possible match was found; false if no more matches are possible.</returns>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.FileExtensionRegex_1.RunnerFactory.Runner.TryMatchAtCurrentPosition(System.ReadOnlySpan{System.Char})">
            <summary>Determine whether <paramref name="inputSpan"/> at base.runtextpos is a match for the regular expression.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if the regular expression matches at the current position; otherwise, false.</returns>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.MimeTypeRegex_2">
            <summary>Custom <see cref="T:System.Text.RegularExpressions.Regex"/>-derived type for the MimeTypeRegex method.</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.MimeTypeRegex_2.Instance">
            <summary>Cached, thread-safe singleton instance.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.MimeTypeRegex_2.#ctor">
            <summary>Initializes the instance.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.MimeTypeRegex_2.RunnerFactory">
            <summary>Provides a factory for creating <see cref="T:System.Text.RegularExpressions.RegexRunner"/> instances to be used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.MimeTypeRegex_2.RunnerFactory.CreateInstance">
            <summary>Creates an instance of a <see cref="T:System.Text.RegularExpressions.RegexRunner"/> used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.MimeTypeRegex_2.RunnerFactory.Runner">
            <summary>Provides the runner that contains the custom logic implementing the specified regular expression.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.MimeTypeRegex_2.RunnerFactory.Runner.Scan(System.ReadOnlySpan{System.Char})">
            <summary>Scan the <paramref name="inputSpan"/> starting from base.runtextstart for the next match.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.MimeTypeRegex_2.RunnerFactory.Runner.TryFindNextPossibleStartingPosition(System.ReadOnlySpan{System.Char})">
            <summary>Search <paramref name="inputSpan"/> starting from base.runtextpos for the next location a match could possibly start.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if a possible match was found; false if no more matches are possible.</returns>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.MimeTypeRegex_2.RunnerFactory.Runner.TryMatchAtCurrentPosition(System.ReadOnlySpan{System.Char})">
            <summary>Determine whether <paramref name="inputSpan"/> at base.runtextpos is a match for the regular expression.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if the regular expression matches at the current position; otherwise, false.</returns>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.ChecksumRegex_3">
            <summary>Custom <see cref="T:System.Text.RegularExpressions.Regex"/>-derived type for the ChecksumRegex method.</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.ChecksumRegex_3.Instance">
            <summary>Cached, thread-safe singleton instance.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.ChecksumRegex_3.#ctor">
            <summary>Initializes the instance.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.ChecksumRegex_3.RunnerFactory">
            <summary>Provides a factory for creating <see cref="T:System.Text.RegularExpressions.RegexRunner"/> instances to be used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.ChecksumRegex_3.RunnerFactory.CreateInstance">
            <summary>Creates an instance of a <see cref="T:System.Text.RegularExpressions.RegexRunner"/> used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.ChecksumRegex_3.RunnerFactory.Runner">
            <summary>Provides the runner that contains the custom logic implementing the specified regular expression.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.ChecksumRegex_3.RunnerFactory.Runner.Scan(System.ReadOnlySpan{System.Char})">
            <summary>Scan the <paramref name="inputSpan"/> starting from base.runtextstart for the next match.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.ChecksumRegex_3.RunnerFactory.Runner.TryFindNextPossibleStartingPosition(System.ReadOnlySpan{System.Char})">
            <summary>Search <paramref name="inputSpan"/> starting from base.runtextpos for the next location a match could possibly start.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if a possible match was found; false if no more matches are possible.</returns>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.ChecksumRegex_3.RunnerFactory.Runner.TryMatchAtCurrentPosition(System.ReadOnlySpan{System.Char})">
            <summary>Determine whether <paramref name="inputSpan"/> at base.runtextpos is a match for the regular expression.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if the regular expression matches at the current position; otherwise, false.</returns>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.Utilities">
            <summary>Helper methods used by generated <see cref="T:System.Text.RegularExpressions.Regex"/>-derived implementations.</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.Utilities.s_defaultTimeout">
            <summary>Default timeout value set in <see cref="T:System.AppContext"/>, or <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout"/> if none was set.</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.Utilities.s_hasTimeout">
            <summary>Whether <see cref="F:System.Text.RegularExpressions.Generated.Utilities.s_defaultTimeout"/> is non-infinite.</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.Utilities.s_asciiHexDigits">
            <summary>Supports searching for characters in or not in "0123456789ABCDEFabcdef".</summary>
        </member>
    </members>
</doc>
