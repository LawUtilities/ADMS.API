using System.Collections.Immutable;
using System.ComponentModel.DataAnnotations;
using System.Diagnostics.CodeAnalysis;

namespace ADMS.Application.DTOs;

/// <summary>
/// Comprehensive Document Data Transfer Object representing complete document information with enhanced validation, audit trails, and professional document management capabilities.
/// </summary>
/// <remarks>
/// This DTO serves as the complete representation of documents within the ADMS legal document management system,
/// implementing multiple marker interfaces for type-safe operations and consistent behavior patterns.
/// 
/// <para><strong>Implemented Marker Interfaces:</strong></para>
/// <list type="bullet">
/// <item><strong>IAdmsEntity:</strong> Core entity identification and validation patterns</item>
/// <item><strong>ISoftDeletable:</strong> Soft deletion with audit trail preservation</item>
/// <item><strong>IVersionControlled:</strong> Check-in/check-out version control operations</item>
/// <item><strong>IFileSystemEntity:</strong> File system metadata and operations</item>
/// <item><strong>ISecureEntity:</strong> Security validation and integrity verification</item>
/// <item><strong>IProfessionalEntity:</strong> Professional legal practice standards</item>
/// <item><strong>IAuditable:</strong> Comprehensive audit trail management</item>
/// <item><strong>IDocumentWithCreationDate:</strong> Creation date temporal operations</item>
/// <item><strong>IValidatedDto:</strong> Standardized validation framework</item>
/// </list>
/// </remarks>
public class DocumentDto : BaseValidationDto, IEquatable<DocumentDto>, IComparable<DocumentDto>,
    IAdmsEntity, ISoftDeletable, IVersionControlled, IFileSystemEntity,
    ISecureEntity, IProfessionalEntity, IAuditable, IDocumentWithCreationDate, IValidatedDto
{
    #region Private Fields

    private RevisionDto? _currentRevision;
    private IEnumerable<RevisionDto>? _revisionHistory;
    private DocumentTransferHistory? _transferHistory;
    private DocumentLifecycleAnalysis? _lifecycleAnalysis;
    private IReadOnlyDictionary<string, object>? _comprehensiveStatistics;

    #endregion Private Fields

    #region Core Document Properties

    /// <summary>
    /// Gets the unique identifier for this document within the ADMS legal document management system.
    /// </summary>
    /// <remarks>
    /// This GUID serves as the primary key and unique identifier for the document, ensuring precise identification
    /// across all system operations, audit trails, and business processes. It corresponds directly to 
    /// <see cref="ADMS.API.Entities.Document.Id"/> and forms the foundation for all document-related operations.
    /// 
    /// <para><strong>System Integration:</strong></para>
    /// <list type="bullet">
    /// <item><strong>Primary Key:</strong> Uniquely identifies the document in the database and all system operations</item>
    /// <item><strong>Foreign Key Reference:</strong> Referenced by DocumentActivityUser, RevisionDto, and transfer audit entities</item>
    /// <item><strong>API Operations:</strong> Document identification in REST API endpoints and client applications</item>
    /// <item><strong>Activity Tracking:</strong> Links all activities, revisions, and transfers to this specific document</item>
    /// <item><strong>Security Context:</strong> Document-level security validation and access control</item>
    /// </list>
    /// 
    /// <para><strong>Legal Practice Requirements:</strong></para>
    /// <list type="bullet">
    /// <item><strong>Audit Trail Foundation:</strong> Essential for maintaining complete audit trails required for legal compliance</item>
    /// <item><strong>Document Discovery:</strong> Critical for legal discovery and document production in litigation</item>
    /// <item><strong>Professional Responsibility:</strong> Enables precise document identification for professional accountability</item>
    /// <item><strong>Client Communication:</strong> Facilitates accurate client communication about specific documents</item>
    /// <item><strong>Practice Management:</strong> Supports comprehensive practice management and document tracking</item>
    /// </list>
    /// 
    /// <para><strong>Validation Requirements:</strong></para>
    /// <list type="bullet">
    /// <item><strong>Required Field:</strong> Cannot be null, empty, or Guid.Empty - validated by BaseValidationDto.ValidateGuid()</item>
    /// <item><strong>Uniqueness:</strong> Must be unique across all documents in the system for proper identification</item>
    /// <item><strong>Immutability:</strong> Set via init accessor to prevent modification after document creation</item>
    /// <item><strong>System Generated:</strong> Typically generated by Guid.NewGuid() to ensure uniqueness and security</item>
    /// </list>
    /// 
    /// <para><strong>Interface Compliance:</strong></para>
    /// This property supports multiple interface contracts:
    /// <list type="bullet">
    /// <item><strong>IAdmsEntity:</strong> Core entity identification pattern</item>
    /// <item><strong>IEquatable&lt;DocumentDto&gt;:</strong> Equality comparison based on Id value</item>
    /// <item><strong>IComparable&lt;DocumentDto&gt;:</strong> Ordering operations using Id as tie-breaker</item>
    /// </list>
    /// 
    /// <para><strong>Entity Framework Integration:</strong></para>
    /// <list type="bullet">
    /// <item><strong>Primary Key Mapping:</strong> Maps directly to ADMS.API.Entities.Document.Id</item>
    /// <item><strong>Relationship Foundation:</strong> Basis for all entity relationships and foreign key constraints</item>
    /// <item><strong>Query Performance:</strong> Optimized for indexed queries and relationship navigation</item>
    /// </list>
    /// </remarks>
    /// <example>
    /// <code>
    /// // Creating a new document with system-generated ID
    /// var document = new DocumentDto
    /// {
    ///     Id = Guid.NewGuid(), // System-generated unique identifier
    ///     FileName = "Legal_Contract_v1",
    ///     Extension = ".pdf",
    ///     CreationDate = DateTime.UtcNow
    ///     // ... other required properties
    /// };
    /// 
    /// // Using ID for API operations
    /// var documentUrl = $"/api/documents/{document.Id}";
    /// 
    /// // Document identification in audit trails
    /// var auditEntry = $"Document {document.Id} ({document.DisplayText}) was accessed by user";
    /// 
    /// // Equality comparison using ID
    /// var isSameDocument = document1.Id == document2.Id;
    /// </code>
    /// </example>
    [Required(ErrorMessage = "Document ID is required for document identification and system operations.")]
    public required Guid Id { get; init; }

    /// <summary>
    /// Gets the file name portion of the document without the extension.
    /// </summary>
    /// <remarks>
    /// This property stores the human-readable file name portion that identifies the document content and purpose,
    /// excluding the file extension which is stored separately in the <see cref="Extension"/> property. 
    /// The file name is critical for document identification, search operations, and professional document organization.
    /// 
    /// <para><strong>File System Integration:</strong></para>
    /// <list type="bullet">
    /// <item><strong>File Identification:</strong> Primary human-readable identifier for the document content</item>
    /// <item><strong>Search Operations:</strong> Used in full-text search and document discovery operations</item>
    /// <item><strong>Professional Organization:</strong> Enables professional document naming conventions and standards</item>
    /// <item><strong>Client Communication:</strong> Provides meaningful document names for client interaction</item>
    /// <item><strong>File System Compatibility:</strong> Validated for file system naming constraints and security</item>
    /// </list>
    /// 
    /// <para><strong>Legal Practice Standards:</strong></para>
    /// <list type="bullet">
    /// <item><strong>Professional Naming:</strong> Supports professional legal document naming conventions</item>
    /// <item><strong>Document Classification:</strong> Enables classification and categorization of legal documents</item>
    /// <item><strong>Client Service:</strong> Provides meaningful names for client document communication</item>
    /// <item><strong>Practice Management:</strong> Facilitates effective document organization and retrieval</item>
    /// <item><strong>Legal Discovery:</strong> Essential for legal discovery and document production processes</item>
    /// </list>
    /// 
    /// <para><strong>Validation Rules and Constraints:</strong></para>
    /// <list type="bullet">
    /// <item><strong>Required Field:</strong> Cannot be null, empty, or whitespace - essential for document identification</item>
    /// <item><strong>Length Constraint:</strong> Maximum length defined by FileValidationHelper.MaxFileNameLength for file system compatibility</item>
    /// <item><strong>Character Validation:</strong> Validated by FileValidationHelper.ValidateFileName() for file system safety</item>
    /// <item><strong>Security Validation:</strong> Checked for malicious patterns in ValidateCustomRules() method</item>
    /// <item><strong>Professional Standards:</strong> Must meet professional document naming standards</item>
    /// </list>
    /// 
    /// <para><strong>Security Considerations:</strong></para>
    /// <list type="bullet">
    /// <item><strong>Malicious Content Detection:</strong> Validated against script injection and malicious patterns</item>
    /// <item><strong>File System Safety:</strong> Ensures compatibility with underlying file system constraints</item>
    /// <item><strong>Cross-Platform Compatibility:</strong> Validated for cross-platform file system compatibility</item>
    /// <item><strong>Professional Security:</strong> Meets professional legal practice security requirements</item>
    /// </list>
    /// 
    /// <para><strong>Usage in Interface Implementations:</strong></para>
    /// <list type="bullet">
    /// <item><strong>IAdmsEntity.DisplayText:</strong> Combined with Extension to form complete display text</item>
    /// <item><strong>IFileSystemEntity.FullFileName:</strong> Combined with Extension for complete file name</item>
    /// <item><strong>String Representation:</strong> Used in ToString(), GetProfessionalSummary(), and audit trails</item>
    /// </list>
    /// 
    /// <para><strong>Entity Alignment:</strong></para>
    /// This property mirrors <see cref="ADMS.API.Entities.Document.FileName"/> exactly, ensuring complete 
    /// consistency between entity and DTO representations for reliable file operations and audit trails.
    /// </remarks>
    /// <example>
    /// <code>
    /// // Professional legal document naming
    /// var legalContract = new DocumentDto
    /// {
    ///     FileName = "Smith_Trust_Agreement_v2", // Professional naming convention
    ///     Extension = ".pdf",
    ///     // ... other properties
    /// };
    /// 
    /// // Document display and identification
    /// Console.WriteLine($"Document: {legalContract.FileName}{legalContract.Extension}");
    /// Console.WriteLine($"Display Text: {legalContract.DisplayText}"); // "Smith_Trust_Agreement_v2.pdf"
    /// 
    /// // Search and filtering operations
    /// var contractDocuments = documents
    ///     .Where(d => d.FileName.Contains("Contract", StringComparison.OrdinalIgnoreCase));
    /// 
    /// // Professional audit trail reporting
    /// auditLogger.LogInfo($"Document '{document.FileName}' accessed for legal review");
    /// </code>
    /// </example>
    [Required(ErrorMessage = "File name is required and cannot be empty for document identification.")]
    [MaxLength(FileValidationHelper.MaxFileNameLength,
        ErrorMessage = "File name cannot exceed {1} characters for file system compatibility.")]
    public required string FileName { get; init; } = string.Empty;

    /// <summary>
    /// Gets the file extension that identifies the document format and content type.
    /// </summary>
    /// <remarks>
    /// This property stores the file extension (including the leading dot) that determines the document format,
    /// content type, and handling requirements. The extension is critical for MIME type validation, security
    /// verification, and ensuring proper document handling within the legal document management system.
    /// 
    /// <para><strong>Document Format Identification:</strong></para>
    /// <list type="bullet">
    /// <item><strong>Content Type Classification:</strong> Determines how the document should be processed and displayed</item>
    /// <item><strong>MIME Type Validation:</strong> Used with GetExpectedMimeTypesForExtension() for consistency validation</item>
    /// <item><strong>Security Verification:</strong> Validates against allowed file types for security compliance</item>
    /// <item><strong>Professional Standards:</strong> Ensures documents meet legal practice format requirements</item>
    /// <item><strong>Client Compatibility:</strong> Ensures client systems can properly handle the document format</item>
    /// </list>
    /// 
    /// <para><strong>Supported Legal Document Formats:</strong></para>
    /// <list type="bullet">
    /// <item><strong>.pdf:</strong> Portable Document Format - preferred for legal documents (MIME: application/pdf)</item>
    /// <item><strong>.doc:</strong> Microsoft Word 97-2003 Document (MIME: application/msword)</item>
    /// <item><strong>.docx:</strong> Microsoft Word Document (MIME: application/vnd.openxmlformats-officedocument.wordprocessingml.document)</item>
    /// <item><strong>.txt:</strong> Plain Text Document (MIME: text/plain)</item>
    /// <item><strong>.rtf:</strong> Rich Text Format - for formatted legal documents</item>
    /// </list>
    /// 
    /// <para><strong>Professional Legal Practice Benefits:</strong></para>
    /// <list type="bullet">
    /// <item><strong>Format Standardization:</strong> Ensures consistent document formats across legal practice</item>
    /// <item><strong>Client Compatibility:</strong> Validates formats that clients can reliably access and review</item>
    /// <item><strong>Legal Discovery:</strong> Supports legal discovery requirements with standard, accessible formats</item>
    /// <item><strong>Professional Presentation:</strong> Maintains professional appearance and formatting standards</item>
    /// <item><strong>Long-term Preservation:</strong> Ensures document formats suitable for long-term legal archival</item>
    /// </list>
    /// 
    /// <para><strong>Validation Rules and Security:</strong></para>
    /// <list type="bullet">
    /// <item><strong>Required Field:</strong> Cannot be null, empty, or whitespace - essential for format identification</item>
    /// <item><strong>Length Constraint:</strong> Maximum length defined by FileValidationHelper.MaxExtensionLength</item>
    /// <item><strong>Format Validation:</strong> Validated by FileValidationHelper.ValidateExtension() for proper format</item>
    /// <item><strong>Security Compliance:</strong> Checked against allowed extensions using FileValidationHelper</item>
    /// <item><strong>MIME Type Consistency:</strong> Cross-validated with MimeType property in ValidateBusinessRules()</item>
    /// </list>
    /// 
    /// <para><strong>Business Rule Integration:</strong></para>
    /// <list type="bullet">
    /// <item><strong>Legal Document Classification:</strong> Used by IsLegalDocument() method for format classification</item>
    /// <item><strong>Security Analysis:</strong> Integral part of GetSecurityAnalysis() for comprehensive security evaluation</item>
    /// <item><strong>Professional Standards:</strong> Supports IProfessionalEntity interface for professional practice compliance</item>
    /// <item><strong>File System Operations:</strong> Combined with FileName for complete file identification</item>
    /// </list>
    /// 
    /// <para><strong>MIME Type Relationship:</strong></para>
    /// The extension is cross-validated with the MimeType property to ensure content consistency:
    /// <list type="bullet">
    /// <item><strong>Consistency Validation:</strong> ValidateBusinessRules() ensures extension matches expected MIME types</item>
    /// <item><strong>Security Verification:</strong> Prevents content type spoofing and security vulnerabilities</item>
    /// <item><strong>Professional Reliability:</strong> Ensures document format integrity for legal practice</item>
    /// </list>
    /// 
    /// <para><strong>Interface Implementation Support:</strong></para>
    /// <list type="bullet">
    /// <item><strong>IFileSystemEntity:</strong> Combined with FileName to provide FullFileName property</item>
    /// <item><strong>ISecureEntity:</strong> Used in security validation and format verification</item>
    /// <item><strong>IProfessionalEntity:</strong> Supports professional document format standards</item>
    /// </list>
    /// 
    /// <para><strong>Entity Alignment:</strong></para>
    /// This property mirrors <see cref="ADMS.API.Entities.Document.Extension"/> exactly, ensuring complete 
    /// consistency between entity and DTO representations for reliable file system operations.
    /// </remarks>
    /// <example>
    /// <code>
    /// // Professional legal document extensions
    /// var pdfDocument = new DocumentDto
    /// {
    ///     FileName = "Trust_Agreement",
    ///     Extension = ".pdf", // Preferred legal document format
    ///     MimeType = "application/pdf", // Must match extension
    ///     // ... other properties
    /// };
    /// 
    /// // Document format validation
    /// var isLegalFormat = document.IsLegalDocument(); // Uses Extension property
    /// var expectedMimes = GetExpectedMimeTypesForExtension(document.Extension);
    /// 
    /// // File system operations
    /// var fullFileName = document.FullFileName; // "Trust_Agreement.pdf"
    /// var displayText = document.DisplayText;   // "Trust_Agreement.pdf"
    /// 
    /// // Professional document categorization
    /// var documentCategory = document.Extension.ToLowerInvariant() switch
    /// {
    ///     ".pdf" => "Portable Document (Recommended)",
    ///     ".docx" => "Word Document (Editable)",
    ///     ".txt" => "Plain Text (Notes)",
    ///     _ => "Other Format"
    /// };
    /// </code>
    /// </example>
    [Required(ErrorMessage = "File extension is required and cannot be empty for document format identification.")]
    [MaxLength(FileValidationHelper.MaxExtensionLength,
        ErrorMessage = "File extension cannot exceed {1} characters for system compatibility.")]
    public required string Extension { get; init; } = string.Empty;

    /// <summary>
    /// Gets the size of the document file in bytes.
    /// </summary>
    /// <remarks>
    /// This property stores the exact file size in bytes as determined by the physical file on disk.
    /// File size is critical for storage management, upload validation, client download preparation,
    /// and maintaining accurate document metadata for legal practice management.
    /// 
    /// <para><strong>Storage Management:</strong></para>
    /// <list type="bullet">
    /// <item><strong>Storage Allocation:</strong> Tracks actual storage consumption for capacity planning and billing</item>
    /// <item><strong>Upload Validation:</strong> Enforces file size limits using FileValidationHelper.IsFileSizeValid()</item>
    /// <item><strong>Performance Optimization:</strong> Enables size-based performance optimizations and handling strategies</item>
    /// <item><strong>Bandwidth Management:</strong> Supports bandwidth estimation and download time calculations</item>
    /// <item><strong>Client Preparation:</strong> Allows clients to prepare appropriate download mechanisms</item>
    /// </list>
    /// 
    /// <para><strong>Legal Practice Benefits:</strong></para>
    /// <list type="bullet">
    /// <item><strong>Document Integrity:</strong> File size consistency validates document integrity and prevents corruption</item>
    /// <item><strong>Professional Reporting:</strong> Formatted file size display for professional client communication</item>
    /// <item><strong>Practice Analytics:</strong> Document size analytics for practice management and efficiency analysis</item>
    /// <item><strong>Client Service:</strong> Accurate file size information for client download planning</item>
    /// <item><strong>Storage Compliance:</strong> Supports compliance with document retention and storage policies</item>
    /// </list>
    /// 
    /// <para><strong>Validation and Constraints:</strong></para>
    /// <list type="bullet">
    /// <item><strong>Non-Negative Requirement:</strong> Must be >= 0 to ensure logical consistency and prevent data errors</item>
    /// <item><strong>Size Limits:</strong> Validated against FileValidationHelper.MinFileSizeBytes and MaxFileSizeBytes</item>
    /// <item><strong>Integrity Verification:</strong> Used in conjunction with checksum for content integrity verification</item>
    /// <item><strong>Professional Limits:</strong> Enforces reasonable file size limits for legal document management</item>
    /// <item><strong>System Performance:</strong> Prevents excessively large files that could impact system performance</item>
    /// </list>
    /// 
    /// <para><strong>Formatted Display Integration:</strong></para>
    /// <list type="bullet">
    /// <item><strong>IFileSystemEntity.FormattedFileSize:</strong> Provides human-readable size display (e.g., "2.5 MB")</item>
    /// <item><strong>Professional Reporting:</strong> Used in GetProfessionalSummary() and GetDetailedDescription()</item>
    /// <item><strong>Client Communication:</strong> Formatted for professional client communication and reports</item>
    /// <item><strong>UI Display:</strong> Optimized for user interface display with appropriate formatting</item>
    /// </list>
    /// 
    /// <para><strong>Performance Considerations:</strong></para>
    /// <list type="bullet">
    /// <item><strong>Storage Optimization:</strong> Enables storage optimization strategies based on document size</item>
    /// <item><strong>Transfer Optimization:</strong> Supports optimized transfer mechanisms for large documents</item>
    /// <item><strong>Caching Strategies:</strong> Informs caching strategies based on document size characteristics</item>
    /// <item><strong>Resource Planning:</strong> Enables accurate resource planning for document operations</item>
    /// </list>
    /// 
    /// <para><strong>Security and Integrity:</strong></para>
    /// <list type="bullet">
    /// <item><strong>Content Verification:</strong> Used with checksum for comprehensive content integrity verification</item>
    /// <item><strong>Upload Security:</strong> Prevents malicious uploads through size constraint enforcement</item>
    /// <item><strong>System Protection:</strong> Protects system resources from denial-of-service through size constraints</item>
    /// </list>
    /// 
    /// <para><strong>Entity Alignment:</strong></para>
    /// This property mirrors <see cref="ADMS.API.Entities.Document.FileSize"/> exactly, ensuring complete 
    /// consistency between entity and DTO representations for accurate storage tracking and reporting.
    /// </remarks>
    /// <example>
    /// <code>
    /// // Document with file size information
    /// var document = new DocumentDto
    /// {
    ///     FileName = "Corporate_Bylaws",
    ///     Extension = ".pdf",
    ///     FileSize = 1847523L, // 1.76 MB in bytes
    ///     // ... other properties
    /// };
    /// 
    /// // Professional file size display
    /// Console.WriteLine($"Document size: {document.FormattedFileSize}"); // "1.76 MB"
    /// 
    /// // File size validation
    /// if (FileValidationHelper.IsFileSizeValid(document.FileSize))
    /// {
    ///     ProcessDocumentUpload(document);
    /// }
    /// 
    /// // Professional reporting with size information
    /// var summary = document.GetProfessionalSummary(); // Includes formatted file size
    /// 
    /// // Client communication about document size
    /// var clientMessage = $"Document '{document.FileName}' ({document.FormattedFileSize}) is ready for download";
    /// 
    /// // Storage analytics
    /// var totalStorage = documents.Sum(d => d.FileSize);
    /// var averageSize = documents.Average(d => d.FileSize);
    /// </code>
    /// </example>
    [Range(0, long.MaxValue, ErrorMessage = "File size must be non-negative for accurate storage tracking.")]
    public long FileSize { get; init; }

    /// <summary>
    /// Gets the MIME type that identifies the document's content format and handling requirements.
    /// </summary>
    /// <remarks>
    /// This property stores the standard MIME type (Multipurpose Internet Mail Extensions type) that precisely 
    /// identifies the document's content format, encoding, and handling requirements. MIME type validation is 
    /// essential for security, content consistency, and proper document processing within the legal document 
    /// management system.
    /// 
    /// <para><strong>Content Type Identification:</strong></para>
    /// <list type="bullet">
    /// <item><strong>Format Specification:</strong> Precisely identifies the document content format for proper processing</item>
    /// <item><strong>Handler Selection:</strong> Enables selection of appropriate content handlers and processing engines</item>
    /// <item><strong>Security Classification:</strong> Critical for security validation and malicious content detection</item>
    /// <item><strong>Professional Standards:</strong> Ensures compliance with professional document format standards</item>
    /// <item><strong>Cross-Platform Compatibility:</strong> Enables consistent document handling across different platforms</item>
    /// </list>
    /// 
    /// <para><strong>Standard Legal Document MIME Types:</strong></para>
    /// <list type="bullet">
    /// <item><strong>application/pdf:</strong> Portable Document Format - primary legal document format</item>
    /// <item><strong>application/msword:</strong> Microsoft Word 97-2003 Document format</item>
    /// <item><strong>application/vnd.openxmlformats-officedocument.wordprocessingml.document:</strong> Microsoft Word (.docx) format</item>
    /// <item><strong>text/plain:</strong> Plain text documents for notes and simple legal text</item>
    /// <item><strong>application/rtf:</strong> Rich Text Format for formatted legal documents</item>
    /// </list>
    /// 
    /// <para><strong>Security and Validation Framework:</strong></para>
    /// <list type="bullet">
    /// <item><strong>Format Validation:</strong> Validated against allowed MIME types using FileValidationHelper.IsMimeTypeAllowed()</item>
    /// <item><strong>Consistency Verification:</strong> Cross-validated with Extension property in ValidateBusinessRules()</item>
    /// <item><strong>Security Compliance:</strong> Prevents content type spoofing and malicious content injection</item>
    /// <item><strong>Pattern Validation:</strong> Enforces standard MIME type format (type/subtype) using regular expressions</item>
    /// <item><strong>Professional Standards:</strong> Ensures MIME types meet professional legal document standards</item>
    /// </list>
    /// 
    /// <para><strong>Legal Practice Compliance:</strong></para>
    /// <list type="bullet">
    /// <item><strong>Document Integrity:</strong> Ensures document format consistency for legal integrity requirements</item>
    /// <item><strong>Client Service:</strong> Enables reliable document delivery and client access</item>
    /// <item><strong>Professional Standards:</strong> Maintains professional document format standards for legal practice</item>
    /// <item><strong>Legal Discovery:</strong> Supports legal discovery with format validation and consistency</item>
    /// <item><strong>Audit Compliance:</strong> Required for ISecureEntity interface compliance and audit trails</item>
    /// </list>
    /// 
    /// <para><strong>Business Rule Integration:</strong></para>
    /// <list type="bullet">
    /// <item><strong>Extension Consistency:</strong> ValidateBusinessRules() ensures MIME type matches file extension</item>
    /// <item><strong>Security Analysis:</strong> Integral component of GetSecurityAnalysis() for comprehensive security evaluation</item>
    /// <item><strong>Professional Classification:</strong> Used in document classification and professional standards validation</item>
    /// <item><strong>Content Handler Selection:</strong> Determines appropriate content processing and display mechanisms</item>
    /// </list>
    /// 
    /// <para><strong>Interface Compliance:</strong></para>
    /// <list type="bullet">
    /// <item><strong>ISecureEntity:</strong> Required for security validation and integrity verification</item>
    /// <item><strong>IProfessionalEntity:</strong> Supports professional document format standards</item>
    /// <item><strong>IValidatedDto:</strong> Subject to comprehensive validation framework requirements</item>
    /// </list>
    /// 
    /// <para><strong>Entity Alignment:</strong></para>
    /// This property mirrors <see cref="ADMS.API.Entities.Document.MimeType"/> exactly, ensuring complete 
    /// consistency between entity and DTO representations for reliable content processing and security validation.
    /// </remarks>
    /// <example>
    /// <code>
    /// // Professional legal document with proper MIME type
    /// var legalDocument = new DocumentDto
    /// {
    ///     FileName = "Partnership_Agreement",
    ///     Extension = ".pdf",
    ///     MimeType = "application/pdf", // Must match extension for validation
    ///     // ... other properties
    /// };
    /// 
    /// // MIME type validation and consistency checking
    /// var expectedMimes = GetExpectedMimeTypesForExtension(document.Extension);
    /// var isConsistent = expectedMimes.Contains(document.MimeType, StringComparer.OrdinalIgnoreCase);
    /// 
    /// // Security analysis using MIME type
    /// var securityAnalysis = document.GetSecurityAnalysis();
    /// Console.WriteLine($"Content type verified: {securityAnalysis.ContentTypeVerified}");
    /// 
    /// // Professional document classification
    /// var isAllowedType = FileValidationHelper.IsMimeTypeAllowed(document.MimeType);
    /// var isLegalFormat = document.IsLegalDocument(); // Uses extension but verified by MIME type
    /// 
    /// // Client communication with MIME type information
    /// var downloadInfo = $"Document: {document.DisplayText} (Type: {document.MimeType})";
    /// </code>
    /// </example>
    [Required(ErrorMessage = "MIME type is required for proper document content identification and handling.")]
    [MaxLength(128, ErrorMessage = "MIME type cannot exceed 128 characters for system compatibility.")]
    [RegularExpression(@"^[\w\.\-]+\/[\w\.\-\+]+$",
        ErrorMessage = "MIME type must follow standard format (type/subtype) for content identification.")]
    public string MimeType { get; init; } = string.Empty;

    /// <summary>
    /// Gets the cryptographic checksum for document content integrity verification and security compliance.
    /// </summary>
    /// <remarks>
    /// This property stores the SHA256 cryptographic hash of the document content, providing essential document 
    /// integrity verification, security compliance, and tamper detection capabilities. The checksum is fundamental 
    /// to the legal document management system's security architecture and professional practice requirements.
    /// 
    /// <para><strong>Document Integrity and Security:</strong></para>
    /// <list type="bullet">
    /// <item><strong>Content Verification:</strong> Cryptographic proof that document content has not been altered or corrupted</item>
    /// <item><strong>Tamper Detection:</strong> Immediate detection of any unauthorized changes to document content</item>
    /// <item><strong>Security Compliance:</strong> Meets legal practice security requirements for document integrity</item>
    /// <item><strong>Professional Standards:</strong> Essential for maintaining professional document management standards</item>
    /// <item><strong>Audit Trail Integrity:</strong> Provides cryptographic evidence for legal and compliance audits</item>
    /// </list>
    /// 
    /// <para><strong>Legal Practice Compliance:</strong></para>
    /// <list type="bullet">
    /// <item><strong>Professional Responsibility:</strong> Ensures lawyers can verify document integrity for client service</item>
    /// <item><strong>Legal Discovery:</strong> Provides cryptographic evidence of document authenticity in legal proceedings</item>
    /// <item><strong>Client Confidence:</strong> Enables verification of document integrity for client peace of mind</item>
    /// <item><strong>Regulatory Compliance:</strong> Meets regulatory requirements for document security and integrity</item>
    /// <item><strong>Professional Ethics:</strong> Supports professional ethical obligations for document security</item>
    /// </list>
    /// 
    /// <para><strong>Cryptographic Standards:</strong></para>
    /// <list type="bullet">
    /// <item><strong>SHA256 Algorithm:</strong> Uses industry-standard SHA256 cryptographic hash algorithm</item>
    /// <item><strong>Hexadecimal Format:</strong> Stored as hexadecimal string representation for database compatibility</item>
    /// <item><strong>Fixed Length:</strong> SHA256 produces consistent 64-character hexadecimal output</item>
    /// <item><strong>Collision Resistance:</strong> Cryptographically secure against hash collision attacks</item>
    /// <item><strong>Industry Standard:</strong> Follows established cryptographic standards for legal document management</item>
    /// </list>
    /// 
    /// <para><strong>Validation and Security Framework:</strong></para>
    /// <list type="bullet">
    /// <item><strong>Required Field:</strong> Cannot be null, empty, or whitespace - essential for security compliance</item>
    /// <item><strong>Format Validation:</strong> Must be valid hexadecimal string using regular expression validation</item>
    /// <item><strong>Length Constraint:</strong> Maximum 128 characters to accommodate various hash formats</item>
    /// <item><strong>Cryptographic Validation:</strong> Validated by FileValidationHelper.IsValidChecksum() for proper format</item>
    /// <item><strong>Content Integrity:</strong> HasValidChecksum property provides quick validation status</item>
    /// </list>
    /// 
    /// <para><strong>Interface Implementation Support:</strong></para>
    /// <list type="bullet">
    /// <item><strong>ISecureEntity:</strong> Core component of security validation through HasValidChecksum property</item>
    /// <item><strong>IValidatedDto:</strong> Subject to comprehensive validation framework for data integrity</item>
    /// <item><strong>ISoftDeletable:</strong> Used in CanBeRestored() to ensure integrity before restoration</item>
    /// <item><strong>IProfessionalEntity:</strong> Essential for professional document management standards</item>
    /// </list>
    /// 
    /// <para><strong>Business Logic Integration:</strong></para>
    /// <list type="bullet">
    /// <item><strong>Security Analysis:</strong> Central component of GetSecurityAnalysis() for comprehensive security evaluation</item>
    /// <item><strong>Document Metrics:</strong> Included in GetDocumentMetrics() for integrity status reporting</item>
    /// <item><strong>Professional Statistics:</strong> Part of GetComprehensiveStatistics() for complete document analysis</item>
    /// <item><strong>Audit Information:</strong> Included in GetAuditInformation() for compliance and audit reporting</item>
    /// </list>
    /// 
    /// <para><strong>Entity Alignment:</strong></para>
    /// This property mirrors <see cref="ADMS.API.Entities.Document.Checksum"/> exactly, ensuring complete 
    /// consistency between entity and DTO representations for reliable security validation and integrity verification.
    /// </remarks>
    /// <example>
    /// <code>
    /// // Document with cryptographic checksum
    /// var secureDocument = new DocumentDto
    /// {
    ///     FileName = "Confidential_Agreement",
    ///     Extension = ".pdf",
    ///     Checksum = "a1b2c3d4e5f67890abcdef1234567890abcdef1234567890abcdef1234567890", // SHA256 hash
    ///     // ... other properties
    /// };
    /// 
    /// // Integrity verification
    /// if (document.HasValidChecksum)
    /// {
    ///     Console.WriteLine("Document integrity verified - safe to process");
    /// }
    /// else
    /// {
    ///     Console.WriteLine("WARNING: Document integrity cannot be verified");
    /// }
    /// 
    /// // Security analysis
    /// var securityAnalysis = document.GetSecurityAnalysis();
    /// Console.WriteLine($"Checksum validation: {securityAnalysis.ChecksumValidation}");
    /// Console.WriteLine($"Integrity status: {securityAnalysis.IntegrityStatus}");
    /// 
    /// // Professional compliance checking
    /// var canRestore = document.CanBeRestored(); // Requires valid checksum
    /// var meetsStandards = securityAnalysis.MeetsProfessionalStandards;
    /// 
    /// // Audit trail reporting
    /// var auditInfo = document.GetAuditInformation();
    /// var checksumInfo = auditInfo["FileMetadata"];
    /// </code>
    /// </example>
    [Required(ErrorMessage = "Checksum is required for document integrity verification and security compliance.")]
    [MaxLength(128, ErrorMessage = "Checksum cannot exceed 128 characters for cryptographic compatibility.")]
    [RegularExpression(@"^[A-Fa-f0-9]+$",
        ErrorMessage = "Checksum must be a hexadecimal string for cryptographic integrity verification.")]
    public string Checksum { get; init; } = string.Empty;

    /// <summary>
    /// Gets a value indicating whether the document is currently checked out for editing in the version control system.
    /// </summary>
    /// <remarks>
    /// This property tracks the check-out status of the document within the ADMS version control system,
    /// implementing professional document custody management that prevents concurrent modifications and
    /// maintains document integrity during editing operations. Check-out status is fundamental to
    /// professional legal document management and collaborative workflow control.
    /// 
    /// <para><strong>Version Control Integration:</strong></para>
    /// <list type="bullet">
    /// <item><strong>Exclusive Access:</strong> Prevents multiple users from simultaneously editing the same document</item>
    /// <item><strong>Content Protection:</strong> Protects document content from concurrent modification conflicts</item>
    /// <item><strong>Professional Workflow:</strong> Implements professional version control workflow patterns</item>
    /// <item><strong>Audit Trail Foundation:</strong> Check-out operations are tracked via DocumentActivityUsers for accountability</item>
    /// <item><strong>Legal Compliance:</strong> Supports legal requirements for document custody and modification tracking</item>
    /// </list>
    /// 
    /// <para><strong>Professional Legal Practice Benefits:</strong></para>
    /// <list type="bullet">
    /// <item><strong>Document Custody:</strong> Clear document custody tracking for professional responsibility</item>
    /// <item><strong>Collaborative Control:</strong> Prevents conflicts in multi-attorney document collaboration</item>
    /// <item><strong>Professional Accountability:</strong> Clear attribution of document editing responsibility</item>
    /// <item><strong>Client Service:</strong> Ensures clients receive properly managed and controlled documents</item>
    /// <item><strong>Quality Control:</strong> Prevents accidental overwrites and maintains document quality</item>
    /// </list>
    /// 
    /// <para><strong>Business Rule Integration:</strong></para>
    /// <list type="bullet">
    /// <item><strong>Deletion Prevention:</strong> Checked-out documents cannot be deleted (validated in ValidateBusinessRules())</item>
    /// <item><strong>Concurrent Edit Prevention:</strong> Only one user can check out a document at a time</item>
    /// <item><strong>Professional Status:</strong> Contributes to Status property calculation for professional display</item>
    /// <item><strong>Edit Availability:</strong> Used in IsAvailableForEdit property for version control operations</item>
    /// </list>
    /// 
    /// <para><strong>Interface Implementation Support:</strong></para>
    /// <list type="bullet">
    /// <item><strong>IVersionControlled:</strong> Core component of version control interface implementation</item>
    /// <item><strong>IProfessionalEntity:</strong> Essential for professional Status property calculation</item>
    /// <item><strong>ISoftDeletable:</strong> Used in CanBeDeleted() to prevent deletion of checked-out documents</item>
    /// <item><strong>IAuditable:</strong> Check-out status changes are tracked through audit trail system</item>
    /// </list>
    /// 
    /// <para><strong>Version Control Operations:</strong></para>
    /// <list type="bullet">
    /// <item><strong>CanBeCheckedOut():</strong> Returns true only if document is not currently checked out and not deleted</item>
    /// <item><strong>CanBeCheckedIn():</strong> Returns true only if document is currently checked out and not deleted</item>
    /// <item><strong>IsAvailableForEdit:</strong> Computed property indicating edit availability based on check-out status</item>
    /// <item><strong>Activity Tracking:</strong> Check-out/check-in operations tracked via "CHECKED_OUT"/"CHECKED_IN" activities</item>
    /// </list>
    /// 
    /// <para><strong>Workflow State Management:</strong></para>
    /// <list type="bullet">
    /// <item><strong>Available State:</strong> IsCheckedOut = false, document available for check-out and editing</item>
    /// <item><strong>Checked Out State:</strong> IsCheckedOut = true, document exclusively reserved for editing</item>
    /// <item><strong>Status Display:</strong> Integrated into Status property for professional status reporting</item>
    /// <item><strong>Validation Rules:</strong> Cannot be both checked out and deleted simultaneously</item>
    /// </list>
    /// 
    /// <para><strong>Entity Alignment:</strong></para>
    /// This property mirrors <see cref="ADMS.API.Entities.Document.IsCheckedOut"/> exactly, ensuring complete 
    /// consistency between entity and DTO representations for reliable version control operations.
    /// </remarks>
    /// <example>
    /// <code>
    /// // Document version control operations
    /// var document = new DocumentDto
    /// {
    ///     FileName = "Client_Contract",
    ///     Extension = ".pdf",
    ///     IsCheckedOut = false, // Available for editing
    ///     IsDeleted = false,
    ///     // ... other properties
    /// };
    /// 
    /// // Version control status checking
    /// if (document.CanBeCheckedOut())
    /// {
    ///     Console.WriteLine("Document is available for check-out and editing");
    /// }
    /// 
    /// // Professional status display
    /// Console.WriteLine($"Document status: {document.Status}"); // "Available" or "Checked Out"
    /// 
    /// // Edit availability validation
    /// if (document.IsAvailableForEdit)
    /// {
    ///     // Allow editing operations
    ///     ProcessDocumentEdit(document);
    /// }
    /// 
    /// // Professional workflow management
    /// var workflowStatus = document.IsCheckedOut switch
    /// {
    ///     true => "Document is currently being edited by another user",
    ///     false when !document.IsDeleted => "Document is available for editing",
    ///     false when document.IsDeleted => "Document is deleted and unavailable",
    ///     _ => "Unknown status"
    /// };
    /// 
    /// // Check-out operation validation
    /// if (document.CanBeCheckedOut())
    /// {
    ///     // Perform check-out operation and track activity
    ///     PerformCheckOutOperation(document.Id, currentUserId);
    /// }
    /// </code>
    /// </example>
    public bool IsCheckedOut { get; init; }

    /// <summary>
    /// Gets a value indicating whether the document has been soft-deleted from the system.
    /// </summary>
    /// <remarks>
    /// This property implements soft deletion functionality, allowing documents to be marked as deleted while
    /// preserving all historical data, audit trails, and relationships for legal compliance and professional
    /// accountability. Soft deletion is essential for legal document management where complete audit trail
    /// preservation is required for regulatory compliance and professional responsibility.
    /// 
    /// <para><strong>Soft Deletion Architecture:</strong></para>
    /// <list type="bullet">
    /// <item><strong>Data Preservation:</strong> Document and all associated data remain in the database for audit compliance</item>
    /// <item><strong>Audit Trail Integrity:</strong> Complete audit trail is preserved including deletion and restoration activities</item>
    /// <item><strong>Legal Compliance:</strong> Meets legal requirements for document retention and evidence preservation</item>
    /// <item><strong>Professional Standards:</strong> Maintains professional practice standards for document lifecycle management</item>
    /// <item><strong>Recovery Capability:</strong> Enables document restoration through CanBeRestored() and professional recovery workflows</item>
    /// </list>
    /// 
    /// <para><strong>Legal Practice Requirements:</strong></para>
    /// <list type="bullet">
    /// <item><strong>Document Retention:</strong> Supports legal document retention policies and compliance requirements</item>
    /// <item><strong>Evidence Preservation:</strong> Maintains documents as potential evidence even after deletion</item>
    /// <item><strong>Professional Accountability:</strong> Preserves complete record of document lifecycle for professional review</item>
    /// <item><strong>Client Protection:</strong> Protects client interests by maintaining retrievable document history</item>
    /// <item><strong>Regulatory Compliance:</strong> Meets regulatory requirements for audit trail and document preservation</item>
    /// </list>
    /// 
    /// <para><strong>Business Rule Integration:</strong></para>
    /// <list type="bullet">
    /// <item><strong>Version Control Constraints:</strong> Deleted documents cannot be checked out (validated in ValidateBusinessRules())</item>
    /// <item><strong>Edit Prevention:</strong> Deleted documents are not available for editing (IsAvailableForEdit = false)</item>
    /// <item><strong>Status Calculation:</strong> Primary component of Status property for professional display</item>
    /// <item><strong>Operation Validation:</strong> Affects availability for various document operations</item>
    /// </list>
    /// 
    /// <para><strong>Interface Implementation Support:</strong></para>
    /// <list type="bullet">
    /// <item><strong>ISoftDeletable:</strong> Core implementation of soft deletion interface with CanBeDeleted()/CanBeRestored()</item>
    /// <item><strong>IProfessionalEntity:</strong> Essential for professional Status property and document lifecycle management</item>
    /// <item><strong>IVersionControlled:</strong> Integrates with version control to prevent operations on deleted documents</item>
    /// <item><strong>IAuditable:</strong> Deletion and restoration activities tracked through comprehensive audit system</item>
    /// </list>
    /// 
    /// <para><strong>Deletion and Restoration Workflow:</strong></para>
    /// <list type="bullet">
    /// <item><strong>CanBeDeleted():</strong> Returns true if document is not already deleted and not currently checked out</item>
    /// <item><strong>CanBeRestored():</strong> Returns true if document is deleted, has valid checksum, and passes validation</item>
    /// <item><strong>Activity Tracking:</strong> Deletion tracked via "DELETED" activity, restoration via "RESTORED" activity</item>
    /// <item><strong>Professional Validation:</strong> Restoration requires valid checksum and overall document validity</item>
    /// </list>
    /// 
    /// <para><strong>Status and Display Integration:</strong></para>
    /// <list type="bullet">
    /// <item><strong>Status Property:</strong> Returns "Deleted" when IsDeleted = true, overriding check-out status</item>
    /// <item><strong>Professional Display:</strong> Integrated into professional summary and detailed description methods</item>
    /// <item><strong>Client Communication:</strong> Enables appropriate client communication about document availability</item>
    /// <item><strong>UI Behavior:</strong> Controls user interface behavior and available operations</item>
    /// </list>
    /// 
    /// <para><strong>Entity Alignment:</strong></para>
    /// This property mirrors <see cref="ADMS.API.Entities.Document.IsDeleted"/> exactly, ensuring complete 
    /// consistency between entity and DTO representations for reliable soft deletion operations.
    /// </remarks>
    /// <example>
    /// <code>
    /// // Document soft deletion workflow
    /// var document = new DocumentDto
    /// {
    ///     FileName = "Outdated_Contract",
    ///     Extension = ".pdf",
    ///     IsDeleted = false, // Active document
    ///     IsCheckedOut = false,
    ///     // ... other properties
    /// };
    /// 
    /// // Professional deletion validation
    /// if (document.CanBeDeleted())
    /// {
    ///     Console.WriteLine("Document can be safely deleted with audit trail preservation");
    ///     // Perform soft deletion - sets IsDeleted = true, preserves all data
    /// }
    /// 
    /// // Status-based professional operations
    /// var operationsAvailable = document.Status switch
    /// {
    ///     "Deleted" => new[] { "Restore", "View Audit Trail" },
    ///     "Available" => new[] { "Edit", "Delete", "Check Out", "View" },
    ///     "Checked Out" => new[] { "Check In", "View" },
    ///     _ => new[] { "View" }
    /// };
    /// 
    /// // Professional restoration workflow
    /// if (document.IsDeleted && document.CanBeRestored())
    /// {
    ///     Console.WriteLine("Document can be professionally restored with integrity validation");
    ///     // Perform restoration - sets IsDeleted = false, validates integrity
    /// }
    /// 
    /// // Client communication based on deletion status
    /// var clientMessage = document.IsDeleted 
    ///     ? "This document has been archived but can be restored if needed"
    ///     : "Document is active and available for your review";
    /// 
    /// // Professional audit trail analysis
    /// var lifecycle = document.GetDocumentLifecycleAnalysis();
    /// Console.WriteLine($"Deletion count: {lifecycle.DeleteCount}");
    /// Console.WriteLine($"Restore count: {lifecycle.RestoreCount}");
    /// </code>
    /// </example>
    public bool IsDeleted { get; init; }

    /// <summary>
    /// Gets the UTC date and time when the document was initially created in the system.
    /// </summary>
    /// <remarks>
    /// This property stores the precise moment when the document was first created within the ADMS legal 
    /// document management system. The creation date is fundamental for temporal tracking, audit trails, 
    /// legal chronology, and professional document lifecycle management. It serves as the immutable temporal 
    /// foundation for all subsequent document operations and analysis.
    /// 
    /// <para><strong>Temporal Foundation and Legal Significance:</strong></para>
    /// <list type="bullet">
    /// <item><strong>Legal Chronology:</strong> Establishes the temporal foundation for legal document timelines and case chronology</item>
    /// <item><strong>Audit Trail Anchor:</strong> Serves as the temporal anchor for all subsequent document activities and revisions</item>
    /// <item><strong>Professional Accountability:</strong> Provides precise creation timestamp for professional responsibility tracking</item>
    /// <item><strong>Legal Discovery:</strong> Critical timestamp for legal discovery, evidence production, and timeline reconstruction</item>
    /// <item><strong>Document Lifecycle:</strong> Foundation for comprehensive document lifecycle analysis and professional reporting</item>
    /// </list>
    /// 
    /// <para><strong>Professional Document Management:</strong></para>
    /// <list type="bullet">
    /// <item><strong>Document Age Calculation:</strong> Enables DocumentAge computation for professional lifecycle analysis</item>
    /// <item><strong>Retention Policy Support:</strong> Foundation for document retention policy implementation and compliance</item>
    /// <item><strong>Professional Reporting:</strong> Essential for professional practice reporting and document analytics</item>
    /// <item><strong>Client Communication:</strong> Provides creation context for client document communication</item>
    /// <item><strong>Practice Analytics:</strong> Enables practice management analytics and workflow optimization</item>
    /// </list>
    /// 
    /// <para><strong>UTC Storage and Consistency:</strong></para>
    /// <list type="bullet">
    /// <item><strong>Timezone Independence:</strong> Stored in UTC to ensure consistent temporal operations across timezones</item>
    /// <item><strong>Global Consistency:</strong> Enables consistent temporal operations for distributed legal practice</item>
    /// <item><strong>Audit Compliance:</strong> Meets audit requirements for precise temporal tracking</item>
    /// <item><strong>International Practice:</strong> Supports international legal practice with consistent time representation</item>
    /// <item><strong>System Integration:</strong> Enables integration with external systems requiring precise timestamps</item>
    /// </list>
    /// 
    /// <para><strong>Validation and Immutability:</strong></para>
    /// <list type="bullet">
    /// <item><strong>Required Field:</strong> Cannot be null or default value - validated by ValidateRequiredDate()</item>
    /// <item><strong>Immutable Value:</strong> Set via init accessor to prevent modification after document creation</item>
    /// <item><strong>Temporal Validation:</strong> Validated for reasonable bounds and professional consistency</item>
    /// <item><strong>Revision Consistency:</strong> All revision dates must be >= CreationDate (validated in ValidateCrossPropertyRules())</item>
    /// <item><strong>Professional Standards:</strong> Must meet professional temporal tracking requirements</item>
    /// </list>
    /// 
    /// <para><strong>Interface Implementation Support:</strong></para>
    /// <list type="bullet">
    /// <item><strong>IDocumentWithCreationDate:</strong> Core implementation providing DocumentAge calculation</item>
    /// <item><strong>IAuditable:</strong> Foundation for comprehensive audit trail temporal consistency</item>
    /// <item><strong>IProfessionalEntity:</strong> Essential for professional document lifecycle tracking</item>
    /// <item><strong>IComparable&lt;DocumentDto&gt;:</strong> Secondary sort criteria for document ordering operations</item>
    /// </list>
    /// 
    /// <para><strong>Business Logic Integration:</strong></para>
    /// <list type="bullet">
    /// <item><strong>Document Age Calculation:</strong> DocumentAge property computed as DateTime.UtcNow - CreationDate</item>
    /// <item><strong>Lifecycle Analysis:</strong> Central component of GetDocumentLifecycleAnalysis() for professional analysis</item>
    /// <item><strong>Professional Reporting:</strong> Included in GetDetailedDescription() and audit information</item>
    /// <item><strong>Temporal Analytics:</strong> Enables document age analytics and retention policy implementation</item>
    /// </list>
    /// 
    /// <para><strong>Entity Alignment:</strong></para>
    /// This property mirrors <see cref="ADMS.API.Entities.Document.CreationDate"/> exactly, ensuring complete 
    /// consistency between entity and DTO representations for reliable temporal operations and audit trails.
    /// </remarks>
    /// <example>
    /// <code>
    /// // Document creation with proper timestamp
    /// var newDocument = new DocumentDto
    /// {
    ///     FileName = "Estate_Planning_Will",
    ///     Extension = ".pdf",
    ///     CreationDate = DateTime.UtcNow, // Precise UTC creation timestamp
    ///     // ... other properties
    /// };
    /// 
    /// // Professional document age analysis
    /// var documentAge = document.DocumentAge;
    /// Console.WriteLine($"Document age: {documentAge.TotalDays:F1} days");
    /// 
    /// // Legal chronology and timeline operations
    /// var isRecentDocument = document.CreationDate > DateTime.UtcNow.AddDays(-30);
    /// var creationYear = document.CreationDate.Year;
    /// var ageInYears = (DateTime.UtcNow - document.CreationDate).TotalDays / 365.25;
    /// 
    /// // Professional reporting with creation context
    /// var description = document.GetDetailedDescription();
    /// // Includes: "created on 2024-01-15" formatted for professional display
    /// 
    /// // Document lifecycle analysis
    /// var lifecycle = document.GetDocumentLifecycleAnalysis();
    /// Console.WriteLine($"Document created: {lifecycle.CreationDate:yyyy-MM-dd HH:mm:ss UTC}");
    /// Console.WriteLine($"Document age: {lifecycle.DocumentAge.TotalDays:F0} days");
    /// 
    /// // Retention policy implementation
    /// var retentionDeadline = document.CreationDate.AddYears(7); // 7-year retention
    /// var requiresArchival = DateTime.UtcNow > retentionDeadline;
    /// 
    /// // Professional audit trail temporal validation
    /// var hasValidTimeline = document.Revisions?.All(r => r.CreationDate >= document.CreationDate) ?? true;
    /// </code>
    /// </example>
    [Required(ErrorMessage = "Creation date is required for temporal tracking and audit compliance.")]
    public required DateTime CreationDate { get; init; }

    #endregion Core Document Properties

    #region Navigation Properties

    /// <summary>
    /// Gets the collection of document revisions representing the complete version history for this document.
    /// </summary>
    /// <remarks>
    /// This collection provides comprehensive version control functionality by maintaining all revisions 
    /// of the document in chronological order. Each revision represents a specific version with sequential 
    /// numbering, enabling professional document version management for legal practice compliance.
    /// 
    /// <para><strong>Version Control Features:</strong></para>
    /// <list type="bullet">
    /// <item><strong>Sequential Versioning:</strong> Revisions numbered sequentially starting from 1</item>
    /// <item><strong>Chronological Ordering:</strong> Maintains creation date consistency for audit trails</item>
    /// <item><strong>Complete History:</strong> Preserves all document versions for legal compliance</item>
    /// <item><strong>Professional Management:</strong> Supports legal practice version control standards</item>
    /// </list>
    /// 
    /// <para><strong>Computed Property Support:</strong></para>
    /// <list type="bullet">
    /// <item><strong>CurrentRevision:</strong> Returns the highest numbered revision</item>
    /// <item><strong>RevisionCount:</strong> Total number of revisions for tracking</item>
    /// <item><strong>RevisionHistory:</strong> Chronologically ordered revision sequence</item>
    /// </list>
    /// 
    /// <para><strong>Legal Practice Benefits:</strong></para>
    /// <list type="bullet">
    /// <item><strong>Document Evolution Tracking:</strong> Complete change history for legal chronology</item>
    /// <item><strong>Professional Accountability:</strong> Version-specific user attribution</item>
    /// <item><strong>Legal Discovery Support:</strong> Comprehensive version history for evidence</item>
    /// <item><strong>Compliance Requirements:</strong> Meets legal practice version control standards</item>
    /// </list>
    /// </remarks>
    /// <example>
    /// <code>
    /// // Professional version control analysis
    /// var currentVersion = document.CurrentRevision;
    /// var versionCount = document.RevisionCount;
    /// var revisionAnalysis = document.GetRevisionAnalysis();
    /// 
    /// Console.WriteLine($"Document version {currentVersion?.RevisionNumber} of {versionCount}");
    /// Console.WriteLine($"Version control stage: {revisionAnalysis.VersionControlStage}");
    /// </code>
    /// </example>
    public ICollection<RevisionDto> Revisions { get; init; } = [];

    /// <summary>
    /// Gets the collection of document activity user associations representing the complete audit trail.
    /// </summary>
    /// <remarks>
    /// This collection maintains the comprehensive audit trail of all user activities performed on the document,
    /// providing essential accountability, compliance tracking, and professional document management capabilities.
    /// Each entry represents a specific operation (CREATED, SAVED, CHECKED_OUT, etc.) with user attribution.
    /// 
    /// <para><strong>Activity Types Tracked:</strong></para>
    /// <list type="bullet">
    /// <item><strong>CREATED:</strong> Document creation with user attribution</item>
    /// <item><strong>SAVED:</strong> Document save operations and modifications</item>
    /// <item><strong>CHECKED_OUT/CHECKED_IN:</strong> Version control operations</item>
    /// <item><strong>DELETED/RESTORED:</strong> Deletion and restoration operations</item>
    /// </list>
    /// 
    /// <para><strong>Professional Benefits:</strong></para>
    /// <list type="bullet">
    /// <item><strong>Complete Accountability:</strong> User attribution for all operations</item>
    /// <item><strong>Legal Discovery:</strong> Comprehensive activity history for evidence</item>
    /// <item><strong>Audit Compliance:</strong> Meets regulatory audit requirements</item>
    /// <item><strong>Professional Standards:</strong> Supports practice accountability</item>
    /// </list>
    /// 
    /// <para><strong>Business Logic Integration:</strong></para>
    /// <list type="bullet">
    /// <item><strong>GetActivitiesByType():</strong> Filter activities by type</item>
    /// <item><strong>GetMostRecentActivity():</strong> Latest operation information</item>
    /// <item><strong>HasBeenAccessedByUser():</strong> User interaction validation</item>
    /// </list>
    /// </remarks>
    /// <example>
    /// <code>
    /// // Activity analysis
    /// var recentActivity = document.GetMostRecentActivity();
    /// var creationActivities = document.GetActivitiesByType("CREATED");
    /// var totalActivities = document.TotalActivityCount;
    /// 
    /// // Professional audit reporting
    /// foreach (var activity in document.DocumentActivityUsers.OrderBy(a => a.CreatedAt))
    /// {
    ///     Console.WriteLine($"{activity.User?.Name} performed {activity.DocumentActivity?.Activity}");
    /// }
    /// </code>
    /// </example>
    public ICollection<DocumentActivityUserMinimalDto> DocumentActivityUsers { get; init; } = [];

    /// <summary>
    /// Gets the collection of source-side transfer audit entries for documents moved/copied FROM other matters.
    /// </summary>
    /// <remarks>
    /// This collection tracks the source side of document transfer operations, maintaining complete audit trails
    /// for documents moved or copied FROM source matters. Essential for legal compliance and document custody tracking.
    /// 
    /// <para><strong>Transfer Operations:</strong></para>
    /// <list type="bullet">
    /// <item><strong>MOVED:</strong> Document custody transferred from source matter</item>
    /// <item><strong>COPIED:</strong> Document duplicated from source matter</item>
    /// </list>
    /// 
    /// <para><strong>Legal Compliance Features:</strong></para>
    /// <list type="bullet">
    /// <item><strong>Document Provenance:</strong> Complete tracking of document origins</item>
    /// <item><strong>Custody Chain:</strong> Maintains document custody chains</item>
    /// <item><strong>User Attribution:</strong> Complete accountability for transfers</item>
    /// <item><strong>Audit Trail Integrity:</strong> Preserves complete transfer history</item>
    /// </list>
    /// 
    /// <para><strong>Professional Benefits:</strong></para>
    /// <list type="bullet">
    /// <item><strong>Matter Organization:</strong> Supports professional document organization</item>
    /// <item><strong>Client Communication:</strong> Enables client updates about document changes</item>
    /// <item><strong>Quality Control:</strong> Provides transfer oversight capabilities</item>
    /// </list>
    /// </remarks>
    /// <example>
    /// <code>
    /// // Transfer history analysis
    /// var transferHistory = document.GetTransferHistory();
    /// Console.WriteLine($"Transferred from {transferHistory.SourceTransferCount} matters");
    /// 
    /// // Source transfer audit reporting
    /// foreach (var transfer in document.MatterDocumentActivityUsersFrom)
    /// {
    ///     var operation = transfer.MatterDocumentActivity?.Activity ?? "UNKNOWN";
    ///     var source = transfer.Matter?.Description ?? "Unknown";
    ///     Console.WriteLine($"Document {operation.ToLower()} from '{source}'");
    /// }
    /// </code>
    /// </example>
    public ICollection<MatterDocumentActivityUserFromDto> MatterDocumentActivityUsersFrom { get; init; } = [];

    /// <summary>
    /// Gets the collection of destination-side transfer audit entries for documents moved/copied TO other matters.
    /// </summary>
    /// <remarks>
    /// This collection tracks the destination side of document transfer operations, completing the bidirectional
    /// audit system when combined with MatterDocumentActivityUsersFrom. Essential for comprehensive document 
    /// custody tracking and legal compliance requirements.
    /// 
    /// <para><strong>Bidirectional Audit Completion:</strong></para>
    /// <list type="bullet">
    /// <item><strong>Complete Transfer Coverage:</strong> Combined with source tracking provides full audit coverage</item>
    /// <item><strong>Legal Compliance:</strong> Ensures every document movement is fully documented</item>
    /// <item><strong>Professional Accountability:</strong> Complete user attribution for all transfers</item>
    /// <item><strong>Audit Trail Integrity:</strong> Maintains comprehensive transfer audit integrity</item>
    /// </list>
    /// 
    /// <para><strong>Transfer Operations:</strong></para>
    /// <list type="bullet">
    /// <item><strong>MOVED:</strong> Document custody received at destination matter</item>
    /// <item><strong>COPIED:</strong> Document copy received at destination matter</item>
    /// </list>
    /// 
    /// <para><strong>Professional Practice Integration:</strong></para>
    /// <list type="bullet">
    /// <item><strong>Document Location Tracking:</strong> Complete location history for client service</item>
    /// <item><strong>Matter Organization:</strong> Supports professional document organization strategies</item>
    /// <item><strong>Practice Management:</strong> Facilitates workflow optimization and analysis</item>
    /// <item><strong>Quality Assurance:</strong> Enables comprehensive document organization oversight</item>
    /// </list>
    /// 
    /// <para><strong>Business Logic Integration:</strong></para>
    /// <list type="bullet">
    /// <item><strong>GetTransferHistory():</strong> Includes destination data for complete transfer analytics</item>
    /// <item><strong>GetAssociatedUsers():</strong> Includes destination transfer users for comprehensive tracking</item>
    /// <item><strong>Audit Compliance:</strong> Supports comprehensive audit reporting and compliance</item>
    /// </list>
    /// </remarks>
    /// <example>
    /// <code>
    /// // Complete transfer analysis
    /// var transferHistory = document.GetTransferHistory();
    /// Console.WriteLine($"Transferred to {transferHistory.DestinationTransferCount} matters");
    /// Console.WriteLine($"Well distributed: {transferHistory.IsWellDistributed}");
    /// 
    /// // Destination transfer reporting
    /// foreach (var transfer in document.MatterDocumentActivityUsersTo)
    /// {
    ///     var operation = transfer.MatterDocumentActivity?.Activity ?? "UNKNOWN";
    ///     var destination = transfer.Matter?.Description ?? "Unknown";
    ///     Console.WriteLine($"Document {operation.ToLower()} to '{destination}'");
    /// }
    /// 
    /// // Professional assessment
    /// var assessment = transferHistory.GetProfessionalAssessment();
    /// Console.WriteLine($"Transfer assessment: {assessment}");
    /// </code>
    /// </example>
    public ICollection<MatterDocumentActivityUserToDto> MatterDocumentActivityUsersTo { get; init; } = [];

    #endregion Navigation Properties

    #region Interface Implementations

    // IAdmsEntity
    public string DisplayText => $"{FileName}{Extension}";
    public bool IsValid => !HasValidationErrors(ValidateModel(this));

    // IFileSystemEntity  
    public string FullFileName => $"{FileName}{Extension}";
    public string FormattedFileSize => FileValidationHelper.FormatFileSize(FileSize);

    // ISecureEntity
    public bool HasValidChecksum => FileValidationHelper.IsValidChecksum(Checksum);

    // IProfessionalEntity
    public string Status => IsDeleted ? "Deleted" : IsCheckedOut ? "Checked Out" : "Available";

    // IAuditable
    public bool HasActivities => TotalActivityCount > 0;
    public int TotalActivityCount =>
        (DocumentActivityUsers?.Count ?? 0) +
        (MatterDocumentActivityUsersFrom?.Count ?? 0) +
        (MatterDocumentActivityUsersTo?.Count ?? 0);

    // IVersionControlled
    public bool IsAvailableForEdit => !IsDeleted && !IsCheckedOut;

    // IDocumentWithCreationDate
    public TimeSpan DocumentAge => DateTime.UtcNow - CreationDate;

    #endregion Interface Implementations

    #region Computed Properties

    public RevisionDto? CurrentRevision =>
        _currentRevision ??= Revisions?.OrderByDescending(r => r.RevisionNumber).FirstOrDefault();

    public int RevisionCount => Revisions?.Count ?? 0;

    public IEnumerable<RevisionDto> RevisionHistory =>
        _revisionHistory ??= Revisions?.OrderBy(r => r.RevisionNumber) ?? Enumerable.Empty<RevisionDto>();

    public bool HasActivityHistory =>
        HasActivities &&
        GetActivitiesByType("CREATED").Any() &&
        TotalActivityCount >= RevisionCount;

    #endregion Computed Properties

    #region Validation Methods

    protected override IEnumerable<ValidationResult> ValidateCoreProperties()
    {
        // Validate GUID
        foreach (var result in ValidateGuid(Id, nameof(Id)))
            yield return result;

        // Validate file name
        foreach (var result in FileValidationHelper.ValidateFileName(FileName, nameof(FileName)))
            yield return result;

        // Validate extension
        foreach (var result in FileValidationHelper.ValidateExtension(Extension, nameof(Extension)))
            yield return result;

        // Validate creation date
        foreach (var result in ValidateRequiredDate(CreationDate, nameof(CreationDate)))
            yield return result;

        // Validate MIME type
        if (!FileValidationHelper.IsMimeTypeAllowed(MimeType))
        {
            yield return CreateValidationResult(
                $"MIME type '{MimeType}' is not allowed.",
                nameof(MimeType));
        }

        // Validate checksum
        if (!HasValidChecksum)
        {
            yield return CreateValidationResult(
                "Checksum must be a valid SHA256 hash.",
                nameof(Checksum));
        }

        // Validate file size
        if (!FileValidationHelper.IsFileSizeValid(FileSize))
        {
            yield return CreateValidationResult(
                $"File size must be between {FileValidationHelper.MinFileSizeBytes} and {FileValidationHelper.MaxFileSizeBytes} bytes.",
                nameof(FileSize));
        }
    }

    protected override IEnumerable<ValidationResult> ValidateBusinessRules()
    {
        // Version control business rules
        if (IsCheckedOut && IsDeleted)
        {
            yield return CreateValidationResult(
                "Document cannot be both checked out and deleted.",
                nameof(IsCheckedOut), nameof(IsDeleted));
        }

        // MIME type consistency
        var expectedMimeTypes = GetExpectedMimeTypesForExtension(Extension);
        if (expectedMimeTypes.Any() && !expectedMimeTypes.Contains(MimeType, StringComparer.OrdinalIgnoreCase))
        {
            yield return CreateValidationResult(
                $"MIME type '{MimeType}' does not match extension '{Extension}'. Expected: {string.Join(", ", expectedMimeTypes)}",
                nameof(MimeType), nameof(Extension));
        }
    }

    protected override IEnumerable<ValidationResult> ValidateCrossPropertyRules()
    {
        // Validate revision consistency
        if (RevisionCount > 0 && CurrentRevision != null)
        {
            if (CurrentRevision.CreationDate < CreationDate)
            {
                yield return CreateValidationResult(
                    "Current revision creation date cannot be before document creation date.",
                    nameof(Revisions));
            }
        }
    }

    protected override IEnumerable<ValidationResult> ValidateCollections()
    {
        // Validate revisions collection
        if (Revisions?.Any() == true)
        {
            var revisionNumbers = Revisions.Select(r => r.RevisionNumber).ToList();
            if (revisionNumbers.Distinct().Count() != revisionNumbers.Count)
            {
                yield return CreateValidationResult(
                    "Revision numbers must be unique.",
                    nameof(Revisions));
            }
        }

        // Validate document activities
        if (DocumentActivityUsers?.Any() == true)
        {
            foreach (var activity in DocumentActivityUsers.Where(a => a == null))
            {
                yield return CreateValidationResult(
                    "Document activity users collection cannot contain null items.",
                    nameof(DocumentActivityUsers));
                break;
            }
        }
    }

    protected override IEnumerable<ValidationResult> ValidateCustomRules()
    {
        // Interface compliance validation
        foreach (var result in ValidateInterfaceCompliance())
            yield return result;

        // Advanced security validation
        if (!string.IsNullOrWhiteSpace(FileName))
        {
            var securityPatterns = new[] { "<script", "javascript:", "vbscript:", "<object", "<embed", "<iframe" };
            var fileNameLower = FileName.ToLowerInvariant();

            if (securityPatterns.Any(pattern => fileNameLower.Contains(pattern, StringComparison.OrdinalIgnoreCase)))
            {
                yield return CreateValidationResult(
                    "File name contains potentially malicious content patterns.",
                    nameof(FileName));
            }
        }
    }

    private IEnumerable<ValidationResult> ValidateInterfaceCompliance()
    {
        // Validate IFileSystemEntity contract
        if (string.IsNullOrWhiteSpace(FullFileName))
        {
            yield return CreateValidationResult(
                "FullFileName must be properly computed for IFileSystemEntity compliance.",
                nameof(FullFileName));
        }

        // Validate ISecureEntity contract
        if (string.IsNullOrWhiteSpace(Checksum) || string.IsNullOrWhiteSpace(MimeType))
        {
            yield return CreateValidationResult(
                "Security properties (Checksum, MimeType) are required for ISecureEntity compliance.",
                nameof(Checksum), nameof(MimeType));
        }

        // Validate IVersionControlled contract
        if (IsCheckedOut && IsDeleted)
        {
            yield return CreateValidationResult(
                "Document cannot be both checked out and deleted - violates IVersionControlled contract.",
                nameof(IsCheckedOut), nameof(IsDeleted));
        }
    }

    #endregion Validation Methods

    #region Interface Implementation Methods

    // ISoftDeletable
    public bool CanBeDeleted() => !IsDeleted && !IsCheckedOut;
    public bool CanBeRestored() => IsDeleted && HasValidChecksum && IsValid;

    // IVersionControlled
    public bool CanBeCheckedOut() => !IsCheckedOut && !IsDeleted;
    public bool CanBeCheckedIn() => IsCheckedOut && !IsDeleted;

    // IProfessionalEntity
    public object GetComprehensiveStatistics() => GetComprehensiveStatisticsInternal();
    public IReadOnlyDictionary<string, object> GetAuditInformation() => GetAuditInformationInternal();

    #endregion Interface Implementation Methods

    #region Business Logic Methods

    public object GetDocumentMetrics() => new
    {
        FileInfo = new { FileName, Extension, FormattedFileSize, MimeType },
        StatusInfo = new { Status, IsAvailableForEdit, HasValidChecksum },
        ActivityInfo = new { TotalActivityCount, RevisionCount, HasActivityHistory },
        LifecycleInfo = new { DocumentAge.TotalDays, CreationDate }
    };

    public bool IsLegalDocument() => IsLegalDocumentExtension(Extension);

    public DocumentTransferHistory GetTransferHistory()
    {
        if (_transferHistory != null) return _transferHistory;

        var sourceTransfers = MatterDocumentActivityUsersFrom?.ToList() ?? [];
        var destinationTransfers = MatterDocumentActivityUsersTo?.ToList() ?? [];

        var allTransferUsers = sourceTransfers
            .Where(t => t.User != null)
            .Select(t => t.User!.Id)
            .Concat(destinationTransfers
                .Where(t => t.User != null)
                .Select(t => t.User!.Id))
            .Distinct()
            .Count();

        var recentTransfers = sourceTransfers
            .Where(t => t.CreatedAt > DateTime.UtcNow.AddDays(-30))
            .Count() +
            destinationTransfers
            .Where(t => t.CreatedAt > DateTime.UtcNow.AddDays(-30))
            .Count();

        var allTransferDates = sourceTransfers
            .Select(t => t.CreatedAt)
            .Concat(destinationTransfers.Select(t => t.CreatedAt))
            .ToList();

        _transferHistory = new DocumentTransferHistory
        {
            DocumentId = Id,
            DocumentName = DisplayText,
            SourceTransferCount = sourceTransfers.Count,
            DestinationTransferCount = destinationTransfers.Count,
            TotalTransferCount = sourceTransfers.Count + destinationTransfers.Count,
            UniqueTransferUsers = allTransferUsers,
            RecentTransferCount = recentTransfers,
            HasTransferActivity = sourceTransfers.Any() || destinationTransfers.Any(),
            IsFrequentlyTransferred = (sourceTransfers.Count + destinationTransfers.Count) > 5,
            LastTransferDate = allTransferDates.Any() ? allTransferDates.Max() : null,
            TransferBalance = Math.Abs(sourceTransfers.Count - destinationTransfers.Count),
            IsWellDistributed = Math.Abs(sourceTransfers.Count - destinationTransfers.Count) <= 2,
            HasComprehensiveTransferAudit = sourceTransfers.Any() && destinationTransfers.Any(),
            TransferAuditCompliance = sourceTransfers.All(t => t.User != null) &&
                                    destinationTransfers.All(t => t.User != null)
        };

        return _transferHistory;
    }

    public DocumentLifecycleAnalysis GetDocumentLifecycleAnalysis()
    {
        if (_lifecycleAnalysis != null) return _lifecycleAnalysis;

        var creationActivity = GetActivitiesByType("CREATED").FirstOrDefault();
        var saveActivities = GetActivitiesByType("SAVED").ToList();
        var checkOutActivities = GetActivitiesByType("CHECKED_OUT").ToList();
        var checkInActivities = GetActivitiesByType("CHECKED_IN").ToList();
        var deleteActivities = GetActivitiesByType("DELETED").ToList();
        var restoreActivities = GetActivitiesByType("RESTORED").ToList();

        var lifecycleStage = IsDeleted ? "Deleted" :
                           IsCheckedOut ? "Under Revision" :
                           RevisionCount > 1 ? "Mature" :
                           RevisionCount == 1 ? "Initial Version" :
                           "Newly Created";

        _lifecycleAnalysis = new DocumentLifecycleAnalysis
        {
            DocumentId = Id,
            DocumentName = DisplayText,
            CreationDate = CreationDate,
            CreatedByUser = creationActivity?.User?.Name ?? "Unknown",
            CurrentStatus = Status,
            LifecycleStage = lifecycleStage,
            ModificationCount = saveActivities.Count,
            CheckOutCount = checkOutActivities.Count,
            CheckInCount = checkInActivities.Count,
            DeleteCount = deleteActivities.Count,
            RestoreCount = restoreActivities.Count,
            UniqueModifyingUsers = saveActivities
                .Where(a => a.User != null)
                .Select(a => a.User!.Id)
                .Distinct()
                .Count(),
            TotalUniqueUsers = GetAssociatedUsers().Count(),
            VersionControlCompliance = checkOutActivities.Count == checkInActivities.Count,
            HasBalancedVersionControl = Math.Abs(checkOutActivities.Count - checkInActivities.Count) <= 1,
            IsActivelyManaged = saveActivities.Any(a => a.CreatedAt > DateTime.UtcNow.AddDays(-30)),
            DocumentAge = DocumentAge,
            LastActivityDate = GetMostRecentActivity()?.CreatedAt,
            HasComprehensiveAuditTrail = HasActivities && creationActivity != null,
            AuditTrailCompliance = HasActivities && !HasValidationErrors(ValidateModel(this))
        };

        return _lifecycleAnalysis;
    }

    public IEnumerable<UserMinimalDto> GetAssociatedUsers()
    {
        var allUsers = new List<UserMinimalDto>();

        if (DocumentActivityUsers?.Any() == true)
        {
            allUsers.AddRange(DocumentActivityUsers
                .Where(a => a.User != null)
                .Select(a => a.User!));
        }

        if (MatterDocumentActivityUsersFrom?.Any() == true)
        {
            allUsers.AddRange(MatterDocumentActivityUsersFrom
                .Where(t => t.User != null)
                .Select(t => new UserMinimalDto
                {
                    Id = t.User!.Id,
                    Name = t.User.Name
                }));
        }

        if (MatterDocumentActivityUsersTo?.Any() == true)
        {
            allUsers.AddRange(MatterDocumentActivityUsersTo
                .Where(t => t.User != null)
                .Select(t => new UserMinimalDto
                {
                    Id = t.User!.Id,
                    Name = t.User.Name
                }));
        }

        return allUsers
            .Where(u => u.Id != Guid.Empty && !string.IsNullOrWhiteSpace(u.Name))
            .DistinctBy(u => u.Id)
            .OrderBy(u => u.Name, StringComparer.OrdinalIgnoreCase);
    }

    public IEnumerable<DocumentActivityUserMinimalDto> GetActivitiesByType([NotNull] string activityType)
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(activityType, nameof(activityType));

        return DocumentActivityUsers?
            .Where(a => string.Equals(a.DocumentActivity?.Activity, activityType, StringComparison.OrdinalIgnoreCase))
            .OrderBy(a => a.CreatedAt) ?? Enumerable.Empty<DocumentActivityUserMinimalDto>();
    }

    public DocumentActivityUserMinimalDto? GetMostRecentActivity()
    {
        return DocumentActivityUsers?
            .OrderByDescending(a => a.CreatedAt)
            .FirstOrDefault();
    }

    public IEnumerable<DocumentActivityUserMinimalDto> GetActivitiesInTimeRange(DateTime startDate, DateTime endDate)
    {
        return DocumentActivityUsers?
            .Where(a => a.CreatedAt >= startDate && a.CreatedAt <= endDate)
            .OrderBy(a => a.CreatedAt) ?? Enumerable.Empty<DocumentActivityUserMinimalDto>();
    }

    public bool HasBeenAccessedByUser(Guid userId)
    {
        if (userId == Guid.Empty) return false;

        var hasDocumentActivity = DocumentActivityUsers?.Any(a => a.User?.Id == userId) == true;
        var hasTransferFromActivity = MatterDocumentActivityUsersFrom?.Any(t => t.User?.Id == userId) == true;
        var hasTransferToActivity = MatterDocumentActivityUsersTo?.Any(t => t.User?.Id == userId) == true;

        return hasDocumentActivity || hasTransferFromActivity || hasTransferToActivity;
    }

    public DocumentRevisionAnalysis GetRevisionAnalysis()
    {
        var revisions = RevisionHistory.ToList();
        var hasSequentialNumbering = !revisions.Where((t, i) => t.RevisionNumber != i + 1).Any();

        var versionControlStage = RevisionCount switch
        {
            0 => "No Versions",
            1 => "Initial Version",
            2 or 3 => "Early Development",
            > 3 and <= 10 => "Active Development",
            > 10 and <= 50 => "Mature Document",
            _ => "Highly Revised"
        };

        var revisionFrequency = revisions.Count > 1 && revisions.Any()
            ? (DateTime.UtcNow - revisions.First().CreationDate).TotalDays / revisions.Count
            : 0;

        return new DocumentRevisionAnalysis
        {
            DocumentId = Id,
            DocumentName = DisplayText,
            TotalRevisions = RevisionCount,
            HasRevisions = RevisionCount > 0,
            HasSequentialNumbering = hasSequentialNumbering,
            VersionControlStage = versionControlStage,
            FirstRevisionDate = revisions.FirstOrDefault()?.CreationDate,
            LastRevisionDate = revisions.LastOrDefault()?.CreationDate,
            RevisionSpan = revisions.Any() && revisions.Count > 1
                ? revisions.Last().CreationDate - revisions.First().CreationDate
                : TimeSpan.Zero,
            AverageRevisionFrequency = revisionFrequency,
            IsVersionControlCompliant = hasSequentialNumbering && RevisionCount > 0,
            IsActivelyVersioned = revisions.Any(r => r.CreationDate > DateTime.UtcNow.AddDays(-30)),
            IsWellMaintained = RevisionCount > 0 && hasSequentialNumbering,
            RevisionDensity = DocumentAge.TotalDays > 0 ? RevisionCount / DocumentAge.TotalDays : 0,
            CurrentRevisionNumber = CurrentRevision?.RevisionNumber ?? 0,
            IsLatestRevisionRecent = CurrentRevision?.CreationDate > DateTime.UtcNow.AddDays(-7)
        };
    }

    public DocumentDto CreateCopy(
        [NotNull] string newFileName,
        bool preserveRevisions = false,
        bool preserveActivities = false)
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(newFileName, nameof(newFileName));

        var copy = new DocumentDto
        {
            Id = Guid.NewGuid(),
            FileName = newFileName.Trim(),
            Extension = Extension,
            FileSize = FileSize,
            MimeType = MimeType,
            Checksum = Checksum,
            IsCheckedOut = false,
            IsDeleted = false,
            CreationDate = DateTime.UtcNow,
            Revisions = preserveRevisions ? Revisions : [],
            DocumentActivityUsers = preserveActivities ? DocumentActivityUsers : [],
            MatterDocumentActivityUsersFrom = preserveActivities ? MatterDocumentActivityUsersFrom : [],
            MatterDocumentActivityUsersTo = preserveActivities ? MatterDocumentActivityUsersTo : []
        };

        var validationResults = ValidateModel(copy);
        if (!HasValidationErrors(validationResults)) return copy;
        var summary = GetValidationSummary(validationResults);
        throw new ValidationException($"Document copy validation failed: {summary}");
    }

    public DocumentSecurityAnalysis GetSecurityAnalysis()
    {
        var isLegalFormat = IsLegalDocumentExtension(Extension);
        var expectedMimeTypes = GetExpectedMimeTypesForExtension(Extension);
        var mimeTypeMatches = expectedMimeTypes.Contains(MimeType, StringComparer.OrdinalIgnoreCase);

        var securityRating = HasValidChecksum switch
        {
            true when mimeTypeMatches && isLegalFormat => "High",
            true when (mimeTypeMatches || isLegalFormat) => "Medium",
            _ => "Low"
        };

        var validationResults = ValidateModel(this);
        var hasSecurityIssues = validationResults.Any(v =>
            v.ErrorMessage?.Contains("security", StringComparison.OrdinalIgnoreCase) == true ||
            v.ErrorMessage?.Contains("malicious", StringComparison.OrdinalIgnoreCase) == true);

        return new DocumentSecurityAnalysis
        {
            DocumentId = Id,
            DocumentName = DisplayText,
            SecurityRating = securityRating,
            IsSafeFileFormat = isLegalFormat,
            IsLegalDocumentFormat = isLegalFormat,
            FileExtension = Extension,
            MimeType = MimeType,
            HasValidChecksum = HasValidChecksum,
            ChecksumValidation = HasValidChecksum ? "Valid" : "Invalid",
            IntegrityStatus = HasValidChecksum ? "Verified" : "Unverified",
            MimeTypeMatches = mimeTypeMatches,
            ExpectedMimeTypes = expectedMimeTypes.ToList(),
            ContentTypeVerified = mimeTypeMatches,
            HasSecurityIssues = hasSecurityIssues,
            SecurityValidationPassed = !hasSecurityIssues && HasValidChecksum && mimeTypeMatches,
            MeetsProfessionalStandards = isLegalFormat && HasValidChecksum && mimeTypeMatches,
            IsAuditCompliant = !HasValidationErrors(validationResults),
            RiskLevel = hasSecurityIssues ? "High" :
                       !HasValidChecksum ? "Medium" :
                       !mimeTypeMatches ? "Medium" :
                       "Low"
        };
    }

    #endregion Business Logic Methods

    #region Static Factory Methods

    public static DocumentDto FromEntityEnhanced(
        [NotNull] Entities.Document entity,
        bool includeRevisions = true,
        bool includeActivityUsers = true,
        bool includeMatterTransfers = true)
    {
        ArgumentNullException.ThrowIfNull(entity, nameof(entity));

        var dto = new DocumentDto
        {
            Id = entity.Id,
            FileName = entity.FileName,
            Extension = entity.Extension,
            FileSize = entity.FileSize,
            MimeType = entity.MimeType,
            Checksum = entity.Checksum,
            IsCheckedOut = entity.IsCheckedOut,
            IsDeleted = entity.IsDeleted,
            CreationDate = entity.CreationDate,
            Revisions = includeRevisions && entity.Revisions?.Any() == true
                ? entity.Revisions.Select(r => RevisionDto.FromEntity(r)).ToList()
                : [],
            DocumentActivityUsers = includeActivityUsers && entity.DocumentActivityUsers?.Any() == true
                ? entity.DocumentActivityUsers.Select(da => DocumentActivityUserMinimalDto.FromEntity(da)).ToList()
                : [],
            MatterDocumentActivityUsersFrom = includeMatterTransfers && entity.MatterDocumentActivityUsersFrom?.Any() == true
                ? entity.MatterDocumentActivityUsersFrom.Select(mda => MatterDocumentActivityUserFromDto.FromEntity(mda)).ToList()
                : [],
            MatterDocumentActivityUsersTo = includeMatterTransfers && entity.MatterDocumentActivityUsersTo?.Any() == true
                ? entity.MatterDocumentActivityUsersTo.Select(mda => MatterDocumentActivityUserToDto.FromEntity(mda)).ToList()
                : []
        };

        var validationResults = ValidateModel(dto);
        if (!HasValidationErrors(validationResults)) return dto;
        var summary = GetValidationSummary(validationResults);
        var entityInfo = $"{entity.FileName}{entity.Extension}";
        throw new ValidationException($"Enhanced DocumentDto creation failed for '{entityInfo}' ({entity.Id}): {summary}");
    }

    #endregion Static Factory Methods

    #region String Representation Methods

    public string GetProfessionalSummary()
    {
        var revisionInfo = RevisionCount > 0 ? $", {RevisionCount} revision{(RevisionCount != 1 ? "s" : "")}" : "";
        var activityInfo = HasActivities ? $", {TotalActivityCount} activit{(TotalActivityCount != 1 ? "ies" : "y")}" : "";

        return $"{DisplayText} ({FormattedFileSize}, {Status}{revisionInfo}{activityInfo})";
    }

    public string GetDetailedDescription()
    {
        var integrityStatus = HasValidChecksum ? "integrity verified" : "integrity unverified";
        var revisionInfo = RevisionCount > 0 ? $"{RevisionCount} revision{(RevisionCount != 1 ? "s" : "")}" : "no revisions";
        var activityInfo = HasActivities ? $"{TotalActivityCount} total activit{(TotalActivityCount != 1 ? "ies" : "y")}" : "no activities";
        var ageInfo = $"{DocumentAge.TotalDays:F0} days old";

        return $"Document '{DisplayText}' (ID: {Id}) created on {CreationDate:yyyy-MM-dd}, " +
               $"size {FormattedFileSize}, {Extension.TrimStart('.')} format, status {Status}, " +
               $"{revisionInfo}, {activityInfo}, {ageInfo}, {integrityStatus}";
    }

    #endregion String Representation Methods

    #region Private Helper Methods

    private IReadOnlyDictionary<string, object> GetComprehensiveStatisticsInternal()
    {
        if (_comprehensiveStatistics != null) return _comprehensiveStatistics;

        var validationResults = ValidateModel(this);
        var validationStatus = HasValidationErrors(validationResults)
            ? GetValidationSummary(validationResults)
            : "Valid";

        _comprehensiveStatistics = new Dictionary<string, object>
        {
            ["DocumentInfo"] = new
            {
                Id,
                FileName,
                Extension,
                FullFileName = DisplayText,
                FileSize = FormattedFileSize,
                FileSizeBytes = FileSize,
                MimeType,
                IsLegalFormat = IsLegalDocumentExtension(Extension)
            },
            ["Status"] = new
            {
                Status,
                IsCheckedOut,
                IsDeleted,
                IsAvailableForEdit,
                CanBeEdited = CanBeCheckedOut(),
                CanBeDeleted = CanBeDeleted(),
                CanBeRestored = CanBeRestored()
            },
            ["Metrics"] = new
            {
                RevisionCount,
                TotalActivityCount,
                HasActivities,
                HasActivityHistory,
                DocumentAgeInDays = DocumentAge.TotalDays
            },
            ["ValidationStatus"] = new
            {
                IsValid,
                ValidationSummary = validationStatus,
                HasValidationErrors = HasValidationErrors(validationResults)
            }
        }.ToImmutableDictionary();

        return _comprehensiveStatistics;
    }

    private IReadOnlyDictionary<string, object> GetAuditInformationInternal()
    {
        var validationResults = ValidateModel(this);
        var isAuditCompliant = !HasValidationErrors(validationResults);

        return new Dictionary<string, object>
        {
            ["DocumentIdentification"] = new
            {
                DocumentId = Id,
                FileName,
                Extension,
                FullFileName = DisplayText,
                CreationDate,
                CreationDateFormatted = CreationDate.ToString("yyyy-MM-dd HH:mm:ss UTC")
            },
            ["FileMetadata"] = new
            {
                FileSize,
                FormattedFileSize,
                MimeType,
                Checksum,
                IsLegalDocumentFormat = IsLegalDocumentExtension(Extension),
                IsLegalDocument = IsLegalDocument()
            },
            ["StatusInformation"] = new
            {
                Status,
                IsCheckedOut,
                IsDeleted,
                IsAvailableForEdit,
                IsAuditCompliant = isAuditCompliant,
                CanBeDeleted = CanBeDeleted(),
                CanBeRestored = CanBeRestored()
            },
            ["AuditTrailSummary"] = new
            {
                TotalActivityCount,
                HasActivities,
                HasActivityHistory,
                RevisionCount,
                HasRevisions = RevisionCount > 0,
                CurrentRevisionNumber = CurrentRevision?.RevisionNumber ?? 0
            }
        }.ToImmutableDictionary();
    }

    private static IReadOnlyList<string> GetExpectedMimeTypesForExtension(string extension)
    {
        return extension.ToLowerInvariant() switch
        {
            ".pdf" => ["application/pdf"],
            ".doc" => ["application/msword"],
            ".docx" => ["application/vnd.openxmlformats-officedocument.wordprocessingml.document"],
            ".xls" => ["application/vnd.ms-excel"],
            ".xlsx" => ["application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"],
            ".ppt" => ["application/vnd.ms-powerpoint"],
            ".pptx" => ["application/vnd.openxmlformats-officedocument.presentationml.presentation"],
            ".txt" => ["text/plain"],
            ".csv" => ["text/csv", "application/csv"],
            ".jpg" or ".jpeg" => ["image/jpeg"],
            ".png" => ["image/png"],
            ".gif" => ["image/gif"],
            ".bmp" => ["image/bmp"],
            ".zip" => ["application/zip"],
            _ => []
        };
    }

    private static bool IsLegalDocumentExtension(string extension)
    {
        var legalExtensions = new[] { ".pdf", ".doc", ".docx", ".txt", ".rtf" };
        return legalExtensions.Contains(extension.ToLowerInvariant());
    }

    #endregion Private Helper Methods

    #region Equality and Comparison

    public virtual bool Equals(DocumentDto? other)
    {
        if (other is null) return false;
        if (ReferenceEquals(this, other)) return true;
        return Id.Equals(other.Id) && Id != Guid.Empty;
    }

    public override bool Equals(object? obj) => Equals(obj as DocumentDto);

    public override int GetHashCode() => Id.GetHashCode();

    public int CompareTo(DocumentDto? other)
    {
        if (other is null) return 1;
        if (ReferenceEquals(this, other)) return 0;

        var displayComparison = string.Compare(DisplayText, other.DisplayText, StringComparison.OrdinalIgnoreCase);
        if (displayComparison != 0) return displayComparison;

        var dateComparison = CreationDate.CompareTo(other.CreationDate);
        return dateComparison != 0 ? dateComparison : Id.CompareTo(other.Id);
    }

    public override string ToString() =>
        $"{DisplayText} ({Id}) [{Status}] - {FormattedFileSize}";

    #endregion Equality and Comparison
}

#region Supporting Data Classes

/// <summary>
/// Represents comprehensive validation analysis results for document collections.
/// </summary>
public class DocumentValidationAnalysis
{
    public required IReadOnlyDictionary<int, IList<ValidationResult>> ValidationResults { get; init; }
    public required int TotalDocuments { get; init; }
    public required int ValidDocuments { get; init; }
    public required int InvalidDocuments { get; init; }
    public required double SuccessRate { get; init; }
    public required string ErrorSummary { get; init; }
    public ImmutableDictionary<string, int> ErrorCategories { get; init; } = ImmutableDictionary<string, int>.Empty;
    public required DateTime ValidationTimestamp { get; init; }

    public string GetProfessionalRecommendations()
    {
        if (SuccessRate >= 0.95)
            return "Excellent data quality. No immediate action required.";

        if (SuccessRate >= 0.80)
            return "Good data quality with minor issues. Review failed documents for common patterns.";

        if (SuccessRate >= 0.60)
            return "Moderate data quality issues detected. Systematic review and remediation recommended.";

        return "Significant data quality issues detected. Immediate review and remediation required before processing.";
    }
}

/// <summary>
/// Represents comprehensive document lifecycle analysis.
/// </summary>
public class DocumentLifecycleAnalysis
{
    public required Guid DocumentId { get; init; }
    public required string DocumentName { get; init; }
    public required DateTime CreationDate { get; init; }
    public required string CreatedByUser { get; init; }
    public required string CurrentStatus { get; init; }
    public required string LifecycleStage { get; init; }
    public required int ModificationCount { get; init; }
    public required int CheckOutCount { get; init; }
    public required int CheckInCount { get; init; }
    public required int DeleteCount { get; init; }
    public required int RestoreCount { get; init; }
    public required int UniqueModifyingUsers { get; init; }
    public required int TotalUniqueUsers { get; init; }
    public required bool VersionControlCompliance { get; init; }
    public required bool HasBalancedVersionControl { get; init; }
    public required bool IsActivelyManaged { get; init; }
    public required TimeSpan DocumentAge { get; init; }
    public DateTime? LastActivityDate { get; init; }
    public required bool HasComprehensiveAuditTrail { get; init; }
    public required bool AuditTrailCompliance { get; init; }

    public string GetProfessionalRecommendations()
    {
        var recommendations = new List<string>();

        if (!IsActivelyManaged && DocumentAge.TotalDays > 365)
            recommendations.Add("Consider archiving - document has been inactive for over a year.");

        if (!VersionControlCompliance)
            recommendations.Add("Review version control practices - check-in/check-out operations are imbalanced.");

        if (!HasComprehensiveAuditTrail)
            recommendations.Add("Audit trail may be incomplete - verify all activities are properly recorded.");

        if (recommendations.Count == 0)
            recommendations.Add("Document lifecycle management meets professional standards.");

        return string.Join(" ", recommendations);
    }
}

/// <summary>
/// Represents comprehensive document transfer history analysis.
/// </summary>
public class DocumentTransferHistory
{
    public required Guid DocumentId { get; init; }
    public required string DocumentName { get; init; }
    public required int SourceTransferCount { get; init; }
    public required int DestinationTransferCount { get; init; }
    public required int TotalTransferCount { get; init; }
    public required int UniqueTransferUsers { get; init; }
    public required int RecentTransferCount { get; init; }
    public required bool HasTransferActivity { get; init; }
    public required bool IsFrequentlyTransferred { get; init; }
    public DateTime? LastTransferDate { get; init; }
    public required int TransferBalance { get; init; }
    public required bool IsWellDistributed { get; init; }
    public required bool HasComprehensiveTransferAudit { get; init; }
    public required bool TransferAuditCompliance { get; init; }

    public string GetProfessionalAssessment()
    {
        if (!HasTransferActivity)
            return "Document has remained in its original matter - stable document placement.";

        if (IsFrequentlyTransferred && !IsWellDistributed)
            return "Document shows frequent transfer activity with imbalanced patterns - review organization strategy.";

        if (HasComprehensiveTransferAudit && TransferAuditCompliance)
            return "Document transfer history shows good audit trail compliance and professional management.";

        if (!TransferAuditCompliance)
            return "Transfer audit trail may be incomplete - verify all transfers are properly documented.";

        return "Document transfer patterns appear normal with adequate audit trail coverage.";
    }
}

/// <summary>
/// Represents comprehensive document revision analysis.
/// </summary>
public class DocumentRevisionAnalysis
{
    public required Guid DocumentId { get; init; }
    public required string DocumentName { get; init; }
    public required int TotalRevisions { get; init; }
    public required bool HasRevisions { get; init; }
    public required bool HasSequentialNumbering { get; init; }
    public required string VersionControlStage { get; init; }
    public DateTime? FirstRevisionDate { get; init; }
    public DateTime? LastRevisionDate { get; init; }
    public required TimeSpan RevisionSpan { get; init; }
    public required double AverageRevisionFrequency { get; init; }
    public required bool IsVersionControlCompliant { get; init; }
    public required bool IsActivelyVersioned { get; init; }
    public required bool IsWellMaintained { get; init; }
    public required double RevisionDensity { get; init; }
    public required int CurrentRevisionNumber { get; init; }
    public bool IsLatestRevisionRecent { get; init; }

    public string GetVersionControlRecommendations()
    {
        var recommendations = new List<string>();

        if (!HasRevisions)
            recommendations.Add("Document lacks revision history - consider implementing version control practices.");

        if (!HasSequentialNumbering)
            recommendations.Add("Revision numbering is not sequential - review version control procedures.");

        if (!IsVersionControlCompliant)
            recommendations.Add("Version control practices need improvement - ensure proper check-in/check-out procedures.");

        if (RevisionDensity > 5)
            recommendations.Add("Very high revision frequency detected - consider consolidating changes before saving.");

        if (!IsActivelyVersioned && TotalRevisions > 0)
            recommendations.Add("Document versioning appears stagnant - verify if document is still in active use.");

        if (recommendations.Count == 0)
            recommendations.Add("Version control practices meet professional standards.");

        return string.Join(" ", recommendations);
    }
}

/// <summary>
/// Represents comprehensive document security analysis.
/// </summary>
public class DocumentSecurityAnalysis
{
    public required Guid DocumentId { get; init; }
    public required string DocumentName { get; init; }
    public required string SecurityRating { get; init; }
    public required bool IsSafeFileFormat { get; init; }
    public required bool IsLegalDocumentFormat { get; init; }
    public required string FileExtension { get; init; }
    public required string MimeType { get; init; }
    public required bool HasValidChecksum { get; init; }
    public required string ChecksumValidation { get; init; }
    public required string IntegrityStatus { get; init; }
    public required bool MimeTypeMatches { get; init; }
    public required List<string> ExpectedMimeTypes { get; init; }
    public required bool ContentTypeVerified { get; init; }
    public required bool HasSecurityIssues { get; init; }
    public required bool SecurityValidationPassed { get; init; }
    public required bool MeetsProfessionalStandards { get; init; }
    public required bool IsAuditCompliant { get; init; }
    public required string RiskLevel { get; init; }

    public string GetSecurityRecommendations()
    {
        var recommendations = new List<string>();

        if (HasSecurityIssues)
            recommendations.Add("Critical: Address identified security issues before processing.");

        if (!HasValidChecksum)
            recommendations.Add("Generate valid SHA256 checksum for content integrity verification.");

        if (!MimeTypeMatches)
            recommendations.Add($"MIME type '{MimeType}' doesn't match extension '{FileExtension}' - verify content type.");

        if (!IsLegalDocumentFormat)
            recommendations.Add("Consider converting to standard legal document format (PDF recommended).");

        if (!MeetsProfessionalStandards)
            recommendations.Add("Document format may not meet professional legal practice standards.");

        if (recommendations.Count == 0)
            recommendations.Add("Document meets professional security standards for legal practice.");

        return string.Join(" ", recommendations);
    }

    public int GetSecurityScore()
    {
        var score = 0;

        score += 20; // Base score
        if (HasValidChecksum) score += 25;
        if (MimeTypeMatches) score += 20;
        if (IsLegalDocumentFormat) score += 15;
        if (!HasSecurityIssues) score += 20;

        return Math.Max(0, Math.Min(100, score));
    }
}

#endregion Supporting Data Classes